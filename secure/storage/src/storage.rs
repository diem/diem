// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::{
    CryptoStorage, Error, GetResponse, GitHubStorage, InMemoryStorage, KVStorage,
    NamespacedStorage, OnDiskStorage, PublicKeyResponse, Value, VaultStorage,
};
use core::convert::From;
use libra_crypto::{
    ed25519::{Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature},
    HashValue,
};

/// This is the Libra interface into secure storage. Any storage engine implementing this trait
/// should support both key/value operations (e.g., get, set and create) and cryptographic key
/// operations (e.g., generate_key, sign_message and rotate_key).

/// This is a hack that allows us to convert from SecureBackend into a useable
/// T: Storage. This boilerplate can be 100% generated by a proc macro.
/// TODO(fga): generate this boilerplate with a macro (e.g. `enum_dispatch`).
pub enum BoxedStorage {
    GitHubStorage(GitHubStorage),
    VaultStorage(VaultStorage),
    InMemoryStorage(InMemoryStorage),
    NamespacedStorage(NamespacedStorage),
    OnDiskStorage(OnDiskStorage),
}
impl From<GitHubStorage> for BoxedStorage {
    fn from(v: GitHubStorage) -> BoxedStorage {
        BoxedStorage::GitHubStorage(v)
    }
}
impl From<VaultStorage> for BoxedStorage {
    fn from(v: VaultStorage) -> BoxedStorage {
        BoxedStorage::VaultStorage(v)
    }
}
impl From<InMemoryStorage> for BoxedStorage {
    fn from(v: InMemoryStorage) -> BoxedStorage {
        BoxedStorage::InMemoryStorage(v)
    }
}
impl From<NamespacedStorage> for BoxedStorage {
    fn from(v: NamespacedStorage) -> BoxedStorage {
        BoxedStorage::NamespacedStorage(v)
    }
}
impl From<OnDiskStorage> for BoxedStorage {
    fn from(v: OnDiskStorage) -> BoxedStorage {
        BoxedStorage::OnDiskStorage(v)
    }
}

impl KVStorage for BoxedStorage {
    #[inline]
    fn available(&self) -> Result<(), Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => KVStorage::available(inner),
            BoxedStorage::VaultStorage(inner) => KVStorage::available(inner),
            BoxedStorage::InMemoryStorage(inner) => KVStorage::available(inner),
            BoxedStorage::NamespacedStorage(inner) => KVStorage::available(inner),
            BoxedStorage::OnDiskStorage(inner) => KVStorage::available(inner),
        }
    }
    #[inline]
    fn get(&self, key: &str) -> Result<GetResponse, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => KVStorage::get(inner, key),
            BoxedStorage::VaultStorage(inner) => KVStorage::get(inner, key),
            BoxedStorage::InMemoryStorage(inner) => KVStorage::get(inner, key),
            BoxedStorage::NamespacedStorage(inner) => KVStorage::get(inner, key),
            BoxedStorage::OnDiskStorage(inner) => KVStorage::get(inner, key),
        }
    }
    #[inline]
    fn set(&mut self, key: &str, value: Value) -> Result<(), Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => KVStorage::set(inner, key, value),
            BoxedStorage::VaultStorage(inner) => KVStorage::set(inner, key, value),
            BoxedStorage::InMemoryStorage(inner) => KVStorage::set(inner, key, value),
            BoxedStorage::NamespacedStorage(inner) => KVStorage::set(inner, key, value),
            BoxedStorage::OnDiskStorage(inner) => KVStorage::set(inner, key, value),
        }
    }
    #[inline]
    #[cfg(any(test, feature = "testing"))]
    fn reset_and_clear(&mut self) -> Result<(), Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => KVStorage::reset_and_clear(inner),
            BoxedStorage::VaultStorage(inner) => KVStorage::reset_and_clear(inner),
            BoxedStorage::InMemoryStorage(inner) => KVStorage::reset_and_clear(inner),
            BoxedStorage::NamespacedStorage(inner) => KVStorage::reset_and_clear(inner),
            BoxedStorage::OnDiskStorage(inner) => KVStorage::reset_and_clear(inner),
        }
    }
}
impl CryptoStorage for BoxedStorage {
    #[inline]
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => CryptoStorage::create_key(inner, name),
            BoxedStorage::VaultStorage(inner) => CryptoStorage::create_key(inner, name),
            BoxedStorage::InMemoryStorage(inner) => CryptoStorage::create_key(inner, name),
            BoxedStorage::NamespacedStorage(inner) => CryptoStorage::create_key(inner, name),
            BoxedStorage::OnDiskStorage(inner) => CryptoStorage::create_key(inner, name),
        }
    }
    #[inline]
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => CryptoStorage::export_private_key(inner, name),
            BoxedStorage::VaultStorage(inner) => CryptoStorage::export_private_key(inner, name),
            BoxedStorage::InMemoryStorage(inner) => CryptoStorage::export_private_key(inner, name),
            BoxedStorage::NamespacedStorage(inner) => {
                CryptoStorage::export_private_key(inner, name)
            }
            BoxedStorage::OnDiskStorage(inner) => CryptoStorage::export_private_key(inner, name),
        }
    }
    #[inline]
    fn import_private_key(&mut self, _name: &str, _key: Ed25519PrivateKey) -> Result<(), Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => {
                CryptoStorage::import_private_key(inner, _name, _key)
            }
            BoxedStorage::VaultStorage(inner) => {
                CryptoStorage::import_private_key(inner, _name, _key)
            }
            BoxedStorage::InMemoryStorage(inner) => {
                CryptoStorage::import_private_key(inner, _name, _key)
            }
            BoxedStorage::NamespacedStorage(inner) => {
                CryptoStorage::import_private_key(inner, _name, _key)
            }
            BoxedStorage::OnDiskStorage(inner) => {
                CryptoStorage::import_private_key(inner, _name, _key)
            }
        }
    }
    #[inline]
    fn export_private_key_for_version(
        &self,
        name: &str,
        version: Ed25519PublicKey,
    ) -> Result<Ed25519PrivateKey, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => {
                CryptoStorage::export_private_key_for_version(inner, name, version)
            }
            BoxedStorage::VaultStorage(inner) => {
                CryptoStorage::export_private_key_for_version(inner, name, version)
            }
            BoxedStorage::InMemoryStorage(inner) => {
                CryptoStorage::export_private_key_for_version(inner, name, version)
            }
            BoxedStorage::NamespacedStorage(inner) => {
                CryptoStorage::export_private_key_for_version(inner, name, version)
            }
            BoxedStorage::OnDiskStorage(inner) => {
                CryptoStorage::export_private_key_for_version(inner, name, version)
            }
        }
    }
    #[inline]
    fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => CryptoStorage::get_public_key(inner, name),
            BoxedStorage::VaultStorage(inner) => CryptoStorage::get_public_key(inner, name),
            BoxedStorage::InMemoryStorage(inner) => CryptoStorage::get_public_key(inner, name),
            BoxedStorage::NamespacedStorage(inner) => CryptoStorage::get_public_key(inner, name),
            BoxedStorage::OnDiskStorage(inner) => CryptoStorage::get_public_key(inner, name),
        }
    }
    #[inline]
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => CryptoStorage::rotate_key(inner, name),
            BoxedStorage::VaultStorage(inner) => CryptoStorage::rotate_key(inner, name),
            BoxedStorage::InMemoryStorage(inner) => CryptoStorage::rotate_key(inner, name),
            BoxedStorage::NamespacedStorage(inner) => CryptoStorage::rotate_key(inner, name),
            BoxedStorage::OnDiskStorage(inner) => CryptoStorage::rotate_key(inner, name),
        }
    }
    #[inline]
    fn sign_message(&mut self, name: &str, message: &HashValue) -> Result<Ed25519Signature, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => CryptoStorage::sign_message(inner, name, message),
            BoxedStorage::VaultStorage(inner) => CryptoStorage::sign_message(inner, name, message),
            BoxedStorage::InMemoryStorage(inner) => {
                CryptoStorage::sign_message(inner, name, message)
            }
            BoxedStorage::NamespacedStorage(inner) => {
                CryptoStorage::sign_message(inner, name, message)
            }
            BoxedStorage::OnDiskStorage(inner) => CryptoStorage::sign_message(inner, name, message),
        }
    }
    #[inline]
    fn sign_message_using_version(
        &mut self,
        name: &str,
        version: Ed25519PublicKey,
        message: &HashValue,
    ) -> Result<Ed25519Signature, Error> {
        match self {
            BoxedStorage::GitHubStorage(inner) => {
                CryptoStorage::sign_message_using_version(inner, name, version, message)
            }
            BoxedStorage::VaultStorage(inner) => {
                CryptoStorage::sign_message_using_version(inner, name, version, message)
            }
            BoxedStorage::InMemoryStorage(inner) => {
                CryptoStorage::sign_message_using_version(inner, name, version, message)
            }
            BoxedStorage::NamespacedStorage(inner) => {
                CryptoStorage::sign_message_using_version(inner, name, version, message)
            }
            BoxedStorage::OnDiskStorage(inner) => {
                CryptoStorage::sign_message_using_version(inner, name, version, message)
            }
        }
    }
}
