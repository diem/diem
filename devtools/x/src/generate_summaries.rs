// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::context::XContext;
use anyhow::{anyhow, Context};
use guppy::graph::{
    cargo::CargoOptions,
    feature::{all_filter, default_filter, FeatureQuery},
};
use std::{
    fs,
    path::{Path, PathBuf},
};
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
pub struct Args {
    #[structopt(name = "OUT_DIR")]
    /// Directory to output summaries to (default: target/summaries)
    out_dir: Option<PathBuf>,
}

impl Args {
    const DEFAULT_OUT_DIR: &'static str = "target/summaries";
}

pub fn run(args: Args, xctx: XContext) -> crate::Result<()> {
    let config = xctx.config();
    let summaries_config = config.summaries_config();
    let workspace_config = config.workspace_config();
    let pkg_graph = xctx.core().package_graph()?;
    let feature_graph = pkg_graph.feature_graph();
    let default_members = xctx.core().default_members()?;

    let default_opts = summaries_config.default.to_cargo_options(pkg_graph)?;
    let full_opts = summaries_config.full.to_cargo_options(pkg_graph)?;

    let out_dir = args
        .out_dir
        .unwrap_or_else(|| xctx.core().project_root().join(Args::DEFAULT_OUT_DIR));

    fs::create_dir_all(&out_dir)?;

    // TODO: figure out a way to unify this with WorkspaceSubset.

    // Create summaries for:

    let mut summary_count = 0;

    // * default members (default features)
    // (note that we aren't using the build set from default_members() as it may have different
    // options)
    let feature_query = default_members.build_set().original_query().clone();
    write_summary("default", feature_query, &default_opts, &out_dir)?;

    summary_count += 1;

    // * subsets (default features)
    for (name, subset_config) in &workspace_config.subsets {
        // TODO: cache these next to PackageGraph?
        let package_query = pkg_graph
            .query_workspace_paths(subset_config.members.iter().map(|path| path.as_path()))
            .with_context(|| anyhow!("error while querying workspace paths for {}", name))?;
        let feature_query = feature_graph.query_packages(&package_query, default_filter());
        write_summary(name, feature_query, &default_opts, &out_dir)?;

        summary_count += 1;
    }

    // * full workspace set (all features)
    let package_query = pkg_graph.query_workspace();
    let feature_query = feature_graph.query_packages(&package_query, all_filter());
    write_summary("full", feature_query, &full_opts, &out_dir)?;

    summary_count += 1;

    println!("wrote {} summaries to {}", summary_count, out_dir.display());

    Ok(())
}

fn write_summary(
    name: &str,
    feature_query: FeatureQuery<'_>,
    cargo_opts: &CargoOptions<'_>,
    out_dir: &Path,
) -> crate::Result<()> {
    let build_set = feature_query.resolve_cargo(cargo_opts)?;

    let mut out = format!(
        "# Summary for Libra subset '{}'. @generated by x.\n\
         # To regenerate, run 'cargo x generate-summaries'.\n\n",
        name
    );
    build_set
        .to_summary(cargo_opts)?
        .write_to_string(&mut out)
        .with_context(|| anyhow!("error while generating summary for '{}'", name))?;

    let summary_path = out_dir.join(format!("summary-{}.toml", name));

    fs::write(&summary_path, &out).with_context(|| {
        anyhow!(
            "error while writing summary file {}",
            summary_path.display()
        )
    })
}
