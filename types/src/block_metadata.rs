use crate::account_address::AccountAddress;
use crate::byte_array::ByteArray;
use canonical_serialization::{
    CanonicalDeserialize, CanonicalDeserializer, CanonicalSerialize, CanonicalSerializer,
    SimpleSerializer,
};
use crypto::{ed25519::Ed25519Signature, HashValue};
use failure::prelude::*;
use std::collections::BTreeMap;

/// Struct that will be persisted on chain to store the information of the current block.
///
/// The flow will look like following:
/// 1. The executor will pass this struct to VM at the end of a block proposal.
/// 2. The VM will use this struct to create a special system transaction that will modify the on
///    chain resource that represents the information of the current block. This transaction can't
///    be emitted by regular users and is generated by each of the validators on the fly. Such
///    transaction will be executed before all of the user-submitted transactions in the blocks.
/// 3. Once that special resource is modified, the other user transactions can read the consensus
///    info by calling into the read method of that resource, which would thus give users the
///    information such as the current leader.
#[derive(Debug, PartialEq, Eq)]
pub struct BlockMetaData {
    id: HashValue,
    timestamp_usec: u64,
    // Since Move doesn't support hashmaps, this vote map would be stored as a vector of key value
    // pairs in the Move module. Thus we need a BTreeMap here to define how the values are being
    // ordered.
    previous_block_votes: BTreeMap<AccountAddress, Ed25519Signature>,
    proposer: AccountAddress,
}

impl BlockMetaData {
    pub fn new(
        id: HashValue,
        timestamp_usec: u64,
        previous_block_votes: BTreeMap<AccountAddress, Ed25519Signature>,
        proposer: AccountAddress,
    ) -> Self {
        Self {
            id,
            timestamp_usec,
            previous_block_votes,
            proposer,
        }
    }

    pub fn into_inner(self) -> Result<(ByteArray, u64, ByteArray, AccountAddress)> {
        let id = ByteArray::new(self.id.to_vec());
        let vote_maps = {
            let mut serializer = SimpleSerializer::new();
            serializer.encode_btreemap(&self.previous_block_votes)?;
            ByteArray::new(serializer.get_output())
        };
        Ok((id, self.timestamp_usec, vote_maps, self.proposer))
    }
}

impl CanonicalSerialize for BlockMetaData {
    fn serialize(&self, serializer: &mut impl CanonicalSerializer) -> Result<()> {
        serializer
            .encode_bytes(self.id.as_ref())?
            .encode_u64(self.timestamp_usec)?
            .encode_btreemap(&self.previous_block_votes)?
            .encode_struct(&self.proposer)?;
        Ok(())
    }
}

impl CanonicalDeserialize for BlockMetaData {
    fn deserialize(deserializer: &mut impl CanonicalDeserializer) -> Result<Self> {
        let id = HashValue::from_slice(deserializer.decode_bytes()?.as_slice())?;
        let timestamp_usec = deserializer.decode_u64()?;
        let previous_block_votes = deserializer.decode_btreemap()?;
        let proposer = deserializer.decode_struct()?;
        Ok(Self {
            id,
            timestamp_usec,
            previous_block_votes,
            proposer,
        })
    }
}
