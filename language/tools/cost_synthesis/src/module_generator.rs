// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

//! Logic for random valid module and module universe generation.
//!
//! This module contains the logic for generating random valid modules and valid (rooted) module
//! universes. Note that we do not generate valid function bodies for the functions that are
//! generated -- any function bodies that are generated are simply non-semantic sequences of
//! instructions to check BrTrue, BrFalse, and Branch instructions.
use crate::common::*;
use bytecode_verifier::VerifiedModule;
use rand::{rngs::StdRng, Rng, SeedableRng};
use std::collections::HashMap;
use types::{account_address::AccountAddress, byte_array::ByteArray, language_storage::ModuleId};
use vm::{
    access::*,
    file_format::{
        AddressPoolIndex, Bytecode, CodeUnit, CompiledModule, CompiledModuleMut, FieldDefinition,
        FieldDefinitionIndex, FunctionDefinition, FunctionHandle, FunctionHandleIndex,
        FunctionSignature, FunctionSignatureIndex, Kind, LocalsSignature, LocalsSignatureIndex,
        MemberCount, ModuleHandle, ModuleHandleIndex, SignatureToken, StringPoolIndex,
        StructDefinition, StructHandle, StructHandleIndex, TableIndex, TypeSignature,
        TypeSignatureIndex,
    },
    internals::ModuleIndex,
};

/// A wrapper around a `CompiledModule` containing information needed for generation.
///
/// Contains a source of pseudo-randomness along with a table of the modules that are known and can
/// be called into -- these are all modules that have previously been generated by the same
/// instance of the `ModuleBuilder`.
///
/// The call graph between generated modules forms a rooted DAG based at the current
/// `CompiledModule` being generated.
pub struct ModuleBuilder {
    /// The source of randomness used across the modules that we generate.
    gen: StdRng,

    /// The current module being built.
    module: CompiledModuleMut,

    /// The minimum size of the tables in the generated module.
    table_size: TableIndex,

    /// Other modules that we know, and that we can generate calls type references into. Indexed by
    /// their address and name (i.e. the module's `ModuleId`).
    known_modules: HashMap<ModuleId, CompiledModule>,
}

impl ModuleBuilder {
    /// Create a new module builder with generated module tables of size `table_size`.
    pub fn new(table_size: TableIndex) -> Self {
        let seed: [u8; 32] = [0; 32];
        Self {
            gen: StdRng::from_seed(seed),
            module: Self::default_module_with_types(),
            table_size,
            known_modules: HashMap::new(),
        }
    }

    /// Display the current module being generated.
    pub fn display(&self) {
        println!("{:#?}", self.module)
    }

    fn with_account_addresses(&mut self) {
        let mut addrs = (0..self.table_size)
            .map(|_| AccountAddress::random())
            .collect();
        self.module.address_pool.append(&mut addrs);
    }

    fn with_strings(&mut self) {
        let mut strs = (0..self.table_size)
            .map(|_| {
                let len = self.gen.gen_range(1, MAX_STRING_SIZE);
                (0..len).map(|_| self.gen.gen::<char>()).collect()
            })
            .collect();
        self.module.string_pool.append(&mut strs);
    }

    fn with_bytearrays(&mut self) {
        self.module.byte_array_pool = (0..self.table_size)
            .map(|_| {
                let len = self.gen.gen_range(1, BYTE_ARRAY_MAX_SIZE);
                let bytes = (0..len).map(|_| self.gen.gen::<u8>()).collect();
                ByteArray::new(bytes)
            })
            .collect();
    }

    // Add the functions with locals given by the first part of the tuple, and with function
    // signature `FunctionSignature`.
    fn with_functions(&mut self, sigs: Vec<(Vec<SignatureToken>, FunctionSignature)>) {
        let mut names: Vec<String> = sigs
            .iter()
            .enumerate()
            .map(|(i, _)| format!("func{}", i))
            .collect();
        // Grab the offset before adding the generated names to the string pool; we'll need this
        // later on when we generate the function handles in order to know where we should have the
        // functions point to for their name.
        let offset = self.module.string_pool.len();
        let function_sig_offset = self.module.function_signatures.len();
        self.module.string_pool.append(&mut names);

        self.module.function_defs = sigs
            .iter()
            .enumerate()
            .map(|(i, _)| FunctionDefinition {
                function: FunctionHandleIndex::new(i as u16),
                flags: CodeUnit::PUBLIC,
                code: CodeUnit {
                    max_stack_size: 20,
                    locals: LocalsSignatureIndex(i as u16),
                    // Random nonsense to pad this out. We won't look at this at all, just
                    // non-empty is all that matters.
                    code: vec![Bytecode::Sub, Bytecode::Sub, Bytecode::Add, Bytecode::Ret],
                },
            })
            .collect();

        self.module.function_handles = sigs
            .iter()
            .enumerate()
            .map(|(i, _)| FunctionHandle {
                name: StringPoolIndex::new((i + offset) as u16),
                signature: FunctionSignatureIndex::new((i + function_sig_offset) as u16),
                module: ModuleHandleIndex::new(0),
            })
            .collect();
        let (local_sigs, mut function_sigs): (Vec<_>, Vec<_>) = sigs.into_iter().unzip();
        self.module.function_signatures.append(&mut function_sigs);
        self.module
            .locals_signatures
            .append(&mut local_sigs.into_iter().map(LocalsSignature).collect());
    }

    // Generate `table_size` number of structs. Note that this will not generate nested structs.
    // The overall logic of this function follows very similarly to that for function generation.
    fn with_structs(&mut self) {
        // Generate struct names.
        let mut names: Vec<String> = (0..self.table_size)
            .map(|i| format!("struct{}", i))
            .collect();
        let offset = self.module.string_pool.len() as TableIndex;
        self.module.string_pool.append(&mut names);

        // Generate the field definitions and struct definitions at the same time
        for struct_idx in 0..self.table_size {
            // Generate a random amount of fields for each struct. Each struct must have at least
            // one field.
            let num_fields = self.gen.gen_range(1, MAX_FIELDS);

            // Generate the struct def. This generates pointers into the module's `field_defs` that
            // are not generated just yet -- we do this beforehand so that we can grab the starting
            // index into the module's `field_defs` table before we generate the struct's fields.
            let struct_def = StructDefinition {
                struct_handle: StructHandleIndex(struct_idx),
                field_count: num_fields as MemberCount,
                fields: FieldDefinitionIndex::new(self.module.field_defs.len() as TableIndex),
            };
            self.module.struct_defs.push(struct_def);

            // Generate the fields for the struct.
            for _ in 0..num_fields {
                let struct_handle_idx = StructHandleIndex::new(struct_idx);
                // Pick a random base type (non-reference)
                let typ_idx = TypeSignatureIndex::new(
                    self.gen
                        .gen_range(0, self.module.type_signatures.len() as TableIndex),
                );
                // Pick a random name.
                let str_pool_idx = StringPoolIndex::new(
                    self.gen
                        .gen_range(0, self.module.string_pool.len() as TableIndex),
                );
                let field_def = FieldDefinition {
                    struct_: struct_handle_idx,
                    name: str_pool_idx,
                    signature: typ_idx,
                };
                self.module.field_defs.push(field_def);
            }
        }

        // Generate the struct handles. This needs to be in sync with the names that we generated
        // earlier at the start of this function.
        self.module.struct_handles = (0..self.table_size)
            .map(|struct_idx| StructHandle {
                module: ModuleHandleIndex::new(0),
                name: StringPoolIndex::new((struct_idx + offset) as TableIndex),
                kind: if self.gen.gen_bool(1.0 / 2.0) {
                    Kind::Resource
                } else {
                    Kind::Copyable
                },
                kind_constraints: vec![],
            })
            .collect();
    }

    // Generate `table_size` number of functions in the underlying module. This does this by
    // generating a bunch of random locals type signatures (Vec<SignatureToken>) and the
    // FunctionSignatures. We then call `with_functions` with this generated type info.
    fn with_random_functions(&mut self) {
        use SignatureToken::*;
        // The base signature tokens that we can use for our types.
        let sig_toks = vec![Bool, U64, String, ByteArray, Address];
        // Generate a bunch of random function signatures over these types.
        let functions = (0..self.table_size)
            .map(|_| {
                let num_locals = self.gen.gen_range(1, MAX_NUM_LOCALS);
                let num_args = self.gen.gen_range(1, MAX_FUNCTION_CALL_SIZE);

                let locals = (0..num_locals)
                    .map(|_| {
                        let index = self.gen.gen_range(0, sig_toks.len());
                        sig_toks[index].clone()
                    })
                    .collect();

                let args = (0..num_args)
                    .map(|_| {
                        let index = self.gen.gen_range(0, sig_toks.len());
                        sig_toks[index].clone()
                    })
                    .collect();

                // Generate the function signature. We don't care about the return type of the
                // function, so we don't generate any types, and default to saying that it returns
                // the unit type.
                let function_sig = FunctionSignature {
                    arg_types: args,
                    return_types: vec![],
                    kind_constraints: vec![],
                };

                (locals, function_sig)
            })
            .collect();

        self.with_cross_calls();
        self.with_functions(functions);
    }

    fn with_cross_calls(&mut self) {
        let module_table_size = self.module.module_handles.len();
        if module_table_size < 2 {
            return;
        }

        // We have half/half inter- and intra-module calls.
        let number_of_cross_calls = self.table_size;
        for _ in 0..number_of_cross_calls {
            let non_self_module_handle_idx = self.gen.gen_range(1, module_table_size);
            let callee_module_handle = &self.module.module_handles[non_self_module_handle_idx];
            let address = self.module.address_pool[callee_module_handle.address.into_index()];
            let name = &self.module.string_pool[callee_module_handle.name.into_index()];
            let module_id = ModuleId::new(address, name.to_string());
            let callee_module = self
                .known_modules
                .get(&module_id)
                .expect("[Module Lookup] Unable to get module from known_modules.");

            let callee_function_handle_idx = self
                .gen
                .gen_range(0, callee_module.function_handles().len())
                as TableIndex;
            let callee_function_handle = callee_module
                .function_handle_at(FunctionHandleIndex::new(callee_function_handle_idx));
            let callee_type_sig = callee_module
                .function_signature_at(callee_function_handle.signature)
                .clone();
            let callee_name = callee_module
                .string_at(callee_function_handle.name)
                .to_string();
            let callee_name_idx = self.module.string_pool.len() as TableIndex;
            let callee_type_sig_idx = self.module.function_signatures.len() as TableIndex;
            let func_handle = FunctionHandle {
                module: ModuleHandleIndex::new(non_self_module_handle_idx as TableIndex),
                name: StringPoolIndex::new(callee_name_idx),
                signature: FunctionSignatureIndex::new(callee_type_sig_idx),
            };

            self.module.string_pool.push(callee_name);
            self.module.function_signatures.push(callee_type_sig);
            self.module.function_handles.push(func_handle);
        }
    }

    // Add the modules identitied by their code keys to the module handles of the underlying
    // CompiledModule.
    fn with_callee_modules(&mut self) {
        // Add the SELF module
        let module_name: String = (0..10).map(|_| self.gen.gen::<char>()).collect();
        self.module.string_pool.insert(0, module_name);
        self.module.address_pool.insert(0, AccountAddress::random());
        // Recall that we inserted the module name at index 0 in the string pool.
        let self_module_handle = ModuleHandle {
            address: AddressPoolIndex::new(0),
            name: StringPoolIndex::new(0),
        };
        self.module.module_handles.insert(0, self_module_handle);

        let (mut names, mut addresses) = self
            .known_modules
            .keys()
            .map(|key| (key.name().clone(), key.address()))
            .unzip();

        let address_pool_offset = self.module.address_pool.len() as TableIndex;
        let string_pool_offset = self.module.string_pool.len() as TableIndex;
        // Add the strings and addresses to the pool
        self.module.string_pool.append(&mut names);
        self.module.address_pool.append(&mut addresses);

        let mut module_handles = (0..self.known_modules.len())
            .map(|i| {
                let i = i as TableIndex;
                ModuleHandle {
                    address: AddressPoolIndex::new(address_pool_offset + i),
                    name: StringPoolIndex::new(string_pool_offset + i),
                }
            })
            .collect();
        self.module.module_handles.append(&mut module_handles);
    }

    /// This method builds and then materializes the underlying module skeleton. It then swaps in a
    /// new module skeleton, adds the generated module to the `known_modules`, and returns
    /// the generated module.
    pub fn materialize(&mut self) -> VerifiedModule {
        self.with_callee_modules();
        self.with_account_addresses();
        self.with_strings();
        self.with_bytearrays();
        self.with_random_functions();
        self.with_structs();
        let module = std::mem::replace(&mut self.module, Self::default_module_with_types());
        let module = module.freeze().expect("should satisfy bounds checker");
        self.known_modules.insert(module.self_id(), module.clone());
        // We don't expect the module to pass the verifier at the moment. This is OK because it
        // isn't part of the core code path, just something done to the side.
        VerifiedModule::bypass_verifier_DANGEROUS_FOR_TESTING_ONLY(module)
    }

    // This method generates a default (empty) `CompiledModuleMut` but with base types. This way we
    // can point to them when generating structs/functions etc.
    fn default_module_with_types() -> CompiledModuleMut {
        use SignatureToken::*;
        let mut module = CompiledModuleMut::default();
        module.type_signatures = vec![Bool, U64, String, ByteArray, Address]
            .into_iter()
            .map(TypeSignature)
            .collect();
        module
    }
}

/// A wrapper around a `ModuleBuilder` for building module universes.
///
/// The `ModuleBuilder` is already designed to build module universes but the size of this universe
/// is unspecified and un-iterable. This is a simple wrapper around the builder that allows
/// the implementation of the `Iterator` trait over it.
pub struct ModuleGenerator {
    module_builder: ModuleBuilder,
    iters: u64,
}

impl ModuleGenerator {
    /// Create a new `ModuleGenerator` where each generated module has at least `table_size`
    /// elements in each table, and where `iters` many modules are generated.
    pub fn new(table_size: TableIndex, iters: u64) -> Self {
        Self {
            module_builder: ModuleBuilder::new(table_size),
            iters,
        }
    }
}

impl Iterator for ModuleGenerator {
    type Item = VerifiedModule;
    fn next(&mut self) -> Option<Self::Item> {
        if self.iters == 0 {
            None
        } else {
            self.iters -= 1;
            Some(self.module_builder.materialize())
        }
    }
}
