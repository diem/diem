//! account: vivian, 1000000, 0, validator
//! account: alice, 10000000
//! account: bob, 10000000
//! channel: ch1, alice|bob

//! new-transaction
//! sender: alice
import 0x0.LibraAccount;
main(){
    LibraAccount.enable_channel();
    return;
}

//! new-transaction
//! sender: bob
import 0x0.LibraAccount;
main(){
    LibraAccount.enable_channel();
    return;
}

//! new-transaction
//! sender: alice
//! txn-channel: ch1, alice
//! args: {{bob}},50000,40000

0x0.ChannelScript.open


//! new-transaction
//! sender: alice
//! txn-channel: ch1,alice
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   let hash_lock: bytearray;
   hash_lock = Hash.sha3_256(h"aa");
   ChannelScript.send_payment({{bob}}, 10000, move(hash_lock), 10);
      assert(LibraAccount.channel_balance({{alice}}) == 40000, 106);
      assert(LibraAccount.channel_balance({{bob}}) == 40000, 107);
   return;
}

// bob execute channel transaction without alice signature.
//! new-transaction
//! sender: bob
//! txn-channel: ch1,bob,false
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   ChannelScript.receive_payment(h"aa");
   assert(LibraAccount.channel_balance({{alice}}) == 40000, 106);
   assert(LibraAccount.channel_balance({{bob}}) == 50000, 107);
   return;
}

//! new-transaction
//! sender: alice
//! txn-channel: ch1,bob
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   assert(LibraAccount.channel_is_locked(), 108);
   LibraAccount.resolve();
   assert(!LibraAccount.channel_is_locked(), 109);
   return;
}

// bob execute channel transaction without alice signature.
//! new-transaction
//! sender: bob
//! txn-channel: ch1,bob,false
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   return;
   // channel will be locked by bob in channel_epilogue()
}

// alice
//! new-transaction
//! sender: alice
//! txn-channel: ch1,alice,false
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   assert(LibraAccount.channel_is_locked(), 108);
   LibraAccount.resolve();
   // channel is unlocked
   assert(!LibraAccount.channel_is_locked(), 109);
   return;
   // channel will be unlocked by alice in channel_epilogue()
}

// bob execute channel transaction without alice signature.
//! new-transaction
//! sender: bob
//! txn-channel: ch1,bob,false
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   assert(LibraAccount.channel_balance({{alice}}) == 40000, 106);
   assert(LibraAccount.channel_balance({{bob}}) == 50000, 107);
   return;
   // channel is locked by bob
}

//! new-transaction
import 0x0.LibraSystem;
main() {
    // TODO: this will stop working once we make the Block prologue private. We should delete this
    // part (which will be done by the executor) and leave the second assert
    LibraSystem.block_prologue(1, h"aa", h"bb", {{vivian}});
    LibraSystem.block_prologue(2, h"aa", h"bb", {{vivian}});
    LibraSystem.block_prologue(3, h"aa", h"bb", {{vivian}});
    return;
}

// bob invoke close() after lock timeout
//! new-transaction
//! sender: bob
//! txn-channel: ch1,bob,false
import 0x0.ChannelTransaction;
import 0x0.ChannelScript;
import 0x0.LibraAccount;
import 0x0.Hash;
main() {
   assert(LibraAccount.channel_balance({{alice}}) == 40000, 106);
   assert(LibraAccount.channel_balance({{bob}}) == 50000, 107);
   LibraAccount.close({{alice}});
   // currently resource confiscation only happens after challenge succeed
   // lock timeout doesn't confiscate resource
   assert(LibraAccount.channel_balance({{alice}}) == 40000, 106);
   assert(LibraAccount.channel_balance({{bob}}) == 50000, 107);
   return;
}