//! account: vivian, 1000000, 0, validator
//! account: alice, 10000000
//! account: bob, 10000000

//! new-transaction
//! sender: alice
//! args: {{bob}}
import 0x0.LibraAccount;
import 0x0.LibraCoin;
import 0x0.HashTimeLock;
import 0x0.Hash;
main(unlocker: address){
    let coin: LibraCoin.T;
    let hash_lock: bytearray;
    hash_lock = Hash.sha3_256(h"aa");
    coin = LibraAccount.withdraw_from_sender(10000);
    HashTimeLock.lock(move(unlocker), move(coin), move(hash_lock), 2);
    return;
}

//! new-transaction
import 0x0.LibraSystem;

main() {
    // TODO: this will stop working once we make the Block prologue private. We should delete this
    // part (which will be done by the executor) and leave the second assert
    LibraSystem.block_prologue(1, h"aa", h"bb", {{vivian}});
    LibraSystem.block_prologue(2, h"aa", h"bb", {{vivian}});
    LibraSystem.block_prologue(3, h"aa", h"bb", {{vivian}});
    return;
}

//! new-transaction
//! sender: bob
//! args: {{alice}}
import 0x0.LibraAccount;
import 0x0.LibraCoin;
import 0x0.HashTimeLock;
main(locker: address){
    let coin: LibraCoin.T;
    coin = HashTimeLock.unlock(move(locker), h"aa");
    LibraAccount.deposit(get_txn_sender(), move(coin));
    return;
}

// check: ABORTED
// check: 101

//! new-transaction
//! sender: alice
import 0x0.LibraAccount;
import 0x0.LibraCoin;
import 0x0.HashTimeLock;
main(){
    let coin: LibraCoin.T;
    coin = HashTimeLock.unlock_after_timeout();
    LibraAccount.deposit(get_txn_sender(), move(coin));
    return;
}