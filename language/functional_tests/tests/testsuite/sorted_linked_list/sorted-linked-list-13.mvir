//! account: sys
//! account: alice
//! account: bob
//! account: carol
//! account: david
//! account: eve

//! sender: sys
// Implements a sorted linked list in which everyone can insert a new node (e.g. for DNS)
// but only the list owner/node owner can remove a node
module SortedLinkedList
{
    resource Node
    {
        prev: address, //account address where the previous node is stored (head if no previous node exists)
        next: address, //account address where the next node is stored (head if no next node exists)
        head: address, //account address where current list's head is stored -- whoever stores head is the owner of the whole list
        value: u64 //TODO: make generic
    }

    //an empty resource whose possession signifies that the current address is the head of a list
    resource IsHeadNode {
        dummy: bool //had to add this dummy field because we currently cannot deallocate/unpack resources with no fields in the IR
    } 

    //creates a new list whose head is at txn_sender (is owned by the caller)
    public create_new_list()
    {
        let here: address;
        let head: Self.Node;
        let flag: Self.IsHeadNode;
        
        here = get_txn_sender();

        //make sure no node/list is already stored in this account
        assert(!exists<Node>(copy(here)), 1);
        assert(!exists<IsHeadNode>(copy(here)), 2);
        
        head = Node {
            prev: copy(here),
            next: copy(here),
            head: move(here),
            value: 0
        };
        move_to_sender<Node>(move(head));

        flag = IsHeadNode{dummy: true};
        move_to_sender<IsHeadNode>(move(flag));
        
        return;
    }

    //adds a node that is stored in txn_sender's account and whose location in the list is right after prev_node_address
    public add_node(value: u64, prev_node_address: address) acquires Node //TODO: make value generic
    {
        let here: address;
        let prev_node_ref: & Self.Node;
        let prev_node_mut_ref: &mut Self.Node;
        let next_node_address: address;
        let next_node_mut_ref: &mut Self.Node;
        let next_node_ref: & Self.Node;
        let prev_is_head: bool;
        let next_is_head: bool;
        let prev_value: u64; //TODO: make generic
        let next_value: u64; //TODO: make generic
        let current_node: Self.Node;
        let head_address: address;


        here = get_txn_sender();

        //make sure no node/list is already stored in this account
        assert(!exists<Node>(copy(here)), 3);
        assert(!exists<IsHeadNode>(copy(here)), 4);

        //make sure a node exists in prev_node_address
        assert(exists<Node>(copy(prev_node_address)), 5);

        //get a reference to prev_node and find the address and reference to next_node, head
        prev_node_ref = borrow_global<Node>(copy(prev_node_address));
        next_node_address = *&copy(prev_node_ref).next;
        next_node_ref = borrow_global<Node>(copy(next_node_address));
        head_address = *&copy(next_node_ref).head;

        //see if either prev or next are the head and get their values
        prev_is_head = exists<IsHeadNode>(copy(prev_node_address));
        next_is_head = exists<IsHeadNode>(copy(next_node_address));
        prev_value = *&move(prev_node_ref).value;
        next_value = *&move(next_node_ref).value;

        //check the order -- the list must be sorted
        assert(move(prev_is_head) || (move(prev_value) < copy(value)), 6);
        assert(move(next_is_head) || (move(next_value) > copy(value)), 7);

        //create the new node
        current_node = Node {
            prev: copy(prev_node_address),
            next: copy(next_node_address),
            head: move(head_address),
            value: move(value)
        };
        move_to_sender<Node>(move(current_node));

        //fix the pointers at prev
        prev_node_mut_ref = borrow_global_mut<Node>(move(prev_node_address));
        *&mut move(prev_node_mut_ref).next = copy(here);

        //fix the pointers at next
        next_node_mut_ref = borrow_global_mut<Node>(move(next_node_address));
        *&mut move(next_node_mut_ref).prev = copy(here);
        
        return;
    }

    //can only called by the list owner (head) -- removes the list if it is empty
    public remove_list() acquires Node, IsHeadNode
    {
        let here: address;
        let current_node_ref: & Self.Node;
        let next_node_address: address;
        let prev_node_address: address;
        let temp_address: address;
        let temp_value: u64; //TODO: make generic
        let temp_bool: bool;

        here = get_txn_sender();

        //don't do anything if there is no list head here
        if(!exists<IsHeadNode>(copy(here)))
        {
            return;
        }

        assert(exists<Node>(copy(here)), 8);
        current_node_ref = borrow_global<Node>(copy(here));

        //check that the list is empty
        next_node_address = *&copy(current_node_ref).next;
        prev_node_address = *&move(current_node_ref).prev;
        assert(move(next_node_address) == copy(here), 9);
        assert(move(prev_node_address) == copy(here), 10);

        //destroy the Node and the IsHeadNode
        Node{temp_address, temp_address, temp_address, temp_value} = move_from<Node>(copy(here));
        IsHeadNode{temp_bool} = move_from<IsHeadNode>(move(here));
        
        
        return;
    }

    //removes the current (non-head) node
    public remove_node_by_node_owner()  acquires Node
    {
        let here: address;        
        here = get_txn_sender();

        //make sure a node exists
        assert(exists<Node>(copy(here)), 11);

        //make sure it is not a head node (heads can be removed using remove_list)
        assert(!exists<IsHeadNode>(copy(here)),12);

        //remove it
        Self.remove_node(move(here));
        
        return;
    }

    public remove_node_by_list_owner(node_address: address) acquires Node
    {

        let node_ref: & Self.Node;
        let list_owner: address;
        
        //make sure the node exists
        assert(exists<Node>(copy(node_address)), 13);

        //make sure it is not a head node
        assert(!exists<IsHeadNode>(copy(node_address)), 14);

        //make sure the caller owns the list
        node_ref = borrow_global<Node>(copy(node_address));
        list_owner = *&move(node_ref).head;
        assert(move(list_owner) == get_txn_sender(), 15);

        //remove it
        Self.remove_node(move(node_address));
        
        return;
    }

    //private function used for removing a non-head node -- does not check permissions
    remove_node(node_address: address) acquires Node
    {
        let current_node_ref: & Self.Node;
        let next_node_address: address;
        let next_node_mut_ref: &mut Self.Node;
        let prev_node_address: address;
        let prev_node_mut_ref: &mut Self.Node;
        let temp_address: address;
        let temp_value: u64; //TODO: make generic

        //make sure the node exists
        assert(exists<Node>(copy(node_address)),16);
        
        //make sure it is not a head node
        assert(!exists<IsHeadNode>(copy(node_address)),17);
        
        //find prev and next
        current_node_ref = borrow_global<Node>(copy(node_address));
        next_node_address = *&copy(current_node_ref).next;
        prev_node_address = *&move(current_node_ref).prev;

        //update next
        next_node_mut_ref = borrow_global_mut<Node>(copy(next_node_address));
        *&mut move(next_node_mut_ref).prev = copy(prev_node_address);

        //update prev
        prev_node_mut_ref = borrow_global_mut<Node>(move(prev_node_address));
        *&mut move(prev_node_mut_ref).next = move(next_node_address);
        
        //destroy the current node
        Node {temp_address,temp_address,temp_address,temp_value} = move_from<Node>(move(node_address));
        
        return;
    }

    
}


//! new-transaction
//! sender: alice
//creating a new list
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.create_new_list();
    return;
}

//! new-transaction
//! sender: bob
//adding a new element to Alice's list 0@alice -> 10@bob
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.add_node(10, {{alice}});
    return;
}

//! new-transaction
//! sender: carol
//adding a node between Alice and Bob 0@alice -> 5@carol -> 10@bob
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.add_node(5, {{alice}});
    return;
}

//! new-transaction
//! sender: david
//adding a node after Bob 0@alice -> 5@carol -> 10@bob -> 15@david
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.add_node(15, {{bob}});
    return;
}

//! new-transaction
//! sender: eve
//adding a node between Carol and Bob 0@alice -> 5@carol -> 7@eve -> 10@bob -> 15@david
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.add_node(7, {{carol}});
    return;
}

//! new-transaction
//! sender: carol
//remove node  0@alice -> 7@eve -> 10@bob -> 15@david
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.remove_node_by_node_owner();
    return;
}

//! new-transaction
//! sender: carol
//add a new carol node elsewhere in the list 0@alice -> 7@eve -> 9@carol -> 10@bob -> 15@david
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.add_node(9, {{eve}});
    return;
}

//! new-transaction
//! sender: alice
//Alice removes Bob's node 0@alice -> 7@eve -> 9@carol -> 15@david
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.remove_node_by_list_owner({{bob}});
    return;
}

//! new-transaction
//! sender: alice
//Alice attempts to remove her list while it is not empty
import {{sys}}.SortedLinkedList;
main() {
    SortedLinkedList.remove_list();
    return;
}
//check: ABORTED
