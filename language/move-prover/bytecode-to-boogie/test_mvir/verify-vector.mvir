module VerifyVector {
    import 0x0.Vector;

    // succeeds. [] == [].
    public test_empty1() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        return (move(ev1), move(ev2));
    }

    //succeeds. [] == [].
    public test_empty2() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        let x: u64;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        x = Vector.pop_back<u64>(&mut ev1);
        return (move(ev1), move(ev2));
    }

    // succeeds. [1] == [1]
    public test_empty3() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        Vector.push_back<u64>(&mut ev2, 1);
        return (move(ev1), move(ev2));
    }

    //succeeds. [1,2] != [1].
    public test_empty4() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) != RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        Vector.push_back<u64>(&mut ev1, 2);
        Vector.push_back<u64>(&mut ev2, 1);
        return (move(ev1), move(ev2));
    }

    //succeeds. [1] != [0].
    public test_empty5() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) != RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        Vector.push_back<u64>(&mut ev2, 0);
        return (move(ev1), move(ev2));
    }

    // succeeds. reverse([]) == [].
    public test_reverse1() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.reverse<u64>(&mut ev1);
        return (move(ev1), move(ev2));
    }

    // succeeds. reverse([1,2]) == [2,1].
    public test_reverse2() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        Vector.push_back<u64>(&mut ev1, 2);
        Vector.push_back<u64>(&mut ev2, 2);
        Vector.push_back<u64>(&mut ev2, 1);
        Vector.reverse<u64>(&mut ev1);
        return (move(ev1), move(ev2));
    }

    // succeeds. Always aborts because the first index argument of `swap` is out-of-bounds.
    public test_swap1()
    aborts_if true
    {
        let ev1: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 0);
        Vector.swap<u64>(&mut ev1, 1, 0);
        return;
    }

    // succeeds. Always aborts because the second index argument of `swap` is out-of-bounds.
    public test_swap2()
    aborts_if true
    {
        let ev1: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 0);
        Vector.swap<u64>(&mut ev1, 0, 1);
        return;
    }

    // succeeds. swap([1,2],0,1) == [2,1].
    public test_swap3() : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        Vector.push_back<u64>(&mut ev1, 2);
        Vector.push_back<u64>(&mut ev2, 2);
        Vector.push_back<u64>(&mut ev2, 1);
        Vector.swap<u64>(&mut ev1, 0, 0);
        Vector.swap<u64>(&mut ev1, 0, 1);
        return (move(ev1), move(ev2));
    }

    // succeeds. length([1]) = length([]) + 1.
    public test_length1() : u64 * u64
    ensures RET(0) == RET(1) + 1
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        return (Vector.length<u64>(& ev1), Vector.length<u64>(& ev2));
    }

    // succeeds. length(v) + 3 == length(v^[1]^[2]^[3]).
    public test_length2(v: Vector.T<u64>) : u64 * u64
    ensures RET(0) + 3 == RET(1)
    {
        let x: u64;
        let y: u64;
        x = Vector.length<u64>(& v);
        Vector.push_back<u64>(&mut v, 1);
        Vector.push_back<u64>(&mut v, 2);
        Vector.push_back<u64>(&mut v, 3);
        y = Vector.length<u64>(& v);
        return (move(x), move(y));
    }

    // succeeds. v == v.
    public test_id1(v: Vector.T<u64>) : Vector.T<u64>
    ensures RET(0) == old(v)
    {
        return (move(v));
    }

    // succeeds. reverse(reverse(v)) == v.
    public test_id2(v: Vector.T<u64>) : Vector.T<u64>
    ensures RET(0) == old(v)
    {
        Vector.reverse<u64>(&mut v);
        Vector.reverse<u64>(&mut v);
        return (move(v));
    }

    // succeeds. reverse(some_obscure_reverse_routine(v)) == v.
    public test_id3(v: Vector.T<u64>) : Vector.T<u64>
    ensures RET(0) == old(v)
    {
        let l: u64;
        l = Vector.length<u64>(& v);
        if(copy(l) <= 1) {
        }
        else {
            if (copy(l) <= 3) {
                Vector.swap<u64>(&mut v, 0, copy(l)-1);
            }
            else {
                Vector.reverse<u64>(&mut v);
            }
        }
        Vector.reverse<u64>(&mut v);
        return (move(v));
    }

    // succeeds. If the input vector is empty, destroy it, and return a new empty vector.
    public test_destroy_empty1(v: Vector.T<u64>) : Vector.T<u64>
    ensures RET(0) == old(v)
    {
        if (Vector.is_empty<u64>(& v)) {
            Vector.destroy_empty<u64>(move(v));
            return Vector.empty<u64>();
        }
        else {
            return move(v);
        }
    }

    // succeeds. Always aborts. If v is empty, attempt to access out-of-bounds. Otherwise, attempt to destroy the non-empty vector.
    public test_destroy_empty2(v: Vector.T<u64>)
    aborts_if true
    {
        if (Vector.is_empty<u64>(& v)) {
            Vector.set<u64>(&mut v, 0, 0);
        }
        else {
            Vector.destroy_empty<u64>(move(v));
        }
        return;
    }

    // succeeds. [x] == [x].
    public test_get_set1(x: u64) : Vector.T<u64> * Vector.T<u64>
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let ev2: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        ev2 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        Vector.push_back<u64>(&mut ev2, 2);
        Vector.set<u64>(&mut ev1, 0, move(x));
        Vector.set<u64>(&mut ev2, 0, Vector.get<u64>(& ev1, 0));
        return (move(ev1), move(ev2));
    }

    // succeeds.
    public test_get1() : u64
    ensures RET(0) == 7
    {
        let ev1: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 7);
        return Vector.get<u64>(&ev1, 0);
    }

    // succeeds. Always aborts due to the out-of-bounds index used.
    public test_get2()
    aborts_if true
    {
        let x : u64;
        let ev1: Vector.T<u64>;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 1);
        x = Vector.get<u64>(& ev1, 1);
        return;
    }

    // succeeds. 7 == 7.
    public test_borrow1() : u64 * u64
    ensures RET(0) == RET(1)
    {
        let ev1: Vector.T<u64>;
        let y : &u64;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 7);
        y = Vector.borrow<u64>(&ev1, 0);
        return (7, *move(y));
    }

    // succeeds. Always aborts due to the out-of-bounds index used.
    public test_borrow2() : u64 * u64
    aborts_if true
    ensures false
    {
        let ev1: Vector.T<u64>;
        let y : &u64;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 7);
        y = Vector.borrow<u64>(&ev1, 1);
        return (7, *move(y));
    }

    // succeeds. 0 != 7
    public test_borrow3() : u64 * u64
    ensures RET(0) != RET(1)
    {
        let ev1: Vector.T<u64>;
        let y : &u64;
        ev1 = Vector.empty<u64>();
        Vector.push_back<u64>(&mut ev1, 7);
        y = Vector.borrow<u64>(&ev1, 0);
        return (0, *move(y));
    }

    // succeeds.
    public my_length1(v: Vector.T< u64>): u64
    ensures vector_length(v) == RET(0)
    // TODO: spec_translator cannot handle the following post-conditions
    // ensures vector_length(v) + 1 == RET(0) // thread 'main' panicked at 'unexpected type', language/move-prover/bytecode-to-boogie/src/spec_translator.rs:343:18
    // ensures vector_length(v) < RET(0) + 1 // thread 'main' panicked at 'unexpected type', language/move-prover/bytecode-to-boogie/src/spec_translator.rs:343:18
    {
        return Vector.length<u64>(&v);
    }

    // succeeds. standard vector method (without type parameter).
    public my_length2(v: &Vector.T< u64>): u64
    ensures vector_length(*v) == RET(0)
    {
        return Vector.length<u64>(copy(v));
    }

    // succeeds. standard vector method.
    public my_length3<Element>(v: &Vector.T< Element>): u64
    ensures vector_length(*v) == RET(0)
    {
        return Vector.length<Element>(copy(v));
    }

    // succeeds.
    public my_get1(v: Vector.T<u64>, i: u64): u64
    aborts_if i >= vector_length(v)
    ensures RET(0) == vector_get(v, i)
    {
        return *Vector.borrow<u64>(&v, move(i));
    }

    // succeeds. standard vector method (without type parameter).
    public my_get2(v: &Vector.T<u64>, i: u64): u64
    aborts_if i >= vector_length(*v)
    ensures RET(0) == vector_get(*v, i)
    {
        return *Vector.borrow<u64>(move(v), move(i));
    }

    // succeeds.
    public my_get3(v: &Vector.T<u64>, i: u64): u64
    aborts_if i >= vector_length(*v)
    aborts_if vector_get(*v, i) == 0
    ensures RET(0) + 1 == vector_get(*v, i)
    {
        return *Vector.borrow<u64>(move(v), move(i)) - 1;
    }

    // succeeds. standard vector method.
    public my_get4<Element: unrestricted>(v: &Vector.T<Element>, i: u64): Element
    aborts_if i >= vector_length(*v)
    ensures RET(0) == vector_get(*v, i)
    {
        return *Vector.borrow<Element>(move(v), move(i));
    }

    // succeeds.
    public my_set1(v: Vector.T<u64>, i: u64, e: u64) : Vector.T<u64>
    aborts_if i >= vector_length(v)
    ensures RET(0) == vector_update(v, i, e)
    {
        *(Vector.borrow_mut<u64>(&mut v, move(i))) = move(e);
        return move(v);
    }

    // succeeds. standard vector method (without type parameter).
    public my_set2(v: &mut Vector.T<u64>, i: u64, e: u64)
    aborts_if i >= vector_length(*v)
    ensures *v == vector_update(old(*v), i, e)
    {
        *(Vector.borrow_mut<u64>(move(v), move(i))) = move(e);
        return;
    }

    // succeeds. standard vector method.
    public my_set3<Element: unrestricted>(v: &mut Vector.T<Element>, i: u64, e: Element)
    aborts_if i >= vector_length(*v)
    ensures *v == vector_update(old(*v), i, e)
    {
        *(Vector.borrow_mut<Element>(move(v), move(i))) = move(e);
        return;
    }

    // standard vector method (without type parameter).
    public my_is_empty(v: &Vector.T<u64>): bool
    // TODO: the following post-condition is not parsed.
    // ensures RET(0) == (vector_length(*v) == 0) // mvir parsing errors: ParserError: Invalid token at 10411
    {
        return Vector.length<u64>(move(v)) == 0;
    }

    // TODO: to test composition of helper functions
}
