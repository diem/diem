// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::common::{make_abi_enum_container, type_not_allowed};
use libra_types::transaction::{ArgumentABI, ScriptABI, TypeArgumentABI};
use move_core_types::language_storage::TypeTag;
use serde_generate::rust::output_with_external_dependencies_and_comments;

use heck::{CamelCase, ShoutySnakeCase};
use std::{
    collections::BTreeMap,
    io::{Result, Write},
    path::PathBuf,
};

/// Output transaction builders in Rust for the given ABIs.
/// If `local_types` is true, we generate a file suitable for the Libra codebase itself
/// rather than using serde-generated, standalone definitions.
pub fn output(out: &mut dyn Write, abis: &[ScriptABI], local_types: bool) -> Result<()> {
    output_preamble(out, local_types)?;
    output_script_call_enum_with_imports(out, abis, local_types)?;

    writeln!(out, "\nimpl ScriptCall {{")?;
    output_encode_method(out, abis)?;
    output_decode_method(out, local_types)?;
    writeln!(out, "\n}}")?;

    for abi in abis {
        output_script_encoder_function(out, abi, local_types)?;
    }

    for abi in abis {
        output_script_decoder_function(out, abi, local_types)?;
    }

    output_decoder_map(out, abis)?;
    output_decoding_helpers(out)?;

    for abi in abis {
        output_code_constant(out, abi)?;
    }
    Ok(())
}

fn output_preamble(out: &mut dyn Write, local_types: bool) -> Result<()> {
    if local_types {
        writeln!(
            out,
            r#"
// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To re-generate this code, run: `(cd language/stdlib && cargo run --release)`
"#
        )?;
    }
    writeln!(
        out,
        r#"//! Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
//! standard LCS-compatible representation used in Libra transactions (`Script`).
//!
//! This code was generated by compiling known Script interfaces ("ABIs") with the tool `transaction-builder-generator`.
"#
    )
}

fn output_script_call_enum_with_imports(
    out: &mut dyn Write,
    abis: &[ScriptABI],
    local_types: bool,
) -> Result<()> {
    let mut external_definitions = get_external_definitions(local_types);
    if local_types {
        external_definitions.insert("".to_string(), vec!["Bytes".to_string()]);
    }
    let script_registry: BTreeMap<_, _> =
        vec![("ScriptCall".to_string(), make_abi_enum_container(abis))]
            .into_iter()
            .collect();
    let mut comments: BTreeMap<_, _> = abis
        .iter()
        .map(|abi| {
            (
                vec!["ScriptCall".to_string(), abi.name().to_camel_case()],
                crate::common::prepare_doc_string(abi.doc()),
            )
        })
        .collect();
    comments.insert(
        vec!["ScriptCall".to_string()],
        r#"Structured representation of a call into a known Move script.
```ignore
impl ScriptCall {
    pub fn encode(self) -> Script { .. }
    pub fn decode(&Script) -> Option<ScriptCall> { .. }
}
```
"#
        .into(),
    );
    output_with_external_dependencies_and_comments(
        out,
        /* derive macros */ true,
        &script_registry,
        &external_definitions,
        &comments,
    )
    .map_err(|err| std::io::Error::new(std::io::ErrorKind::Other, format!("{}", err)))?;
    if local_types {
        writeln!(
            out,
            "\n// Type alias used for code generation.\ntype Bytes = Vec<u8>;"
        )?;
    }
    Ok(())
}

fn get_external_definitions(local_types: bool) -> serde_generate::ExternalDefinitions {
    let definitions = if local_types {
        vec![
            ("move_core_types::language_storage", vec!["TypeTag"]),
            (
                "libra_types::transaction",
                vec!["Script", "TransactionArgument"],
            ),
            ("libra_types::account_address", vec!["AccountAddress"]),
        ]
    } else {
        vec![(
            "libra_types",
            vec!["AccountAddress", "TypeTag", "Script", "TransactionArgument"],
        )]
    };
    definitions
        .into_iter()
        .map(|(module, defs)| {
            (
                module.to_string(),
                defs.into_iter().map(String::from).collect(),
            )
        })
        .collect()
}

fn output_encode_method(out: &mut dyn Write, abis: &[ScriptABI]) -> Result<()> {
    writeln!(
        out,
        r#"
/// Build a Libra `Script` from a structured object `ScriptCall`.
pub fn encode(self) -> Script {{
    use ScriptCall::*;
    match self {{"#
    )?;
    for abi in abis {
        output_variant_encoder(out, abi)?;
    }
    writeln!(out, "    }}\n}}\n")
}

fn output_variant_encoder(out: &mut dyn Write, abi: &ScriptABI) -> Result<()> {
    let params = std::iter::empty()
        .chain(abi.ty_args().iter().map(TypeArgumentABI::name))
        .chain(abi.args().iter().map(ArgumentABI::name))
        .collect::<Vec<_>>()
        .join(", ");
    writeln!(
        out,
        "        {0}{{{2}}} => encode_{1}_script({2}),",
        abi.name().to_camel_case(),
        abi.name(),
        params
    )
}

fn output_decode_method(out: &mut dyn Write, local_types: bool) -> Result<()> {
    writeln!(
        out,
        r#"
/// Try to recognize a Libra `Script` and convert it into a structured object `ScriptCall`.
pub fn decode(script: &Script) -> Option<ScriptCall> {{
    match SCRIPT_DECODER_MAP.get({}) {{
        Some(decoder) => decoder(script),
        None => None,
    }}
}}"#,
        if local_types {
            "script.code()"
        } else {
            "&script.code.clone().into_vec()"
        }
    )
}

fn output_comment(
    out: &mut dyn std::io::Write,
    indentation: usize,
    doc: &str,
) -> std::io::Result<()> {
    let prefix = " ".repeat(indentation) + "/// ";
    let empty_line = "\n".to_string() + &" ".repeat(indentation) + "///\n";
    let text = textwrap::indent(doc, &prefix).replace("\n\n", &empty_line);
    write!(out, "\n{}", text)
}

fn output_script_encoder_function(
    out: &mut dyn Write,
    abi: &ScriptABI,
    local_types: bool,
) -> Result<()> {
    output_comment(out, 0, &crate::common::prepare_doc_string(abi.doc()))?;
    write!(
        out,
        r#"pub fn encode_{}_script({}) -> Script {{"#,
        abi.name(),
        [
            quote_type_parameters(abi.ty_args()),
            quote_parameters(abi.args(), local_types),
        ]
        .concat()
        .join(", ")
    )?;
    if local_types {
        writeln!(
            out,
            r#"
    Script::new(
        {}_CODE.to_vec(),
        vec![{}],
        vec![{}],
    )"#,
            abi.name().to_shouty_snake_case(),
            quote_type_arguments(abi.ty_args()),
            quote_arguments(abi.args()),
        )?;
    } else {
        writeln!(
            out,
            r#"
    Script {{
        code: Bytes::from({}_CODE.to_vec()),
        ty_args: vec![{}],
        args: vec![{}],
    }}"#,
            abi.name().to_shouty_snake_case(),
            quote_type_arguments(abi.ty_args()),
            quote_arguments(abi.args()),
        )?;
    }
    writeln!(out, "}}")?;
    Ok(())
}

fn output_script_decoder_function(
    out: &mut dyn Write,
    abi: &ScriptABI,
    local_types: bool,
) -> Result<()> {
    writeln!(
        out,
        "\nfn decode_{}_script({}script: &Script) -> Option<ScriptCall> {{",
        abi.name(),
        // fix warning "unused variable"
        if abi.ty_args().is_empty() && abi.args().is_empty() {
            "_"
        } else {
            ""
        }
    )?;
    writeln!(
        out,
        "    Some(ScriptCall::{} {{",
        abi.name().to_camel_case(),
    )?;
    for (index, ty_arg) in abi.ty_args().iter().enumerate() {
        writeln!(
            out,
            "        {} : script.ty_args{}.get({})?.clone(),",
            ty_arg.name(),
            if local_types { "()" } else { "" },
            index,
        )?;
    }
    for (index, arg) in abi.args().iter().enumerate() {
        writeln!(
            out,
            "        {} : decode_{}_argument(script.args{}.get({})?.clone())?,",
            arg.name(),
            mangle_type(arg.type_tag()),
            if local_types { "()" } else { "" },
            index,
        )?;
    }
    writeln!(out, "    }})")?;
    writeln!(out, "}}")?;
    Ok(())
}

fn output_decoder_map(out: &mut dyn Write, abis: &[ScriptABI]) -> Result<()> {
    writeln!(
        out,
        r#"
type DecoderMap = std::collections::HashMap<Vec<u8>, Box<dyn Fn(&Script) -> Option<ScriptCall> + std::marker::Sync + std::marker::Send>>;

static SCRIPT_DECODER_MAP: once_cell::sync::Lazy<DecoderMap> = once_cell::sync::Lazy::new(|| {{
    let mut map : DecoderMap = std::collections::HashMap::new();"#
    )?;
    for abi in abis {
        writeln!(
            out,
            "    map.insert({}_CODE.to_vec(), Box::new(decode_{}_script));",
            abi.name().to_shouty_snake_case(),
            abi.name()
        )?;
    }
    writeln!(
        out,
        r#"    map
}});
"#
    )
}

fn output_decoding_helpers(out: &mut dyn Write) -> Result<()> {
    writeln!(
        out,
        r#"
#[allow(dead_code)]
fn decode_bool_argument(arg: TransactionArgument) -> Option<bool> {{
    match arg {{
        TransactionArgument::Bool(value) => Some(value),
        _ => None,
    }}
}}

#[allow(dead_code)]
fn decode_u8_argument(arg: TransactionArgument) -> Option<u8> {{
    match arg {{
        TransactionArgument::U8(value) => Some(value),
        _ => None,
    }}
}}

#[allow(dead_code)]
fn decode_u64_argument(arg: TransactionArgument) -> Option<u64> {{
    match arg {{
        TransactionArgument::U64(value) => Some(value),
        _ => None,
    }}
}}

#[allow(dead_code)]
fn decode_u128_argument(arg: TransactionArgument) -> Option<u128> {{
    match arg {{
        TransactionArgument::U128(value) => Some(value),
        _ => None,
    }}
}}

#[allow(dead_code)]
fn decode_address_argument(arg: TransactionArgument) -> Option<AccountAddress> {{
    match arg {{
        TransactionArgument::Address(value) => Some(value),
        _ => None,
    }}
}}

#[allow(dead_code)]
fn decode_u8vector_argument(arg: TransactionArgument) -> Option<Bytes> {{
    match arg {{
        TransactionArgument::U8Vector(value) => Some(value),
        _ => None,
    }}
}}
"#
    )
}

fn output_code_constant(out: &mut dyn Write, abi: &ScriptABI) -> Result<()> {
    writeln!(
        out,
        "\nconst {}_CODE: &[u8] = &[{}];",
        abi.name().to_shouty_snake_case(),
        abi.code()
            .iter()
            .map(|x| format!("{}", x))
            .collect::<Vec<_>>()
            .join(", ")
    )?;
    Ok(())
}

fn quote_type_parameters(ty_args: &[TypeArgumentABI]) -> Vec<String> {
    ty_args
        .iter()
        .map(|ty_arg| format!("{}: TypeTag", ty_arg.name()))
        .collect()
}

fn quote_parameters(args: &[ArgumentABI], local_types: bool) -> Vec<String> {
    args.iter()
        .map(|arg| {
            format!(
                "{}: {}",
                arg.name(),
                quote_type(arg.type_tag(), local_types)
            )
        })
        .collect()
}

fn quote_type_arguments(ty_args: &[TypeArgumentABI]) -> String {
    ty_args
        .iter()
        .map(|ty_arg| ty_arg.name().to_string())
        .collect::<Vec<_>>()
        .join(", ")
}

fn quote_arguments(args: &[ArgumentABI]) -> String {
    args.iter()
        .map(|arg| make_transaction_argument(arg.type_tag(), arg.name()))
        .collect::<Vec<_>>()
        .join(", ")
}

fn quote_type(type_tag: &TypeTag, local_types: bool) -> String {
    use TypeTag::*;
    match type_tag {
        Bool => "bool".into(),
        U8 => "u8".into(),
        U64 => "u64".into(),
        U128 => "u128".into(),
        Address => "AccountAddress".into(),
        Vector(type_tag) => match type_tag.as_ref() {
            U8 => {
                if local_types {
                    "Vec<u8>".into()
                } else {
                    "Bytes".into()
                }
            }
            _ => type_not_allowed(type_tag),
        },

        Struct(_) | Signer => type_not_allowed(type_tag),
    }
}

fn mangle_type(type_tag: &TypeTag) -> String {
    use TypeTag::*;
    match type_tag {
        Bool => "bool".into(),
        U8 => "u8".into(),
        U64 => "u64".into(),
        U128 => "u128".into(),
        Address => "address".into(),
        Vector(type_tag) => match type_tag.as_ref() {
            U8 => "u8vector".into(),
            _ => type_not_allowed(type_tag),
        },

        Struct(_) | Signer => type_not_allowed(type_tag),
    }
}

fn make_transaction_argument(type_tag: &TypeTag, name: &str) -> String {
    use TypeTag::*;
    match type_tag {
        Bool => format!("TransactionArgument::Bool({})", name),
        U8 => format!("TransactionArgument::U8({})", name),
        U64 => format!("TransactionArgument::U64({})", name),
        U128 => format!("TransactionArgument::U128({})", name),
        Address => format!("TransactionArgument::Address({})", name),
        Vector(type_tag) => match type_tag.as_ref() {
            U8 => format!("TransactionArgument::U8Vector({})", name),
            _ => type_not_allowed(type_tag),
        },

        Struct(_) | Signer => type_not_allowed(type_tag),
    }
}

pub struct Installer {
    install_dir: PathBuf,
    libra_types_version: String,
}

impl Installer {
    pub fn new(install_dir: PathBuf, libra_types_version: String) -> Self {
        Installer {
            install_dir,
            libra_types_version,
        }
    }
}

impl crate::SourceInstaller for Installer {
    type Error = Box<dyn std::error::Error>;

    fn install_transaction_builders(
        &self,
        public_name: &str,
        abis: &[ScriptABI],
    ) -> std::result::Result<(), Self::Error> {
        let (name, version) = {
            let parts = public_name.splitn(2, ':').collect::<Vec<_>>();
            if parts.len() >= 2 {
                (parts[0].to_string(), parts[1].to_string())
            } else {
                (parts[0].to_string(), "0.1.0".to_string())
            }
        };
        let dir_path = self.install_dir.join(&name);
        std::fs::create_dir_all(&dir_path)?;
        let mut cargo = std::fs::File::create(&dir_path.join("Cargo.toml"))?;
        write!(
            cargo,
            r#"[package]
name = "{}"
version = "{}"
edition = "2018"

[dependencies]
once_cell = "1.4.0"
serde = {{ version = "1.0", features = ["derive"] }}
serde_bytes = "0.11"
libra-types = {{ path = "../libra-types", version = "{}" }}
"#,
            name, version, self.libra_types_version,
        )?;
        std::fs::create_dir(dir_path.join("src"))?;
        let source_path = dir_path.join("src/lib.rs");
        let mut source = std::fs::File::create(&source_path)?;
        output(&mut source, abis, /* local_types */ false)?;
        Ok(())
    }
}
