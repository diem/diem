// The module for the channel resource
module ChannelAccount {
    import 0x0.LibraAccount;
    import 0x0.LibraCoin;
    import 0x00.Hash;
    import 0x0.Event;
    import 0x0.U64Util;
    import 0x0.AddressUtil;
    import 0x0.BytearrayUtil;

    // Every Channel account has a LibraCoin.T resource
    resource T {
        balance: LibraCoin.T,
        channel_sequence_number: u64,
        closed: bool,
        participant: address,
    }

    // Open channel and deposit default coin
    public open(sender_amount:u64, receiver_amount:u64){
        let sender_coin: LibraCoin.T;
        let receiver_coin: LibraCoin.T;
        let sender:address;
        let receiver:address;
        let sender_account: Self.T;
        let receiver_account: Self.T;

        sender = get_txn_sender();
        receiver = get_txn_receiver();

        sender_coin = LibraAccount.withdraw_from_sender(copy(sender_amount));
        receiver_coin = LibraAccount.withdraw_from_receiver(copy(receiver_amount));

        sender_account = T {balance:move(sender_coin), channel_sequence_number:0, closed: false, participant: copy(receiver)};
        receiver_account = T {balance:move(receiver_coin), channel_sequence_number:0, closed: false, participant: copy(sender)};

        move_to_sender_channel<T>(move(sender_account));
        move_to_receiver_channel<T>(move(receiver_account));
        return;
    }

    // Withdraw LibraCoin from LibraAccount and deposit to ChannelAccount
    public deposit(sender_amount:u64, receiver_amount:u64) {
        let sender:address;
        let receiver:address;
        let sender_coin: LibraCoin.T;
        let receiver_coin: LibraCoin.T;

        sender = get_txn_sender();
        receiver = get_txn_receiver();

        sender_coin = LibraAccount.withdraw_from_sender(copy(sender_amount));
        receiver_coin = LibraAccount.withdraw_from_receiver(copy(receiver_amount));
        Self.deposit_to_sender(move(sender_coin));
        Self.deposit_to_receiver(move(receiver_coin));
        return;
    }

    // Deposits the `to_deposit` coin into the sender or receiver channel account
    do_deposit(is_sender:bool, to_deposit: LibraCoin.T) {
        let deposit_value: u64;
        let to_account_ref: &mut Self.T;

        // Check that the `to_deposit` coin is non-zero
        deposit_value = LibraCoin.value(&to_deposit);
        assert(copy(deposit_value) > 0, 7);

        if(copy(is_sender)){
            to_account_ref = borrow_sender_channel<T>();
        }else{
            to_account_ref = borrow_receiver_channel<T>();
        }
        // Deposit the `to_deposit` coin
        LibraCoin.deposit(&mut copy(to_account_ref).balance, move(to_deposit));
        return;
    }

    public deposit_to_sender(to_deposit: LibraCoin.T) {
        Self.do_deposit(true, move(to_deposit));
        return;
    }

    public deposit_to_receiver(to_deposit: LibraCoin.T) {
        Self.do_deposit(false, move(to_deposit));
        return;
    }

    // Withdraw LibraCoin from ChannelAccount and deposit to LibraAccount
    public withdraw(sender_amount:u64, receiver_amount:u64) {
       let sender:address;
       let receiver:address;
       let sender_coin: LibraCoin.T;
       let receiver_coin: LibraCoin.T;

       sender = get_txn_sender();
       receiver = get_txn_receiver();

       sender_coin = Self.withdraw_from_sender(copy(sender_amount));
       receiver_coin = Self.withdraw_from_receiver(copy(receiver_amount));
       LibraAccount.deposit(copy(sender), move(sender_coin));
       LibraAccount.deposit(copy(receiver), move(receiver_coin));
       return;
    }

    do_withdraw(is_sender:bool, amount:u64): LibraCoin.T {
        let from_account_ref: &mut Self.T;
        let withdraw_coin: LibraCoin.T;

        if(copy(is_sender)){
            from_account_ref = borrow_sender_channel<T>();
        }else{
            from_account_ref = borrow_receiver_channel<T>();
        }
        // Deposit the `to_deposit` coin
        withdraw_coin = LibraCoin.withdraw(&mut copy(from_account_ref).balance, copy(amount));
        return move(withdraw_coin);
    }

    public withdraw_from_sender(amount:u64): LibraCoin.T {
        return Self.do_withdraw(true, copy(amount));
    }

    public withdraw_from_receiver(amount:u64): LibraCoin.T {
        return Self.do_withdraw(false, copy(amount));
    }

    // Transfer amount LibraCoin from sender to receiver
    public transfer(amount:u64){
        let transfer_coin: LibraCoin.T;

        transfer_coin = Self.withdraw_from_sender(move(amount));
        Self.deposit_to_receiver(move(transfer_coin));
        return;
    }

    balance(is_sender:bool): u64{
       let account_ref: &Self.T;

       if(copy(is_sender)){
           account_ref = freeze(borrow_sender_channel<T>());
       }else{
           account_ref = freeze(borrow_receiver_channel<T>());
       }
       return LibraCoin.value(&move(account_ref).balance);
    }

    public sender_balance(): u64 {
        return Self.balance(true);
    }

    public receiver_balance(): u64 {
        return Self.balance(false);
    }

    channel_sequence_number(is_sender:bool): u64{
      let account_ref: &Self.T;

      if(copy(is_sender)){
          account_ref = freeze(borrow_sender_channel<T>());
      }else{
          account_ref = freeze(borrow_receiver_channel<T>());
      }
      return *&move(account_ref).channel_sequence_number;
    }

    public sender_sequence_number(): u64 {
        return Self.channel_sequence_number(true);
    }

    public receiver_sequence_number(): u64 {
        return Self.channel_sequence_number(false);
    }

    closed(is_sender:bool) : bool{
        let account_ref: &Self.T;

        if(copy(is_sender)){
            account_ref = freeze(borrow_sender_channel<T>());
        }else{
            account_ref = freeze(borrow_receiver_channel<T>());
        }
        return *&move(account_ref).closed;
    }

    public sender_closed(): bool {
        return Self.closed(true);
    }

    public receiver_closed(): bool {
        return Self.closed(false);
    }

    do_close(is_sender:bool) {
        let account_ref: &mut Self.T;

        if(copy(is_sender)){
            account_ref = borrow_sender_channel<T>();
        }else{
            account_ref = borrow_receiver_channel<T>();
        }
        *(&mut move(account_ref).closed) = true;
        return;
    }

    public close(){
        Self.do_close(true);
        Self.do_close(false);
        return;
    }

    // The prologue is invoked at the beginning of every channel transaction
    prologue() {
        let sender_sequence_number_value: u64;
        let receiver_sequence_number_value: u64;
        let transaction_channel_sequence_number_value: u64;

        transaction_channel_sequence_number_value = get_txn_channel_sequence_number();

        // sequence_number 0 should be open channel txn.
        if(copy(transaction_channel_sequence_number_value) == 0){
            assert(!exist_sender_channel<T>(), 400);
            assert(!exist_receiver_channel<T>(), 401);
        }else{
            assert(exist_sender_channel<T>(), 400);
            assert(exist_receiver_channel<T>(), 401);
            sender_sequence_number_value = Self.sender_sequence_number();
            receiver_sequence_number_value = Self.receiver_sequence_number();
            assert(copy(sender_sequence_number_value) == copy(receiver_sequence_number_value), 402);
            if(is_offchain()){
                assert(copy(transaction_channel_sequence_number_value) == copy(sender_sequence_number_value), 403);
            }else{
                assert(copy(transaction_channel_sequence_number_value) >= copy(sender_sequence_number_value), 404);
            }
        }
        return;
    }

    update_sequence_number(is_sender:bool, sequence_number: u64){
       let account_ref: &mut Self.T;

       if(copy(is_sender)){
           account_ref = borrow_sender_channel<T>();
       }else{
           account_ref = borrow_receiver_channel<T>();
       }
       *(&mut move(account_ref).channel_sequence_number) = move(sequence_number);
       return;
    }

    epilogue(){
       let transaction_channel_sequence_number_value: u64;
       let new_sequence_number: u64;

       transaction_channel_sequence_number_value = get_txn_channel_sequence_number();
       new_sequence_number = move(transaction_channel_sequence_number_value) + 1;

       Self.update_sequence_number(true, copy(new_sequence_number));
       Self.update_sequence_number(false, move(new_sequence_number));
       return;
    }
}