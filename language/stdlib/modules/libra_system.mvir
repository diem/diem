module LibraSystem {
    import 0x0.LibraAccount;
    import 0x0.ValidatorConfig;
    import 0x0.Vector;
    import 0x0.ConsensusConfig;
    import 0x0.LibraCoin;

    struct ValidatorInfo {
        addr: address,
        consensus_pubkey: bytearray,
        consensus_voting_power: u64,
        network_signing_pubkey: bytearray,
        network_identity_pubkey: bytearray,
    }

    struct ValidatorSetChangeEvent {
        new_validator_set: Vector.T<Self.ValidatorInfo>,
    }

    resource ValidatorSet {
        validators: Vector.T<Self.ValidatorInfo>,
        change_events: LibraAccount.EventHandle<Self.ValidatorSetChangeEvent>,
    }

    resource BlockMetadata {
      // Height of the current block
      // TODO: Should we keep the height?
      height: u64,

      // Unix Timestamp for the current block.
      // TODO: Use a better wrapper for timestamp.
      timestamp: u64,

      // Hash of the current block of transactions.
      id: bytearray,

      // Proposer of the current block.
      proposer: address,
    }

    resource SubsidyInfo {
        withdrawal_capability: LibraAccount.WithdrawalCapability,
        subsidy_height: u64,
        heights: Vector.T<u64>,
        miners: Vector.T<address>,
    }

    public initialize_subsidy_info() {
        assert(get_txn_sender() == 0x6d696e74, 1);

        move_to_sender<SubsidyInfo>(SubsidyInfo {
            withdrawal_capability: LibraAccount.extract_sender_withdrawal_capability(),
            subsidy_height: 0,
            heights: Vector.empty<u64>(),
            miners: Vector.empty<address>(),
        });
        return;
    }

    // This can only be invoked by the Association address, and only a single time.
    // Currently, it is invoked in the genesis transaction
    public initialize_validator_set() {
      // Only callable by the Association address
      assert(get_txn_sender() == 0x1D8, 1);

      move_to_sender<ValidatorSet>(ValidatorSet {
          validators: Vector.empty<Self.ValidatorInfo>(),
          change_events: LibraAccount.new_event_handle<Self.ValidatorSetChangeEvent>(),
      });
      return;
    }

    // This can only be invoked by the Association address, and only a single time.
    // Currently, it is invoked in the genesis transaction
    public initialize_block_metadata() {
      // Only callable by the Association address
      assert(get_txn_sender() == 0xA550C18, 1);

      // TODO: How should we get the default block metadata? Should it be set in the first block prologue transaction or
      //       in the genesis?
      move_to_sender<BlockMetadata>(BlockMetadata {
        height: 0,
        timestamp: 0,
        id: h"",
        proposer: 0xA550C18,
      });
      return;
    }

    subsidy() acquires BlockMetadata, SubsidyInfo {
        let subsidy_info: &mut Self.SubsidyInfo;
        let tmp_height: u64;
        let heights_ref: &mut Vector.T<u64>;
        let miners_ref: &mut Vector.T<address>;
        let start_height: u64;
        let subsidy_coin: u64;
        let subsidy_miner: address;
        let subsidy_flag: bool;
        let libra_coin: LibraCoin.T;
        let current_height: u64;
        let current_miner: address;

        current_height = Self.get_current_block_height();

        if (copy(current_height) > 0 && ConsensusConfig.is_pow()) {
            subsidy_info = borrow_global_mut<SubsidyInfo>(0x6d696e74);
            assert(!Vector.contains<u64>(&copy(subsidy_info).heights, &current_height), 6001);
            assert((Vector.length<u64>(&copy(subsidy_info).heights) <= ConsensusConfig.subsidy_delay()), 6002);

            subsidy_flag = false;

            start_height = *&copy(subsidy_info).subsidy_height + 1;
            subsidy_coin = ConsensusConfig.subsidy_coin(copy(start_height));

            if (Vector.length<u64>(&copy(subsidy_info).heights) == ConsensusConfig.subsidy_delay()) {//pay
                tmp_height = copy(start_height) + ConsensusConfig.subsidy_delay();
                assert(copy(current_height) == copy(tmp_height), 6003);

                tmp_height = Vector.get<u64>(&copy(subsidy_info).heights, 0);
                assert(copy(start_height) == copy(tmp_height), 6004);

                subsidy_flag = true;
            }

            heights_ref = &mut move(subsidy_info).heights;
            if (copy(subsidy_flag)) {
                //remove:height
                Vector.remove_head<u64>(copy(heights_ref));
            }
            Vector.push_back<u64>(move(heights_ref), move(current_height));

            subsidy_info = borrow_global_mut<SubsidyInfo>(0x6d696e74);
            if (copy(subsidy_flag)) {
                assert(copy(subsidy_coin) > 0, 6005);
                subsidy_miner = Vector.get<address>(&copy(subsidy_info).miners, 0);
                if (!LibraAccount.exists(copy(subsidy_miner))) {
                    LibraAccount.create_account(copy(subsidy_miner));
                }
                libra_coin = LibraAccount.withdraw_with_capability(&copy(subsidy_info).withdrawal_capability, move(subsidy_coin));
                LibraAccount.deposit(move(subsidy_miner), move(libra_coin));
                *(&mut copy(subsidy_info).subsidy_height) = move(start_height);

                //remove:miner
                miners_ref = &mut move(subsidy_info).miners;
                Vector.remove_head<address>(copy(miners_ref));
            } else {
                miners_ref = &mut move(subsidy_info).miners;
            }

            current_miner = Self.get_current_proposer();
            Vector.push_back<address>(move(miners_ref), move(current_miner));
            return;
        }

        return;
    }

    public get_consensus_pubkey(v: &Self.ValidatorInfo): &bytearray {
      return &move(v).consensus_pubkey;
    }

    public get_consensus_voting_power(v: &Self.ValidatorInfo): &u64 {
      return &move(v).consensus_voting_power;
    }

    public get_network_signing_pubkey(v: &Self.ValidatorInfo): &bytearray {
      return &move(v).network_signing_pubkey;
    }

    public get_network_identity_pubkey(v: &Self.ValidatorInfo): &bytearray {
      return &move(v).network_identity_pubkey;
    }

    // Set the metadata for the current block.
    // The runtime always runs this before executing the transactions in a block.
    // TODO: 1. Make this private, support other metadata
    //       2. Should the previous block votes be provided from BlockMetadata or should it come from the ValidatorSet
    //          Resource?
    public block_prologue(
        timestamp: u64,
        new_block_hash: bytearray,
        previous_block_votes: bytearray,
        proposer: address
    ) acquires BlockMetadata, ValidatorSet, SubsidyInfo {
      Self.process_block_prologue(move(timestamp), move(new_block_hash), move(previous_block_votes), move(proposer));
      // triggers a reconfiguration if the validator keys or validator set has changed
      Self.reconfigure();
      Self.subsidy();
      return;
    }

    // Update the BlockMetadata resource with the new blockmetada coming from the consensus.
    process_block_prologue(
        timestamp: u64,
        new_block_hash: bytearray,
        previous_block_votes: bytearray,
        proposer: address
    ) acquires BlockMetadata, ValidatorSet {
        let block_metadata_ref: &mut Self.BlockMetadata;

        block_metadata_ref = borrow_global_mut<BlockMetadata>(0xA550C18);

        // TODO: Figure out a story for errors in the system transactions.
        if (!ConsensusConfig.is_pow()) {
            assert(copy(timestamp) > *(&copy(block_metadata_ref).timestamp), 5001);
            assert(Self.is_validator(copy(proposer)), 5002);
        }

        *(&mut copy(block_metadata_ref).id) = move(new_block_hash);
        *(&mut copy(block_metadata_ref).timestamp) = move(timestamp);
        *(&mut copy(block_metadata_ref).proposer) = move(proposer);
        *(&mut move(block_metadata_ref).height) = *(&copy(block_metadata_ref).height) + 1;
        return;
    }

    // Get the current block height
    public get_current_block_height(): u64 acquires BlockMetadata {
      return *&(borrow_global<BlockMetadata>(0xA550C18)).height;
    }

    // Get the current block id
    public get_current_block_id(): bytearray acquires BlockMetadata {
      return *&(borrow_global<BlockMetadata>(0xA550C18)).id;
    }

    // Get the current time
    public get_current_timestamp(): u64 acquires BlockMetadata {
      return *&(borrow_global<BlockMetadata>(0xA550C18)).timestamp;
    }

    // Gets the address of the proposer of the current block
    public get_current_proposer(): address acquires BlockMetadata {
      return *&(borrow_global<BlockMetadata>(0xA550C18)).proposer;
    }

    // Return the size of the current validator set
    public validator_set_size(): u64 acquires ValidatorSet {
        let validator_set_ref: &Self.ValidatorSet;

        validator_set_ref = borrow_global<ValidatorSet>(0x1D8);
        return Vector.length<Self.ValidatorInfo>(&move(validator_set_ref).validators);
    }

    // Return true if addr is a current validator
    public is_validator(addr: address): bool acquires ValidatorSet {
        let size: u64;
        let i: u64;
        let vector_ref: &Vector.T<Self.ValidatorInfo>;
        let info_ref: &Self.ValidatorInfo;

        vector_ref = &borrow_global<ValidatorSet>(0x1D8).validators;
        size = Vector.length<Self.ValidatorInfo>(copy(vector_ref));
        if (copy(size) == 0) {
            return false;
        }

        i = 0;
        // this is only needed to make the bytecode verifier happy
        info_ref = Vector.borrow<Self.ValidatorInfo>(copy(vector_ref), copy(i));
        loop {
            if (*&copy(info_ref).addr == copy(addr)) {
                return true;
            }
            i = copy(i) + 1;
            if (copy(i) >= copy(size)) {
                break;
            }
            info_ref = Vector.borrow<Self.ValidatorInfo>(copy(vector_ref), copy(i));
        }

        return false;
    }

    // TODO: Decide on access control policy. For now, we ensure that this is only callable from the
    // genesis txn. Obviously, we'll need a different policy once we support reconfiguration.
    add_validator(account_address: address) acquires ValidatorSet {
        let validator_set_ref: &mut Self.ValidatorSet;

        // A prospective validator must have a validator config resource
        assert(ValidatorConfig.has(copy(account_address)), 17);

        validator_set_ref = borrow_global_mut<ValidatorSet>(0x1D8);
        Vector.push_back<Self.ValidatorInfo>(
            &mut move(validator_set_ref).validators,
            ValidatorInfo {
                addr: move(account_address),
                consensus_pubkey: h"",
                // TODO: check for LIT, compute voting power based on LIT + stake
                consensus_voting_power: 1,
                network_signing_pubkey: h"",
                network_identity_pubkey: h"",
            }
        );

        return;
    }

    // Return true if the ValidatorInfo given as input is different than the ValidatorConfig
    // published at validator_info.addr + copies the differing fields. Aborts if there is no
    // ValidatorConfig at validator_info.addr
    public copy_validator_info(validator_info: &mut Self.ValidatorInfo): bool {
        let consensus_pubkey: bytearray;
        let network_signing_pubkey: bytearray;
        let network_identity_pubkey: bytearray;
        let config: ValidatorConfig.Config;
        let changed: bool;

        config = ValidatorConfig.config(*&copy(validator_info).addr);
        consensus_pubkey = ValidatorConfig.consensus_pubkey(&config);
        network_signing_pubkey = ValidatorConfig.network_signing_pubkey(&config);
        network_identity_pubkey = ValidatorConfig.network_identity_pubkey(&config);

        changed = false;
        if (&consensus_pubkey != &copy(validator_info).consensus_pubkey) {
            *&mut copy(validator_info).consensus_pubkey = move(consensus_pubkey);
            changed = true;
        }
       if (&network_signing_pubkey != &copy(validator_info).network_signing_pubkey) {
            *&mut copy(validator_info).network_signing_pubkey = move(network_signing_pubkey);
            changed = true;
        }
        if (&network_identity_pubkey != &copy(validator_info).network_identity_pubkey) {
            *&mut copy(validator_info).network_identity_pubkey = move(network_identity_pubkey);
            changed = true;
        }

        return move(changed);
    }

    // Trigger a reconfiguation the Libra system by:
    // (1) Computing a new validator set and storing it on chain
    // (2) Emitting an event containing new validator set, which will be passed to the executor
    // TODO: make  this private + only callable from block prologue
    reconfigure() acquires ValidatorSet {
        let validator_set_ref: &mut Self.ValidatorSet;
        let vector_ref: &mut Vector.T<Self.ValidatorInfo>;
        let info_ref: &mut Self.ValidatorInfo;
        let i: u64;
        let len: u64;
        let changed: bool;

        // For now, this only supports a simple form of reconfiguration: allowing a fixed set of
        // validators to rotate their keys.
        // TODO: support adding and removing validators. Eventually, we will do this by computing
        // the new validator set from a larger list of candidate validators sorted by stake.
        validator_set_ref = borrow_global_mut<ValidatorSet>(0x1D8);
        vector_ref = &mut copy(validator_set_ref).validators;

        i = 0;
        len = Vector.length<Self.ValidatorInfo>(freeze(copy(vector_ref)));
        // assume(len > 0), since an empty validator set is nonsensical
        changed = false;
        info_ref = Vector.borrow_mut<Self.ValidatorInfo>(copy(vector_ref), copy(i));
        // check if each validator has rotated their keys, copy their new info and note the change
        // if so.
        loop {
            if (Self.copy_validator_info(move(info_ref))) {
                changed = true;
            }

            i = move(i) + 1;
            if (copy(i) >= copy(len)) {
                break;
            }
            info_ref = Vector.borrow_mut<Self.ValidatorInfo>(copy(vector_ref), copy(i));
        }

        if (move(changed)) {
            LibraAccount.emit_event<Self.ValidatorSetChangeEvent>(
                &mut move(validator_set_ref).change_events,
                ValidatorSetChangeEvent {
                    new_validator_set: *move(vector_ref),
                },
            );
            return;
        } else {
            return;
        }
    }

    // Get the ValidatorInfo for the ith validator
    public get_ith_validator_info(i: u64): Self.ValidatorInfo acquires ValidatorSet {
      let vector_ref: &Vector.T<Self.ValidatorInfo>;

      vector_ref = &borrow_global<ValidatorSet>(0x1D8).validators;
      assert(copy(i) < Vector.length<Self.ValidatorInfo>(copy(vector_ref)), 3);
      return *Vector.borrow<Self.ValidatorInfo>(copy(vector_ref), move(i));
    }

    // Get the address of the i'th validator.
    public get_ith_validator_address(i: u64): address acquires ValidatorSet {
      let len: u64;
      let validator_set: &Self.ValidatorSet;
      let addr: address;
      let peer: &Self.ValidatorInfo;

      validator_set = borrow_global<ValidatorSet>(0x1D8);
      len = Vector.length<Self.ValidatorInfo>(&copy(validator_set).validators);
      assert(copy(i) < move(len), 3);
      peer = Vector.borrow<Self.ValidatorInfo>(&move(validator_set).validators, move(i));
      addr = *(&move(peer).addr);

      return move(addr);
    }
}
