// The module for the account resource that governs every Libra account
module LibraAccount {
    import 0x0.LibraCoin;
    import 0x0.Hash;
    import 0x0.U64Util;
    import 0x0.AddressUtil;
    import 0x0.BytearrayUtil;
    import 0x0.Vector;
    import 0x0.ChannelTransaction;
    import 0x0.ChannelUtil;

    // Every Libra account has a LibraAccount.T resource
    resource T {
        // The current authentication key.
        // This can be different than the key used to create the account
        authentication_key: bytearray,
        // The coins stored in this account
        balance: LibraCoin.T,
        // If true, the authority to rotate the authentication key of this account resides elsewhere
        delegated_key_rotation_capability: bool,
        // If true, the authority to withdraw funds from this account resides elsewhere
        delegated_withdrawal_capability: bool,
        // Event handle for received event
        received_events: Self.EventHandle<Self.ReceivedPaymentEvent>,
        // Event handle for sent event
        sent_events: Self.EventHandle<Self.SentPaymentEvent>,
        // The current sequence number.
        // Incremented by one each time a transaction is submitted
        sequence_number: u64,
        // Generator for event handles
        event_generator: Self.EventHandleGenerator,
    }

    // The holder of WithdrawalCapability for account_address can withdraw Libra from
    // account_address/LibraAccount.T/balance.
    // There is at most one WithdrawalCapability in existence for a given address.
    resource WithdrawalCapability {
        account_address: address,
    }

    // The holder of KeyRotationCapability for account_address can rotate the authentication key for
    // account_address (i.e., write to account_address/LibraAccount.T/authentication_key).
    // There is at most one KeyRotationCapability in existence for a given address.
    resource KeyRotationCapability {
        account_address: address,
    }

    // Message for sent events
    struct SentPaymentEvent {
        // The amount of LibraCoin.T sent
        amount: u64,
        // The address that was paid
        payee: address,
        // Metadata associated with the payment
        metadata: bytearray,
    }

    // Message for received events
    struct ReceivedPaymentEvent {
        // The amount of LibraCoin.T received
        amount: u64,
        // The address that sent the coin
        payer: address,
        // Metadata associated with the payment
        metadata: bytearray,
    }

    /// Events
    // A resource representing the counter used to generate uniqueness under each account. There won't be destructor for
    // this resource to guarantee the uniqueness of the generated handle.
    resource EventHandleGenerator {
        // A monotonically increasing counter
        counter: u64,
    }

    // A handle for a event such that:
    // 1. Other modules can emit event to this handle.
    // 2. Storage can use this handle to prove the total number of events that happened in the past.
    resource EventHandle<T: unrestricted> {
        // Total number of events emitted to this event stream.
        counter: u64
        // A globally unique ID for this event stream.
        guid: bytearray,
    }

    // Channel Resource on chain
    resource Channel {
        channel_sequence_number: u64,
        // 0 open 1 locked 2 closed 3 resolved
        stage: u64,
        participants: Vector.T<address>,
        events: Self.EventHandle<Self.ChannelEvent>,
    }

    // Channel Resource mirror, keep in channel's shared resource, update at offchain.
    resource ChannelMirror {
        channel_sequence_number: u64,
    }

    // Channel participant account in channel
    resource ChannelParticipantAccount {
        balance: LibraCoin.T,
    }

    resource ChannelLockedBy {
        participant: address,
        time_lock: u64,
    }

    resource ChannelChallengedBy {
        participant: address,
    }

    // A resource to keep user's channels, etc
    resource UserChannels {
        channels: Vector.T<address>,
    }

    // track global channel event
    resource ChannelGlobalEvents {
        events: Self.EventHandle<Self.ChannelEvent>,
    }

    struct ChannelEvent {
        channel_address: address,
        stage: u64,
        balances: Vector.T<u64>,
    }

    // Creates a new LibraAccount.T
    // Invoked by the `create_account` builtin
    make(fresh_address: address): Self.T {
        let zero_balance: LibraCoin.T;
        let generator: Self.EventHandleGenerator;
        let sent_handle: Self.EventHandle<Self.SentPaymentEvent>;
        let received_handle: Self.EventHandle<Self.ReceivedPaymentEvent>;
        let auth_key: bytearray;

        auth_key = AddressUtil.address_to_bytes(copy(fresh_address));
        generator = EventHandleGenerator {counter: 0};
        sent_handle = Self.new_event_handle_impl<Self.SentPaymentEvent>(&mut generator, copy(fresh_address));
        received_handle = Self.new_event_handle_impl<Self.ReceivedPaymentEvent>(&mut generator, move(fresh_address));
        zero_balance = LibraCoin.zero();

        return T {
            authentication_key: move(auth_key),
            balance: move(zero_balance),
            delegated_key_rotation_capability: false,
            delegated_withdrawal_capability: false,
            received_events: move(received_handle),
            sent_events: move(sent_handle),
            sequence_number: 0,
            event_generator: move(generator),
        };
    }

    // Deposits the `to_deposit` coin into the `payee`'s account
    public deposit(payee: address, to_deposit: LibraCoin.T) acquires T {
        Self.deposit_with_metadata(move(payee), move(to_deposit), h"");
        return;
    }

    // Deposits the `to_deposit` coin into the `payee`'s account with the attached `metadata`
    public deposit_with_metadata(
        payee: address,
        to_deposit: LibraCoin.T,
        metadata: bytearray
    ) acquires T {
        let deposit_value: u64;
        let payee_account_ref: &mut Self.T;
        let sender: address;
        let sender_account_ref: &mut Self.T;

        // Check that the `to_deposit` coin is non-zero
        deposit_value = LibraCoin.value(&to_deposit);
        assert(copy(deposit_value) > 0, 7);

        // Load the sender's account
        sender = get_txn_sender();
        sender_account_ref = borrow_global_mut<T>(copy(sender));
        // Log a sent event
        Self.emit_event<Self.SentPaymentEvent>(
            &mut move(sender_account_ref).sent_events,
            SentPaymentEvent {
                amount: copy(deposit_value),
                payee: copy(payee),
                metadata: copy(metadata)
            },
        );

        // Load the payee's account
        payee_account_ref = borrow_global_mut<T>(move(payee));
        // Deposit the `to_deposit` coin
        LibraCoin.deposit(&mut copy(payee_account_ref).balance, move(to_deposit));
        // Log a received event
        Self.emit_event<Self.ReceivedPaymentEvent>(
            &mut move(payee_account_ref).received_events,
            ReceivedPaymentEvent {
                amount: move(deposit_value),
                payer: move(sender),
                metadata: move(metadata)
            }
        );
        return;
    }

    // mint_to_address can only be called by accounts with MintCapability (see LibraCoin)
    // and those account will be charged for gas. If those account don't have enough gas to pay
    // for the transaction cost they will fail minting.
    // However those account can also mint to themselves so that is a decent workaround
    public mint_to_address(payee: address, amount: u64) acquires T {
        // Create an account if it does not exist
        if (!exists<T>(copy(payee))) {
            Self.create_account(copy(payee));
        }

        // Mint and deposit the coin
        Self.deposit(move(payee), LibraCoin.mint_with_default_capability(move(amount)));
        return;
    }

    // Helper to withdraw `amount` from the given `account` and return the resulting LibraCoin.T
    withdraw_from_account(account: &mut Self.T, amount: u64): LibraCoin.T {
        let to_withdraw: LibraCoin.T;

        to_withdraw = LibraCoin.withdraw(&mut move(account).balance, copy(amount));
        return move(to_withdraw);
    }

    // Withdraw `amount` LibraCoin.T from the transaction sender's account
    public withdraw_from_sender(amount: u64): LibraCoin.T acquires T {
        let sender_account: &mut Self.T;

        sender_account = borrow_global_mut<T>(get_txn_sender());
        if (*&copy(sender_account).delegated_withdrawal_capability) {
            // The sender has delegated the privilege to withdraw from her account elsewhere--abort.
            abort(11);
        } else {
            // The sender has retained her withdrawal privileges--proceed.
            return Self.withdraw_from_account(move(sender_account), move(amount));
        }
    }

    // Withdraw `amount` LibraCoin.T from account under cap.account_address
    public withdraw_with_capability(
        cap: &Self.WithdrawalCapability, amount: u64
    ): LibraCoin.T acquires T  {
        let account: &mut Self.T;

        account = borrow_global_mut<T>(*&move(cap).account_address);
        return Self.withdraw_from_account(move(account), move(amount));
    }

    // Return a unique capability granting permission to withdraw from the sender's account balance.
    public extract_sender_withdrawal_capability(): Self.WithdrawalCapability acquires T {
        let sender: address;
        let sender_account: &mut Self.T;
        let delegated_ref: &mut bool;

        sender = get_txn_sender();
        sender_account = borrow_global_mut<T>(copy(sender));
        delegated_ref = &mut move(sender_account).delegated_withdrawal_capability;
        if (*copy(delegated_ref)) {
            // We already extracted the unique withdrawal capability for this account.
            abort(11);
        } else {
            *move(delegated_ref) = true; // ensure uniqueness of the capability
            return WithdrawalCapability { account_address: move(sender) };
        }
    }

    // Return the withdrawal capability to the account it originally came from
    public restore_withdrawal_capability(cap: Self.WithdrawalCapability) acquires T {
        let account_address: address;
        let account: &mut Self.T;

        // Destroy the capability
        WithdrawalCapability { account_address } = move(cap);
        account = borrow_global_mut<T>(move(account_address));
        // Update the flag for `account_address` to indicate that the capability has been restored.
        // The account owner will now be able to call pay_from_sender, withdraw_from_sender, and
        // extract_sender_withdrawal_capability again.
        *(&mut move(account).delegated_withdrawal_capability) = false;

        return;
    }

    // Withdraw `amount` LibraCoin.T from the transaction sender's account and send the coin
    // to the `payee` address with the attached `metadata`
    // Creates the `payee` account if it does not exist
    public pay_from_sender_with_metadata(
        payee: address,
        amount: u64,
        metadata: bytearray
    ) acquires T {
        if (!exists<T>(copy(payee))) {
            Self.create_account(copy(payee));
        }
        Self.deposit_with_metadata(
            move(payee),
            Self.withdraw_from_sender(move(amount)),
            move(metadata)
        );
        return;
    }

    // Withdraw `amount` LibraCoin.T from the transaction sender's account and send the coin
    // to the `payee` address
    // Creates the `payee` account if it does not exist
    public pay_from_sender(payee: address, amount: u64) acquires T {
        Self.pay_from_sender_with_metadata(move(payee), move(amount), h"");
        return;
    }

    rotate_authentication_key_for_account(account: &mut Self.T, new_authentication_key: bytearray) {
        *(&mut move(account).authentication_key) = move(new_authentication_key);
        return;
    }

    // Rotate the transaction sender's authentication key
    // The new key will be used for signing future transactions
    public rotate_authentication_key(new_authentication_key: bytearray) acquires T {
        let sender_account: &mut Self.T;

        sender_account = borrow_global_mut<T>(get_txn_sender());
        if (*&copy(sender_account).delegated_key_rotation_capability) {
            // The sender has delegated the privilege to rotate her key elsewhere--abort
            abort(11);
        } else {
            // The sender has retained her key rotation privileges--proceed.
            Self.rotate_authentication_key_for_account(
                move(sender_account),
                move(new_authentication_key)
            );
            return;
        }
    }

    // Rotate the authentication key for the account under cap.account_address
    public rotate_authentication_key_with_capability(
        cap: &Self.KeyRotationCapability,
        new_authentication_key: bytearray,
    ) acquires T  {
        Self.rotate_authentication_key_for_account(
            borrow_global_mut<T>(*&move(cap).account_address),
            move(new_authentication_key)
        );
        return;
    }

    // Return a unique capability granting permission to rotate the sender's authentication key
    public extract_sender_key_rotation_capability(): Self.KeyRotationCapability acquires T {
        let sender: address;
        let delegated_ref: &mut bool;

        sender = get_txn_sender();
        delegated_ref = &mut borrow_global_mut<T>(copy(sender)).delegated_key_rotation_capability;
        if (*copy(delegated_ref)) {
            // We already extracted the unique key rotation capability for this account.
            abort(11);
        } else {
            *move(delegated_ref) = true; // ensure uniqueness of the capability
            return KeyRotationCapability { account_address: move(sender) };
        }
    }

    // Return the key rotation capability to the account it originally came from
    public restore_key_rotation_capability(cap: Self.KeyRotationCapability) acquires T {
        let account_address: address;
        let account: &mut Self.T;

        // Destroy the capability
        KeyRotationCapability { account_address } = move(cap);
        account = borrow_global_mut<T>(move(account_address));
        // Update the flag for `account_address` to indicate that the capability has been restored.
        // The account owner will now be able to call rotate_authentication_key and
        // extract_sender_key_rotation_capability again
        *(&mut move(account).delegated_key_rotation_capability) = false;

        return;
    }

    // Creates a new account at `fresh_address` with an initial balance of zero
    public create_account(fresh_address: address) {
        let generator: Self.EventHandleGenerator;

        generator = EventHandleGenerator {counter: 0};
        Self.save_account(
            copy(fresh_address),
            T {
                authentication_key: AddressUtil.address_to_bytes(copy(fresh_address)),
                balance: LibraCoin.zero(),
                delegated_key_rotation_capability: false,
                delegated_withdrawal_capability: false,
                received_events: Self.new_event_handle_impl<Self.ReceivedPaymentEvent>(&mut generator, copy(fresh_address)),
                sent_events: Self.new_event_handle_impl<Self.SentPaymentEvent>(&mut generator, move(fresh_address)),
                sequence_number: 0,
                event_generator: move(generator),
            }
        );
        return;
    }

    // Creates a new account at `fresh_address` with the `initial_balance` deducted from the
    // transaction sender's account
    public create_new_account(fresh_address: address, initial_balance: u64) acquires T {
        Self.create_account(copy(fresh_address));
        if (copy(initial_balance) > 0) {
            Self.pay_from_sender(move(fresh_address), move(initial_balance));
        }
        return;
    }

    // Save an account to a given address if the address does not have an account resource yet
    native save_account(addr: address, account: Self.T);

    // Helper to return u64 value of the `balance` field for given `account`
    balance_for_account(account: &Self.T): u64 {
        let balance_value: u64;
        balance_value = LibraCoin.value(&move(account).balance);
        return move(balance_value);
    }

    // Return the current balance of the LibraCoin.T in LibraAccount.T at `addr`
    public balance(addr: address): u64 acquires T {
        return Self.balance_for_account(borrow_global<T>(move(addr)));
    }

    // Helper to return the sequence number field for given `account`
    sequence_number_for_account(account: &Self.T): u64 {
        return *(&move(account).sequence_number);
    }

    // Return the current sequence number at `addr`
    public sequence_number(addr: address): u64 acquires T {
        return Self.sequence_number_for_account(borrow_global<T>(move(addr)));
    }

   // Return true if the account at `addr` has delegated its key rotation capability
    public delegated_key_rotation_capability(addr: address): bool acquires T {
        return *&(borrow_global<T>(move(addr))).delegated_key_rotation_capability;
    }

    // Return true if the account at `addr` has delegated its withdrawal capability
    public delegated_withdrawal_capability(addr: address): bool acquires T {
        return *&(borrow_global<T>(move(addr))).delegated_withdrawal_capability;
    }


    // Return a reference to the address associated with the given withdrawal capability
    public withdrawal_capability_address(cap: &Self.WithdrawalCapability): &address {
        return &move(cap).account_address;
    }

    // Return a reference to the address associated with the given key rotation capability
    public key_rotation_capability_address(cap: &Self.KeyRotationCapability): &address {
        return &move(cap).account_address;
    }

    // Checks if an account exists at `check_addr`
    public exists(check_addr: address): bool {
        return exists<T>(move(check_addr));
    }

    // The prologue is invoked at the beginning of every transaction
    // It verifies:
    // - The account's auth key matches the transaction's public key
    // - That the account has enough balance to pay for all of the gas
    // - That the sequence number matches the transaction's sequence key
    prologue() acquires T,ChannelLockedBy,Channel {
        let transaction_sender: address;
        let transaction_sender_exists: bool;
        let sender_account: &mut Self.T;
        let imm_sender_account: &Self.T;
        let sender_public_key: bytearray;
        let public_key_hash: bytearray;
        let gas_price: u64;
        let gas_units: u64;
        let max_transaction_fee: u64;
        let balance_amount: u64;
        let sequence_number_value: u64;
        let transaction_sequence_number_value: u64;

        transaction_sender = get_txn_sender();

        // FUTURE: Make these error codes sequential
        // Verify that the transaction sender's account exists
        transaction_sender_exists = exists<T>(copy(transaction_sender));
        assert(move(transaction_sender_exists), 5);

        // Load the transaction sender's account
        sender_account = borrow_global_mut<T>(copy(transaction_sender));

        // Check that the account has enough balance for all of the gas
        // Not check gas when tx execute on offchain vm.
        // Not check auth key for allow offchain vm to mock another use TODO(jole) security
        if(!ChannelTransaction.is_offchain()){
            // Check that the transaction's public key matches the account's current auth key
            sender_public_key = get_txn_public_key();
            public_key_hash = Hash.sha3_256(move(sender_public_key));
            assert(move(public_key_hash) == *(&copy(sender_account).authentication_key), 2);

            // Check that the account has enough balance for all of the gas
            gas_price = get_txn_gas_unit_price();
            gas_units = get_txn_max_gas_units();
            max_transaction_fee = move(gas_price) * move(gas_units);
            imm_sender_account = freeze(copy(sender_account));
            balance_amount = Self.balance_for_account(move(imm_sender_account));
            assert(move(balance_amount) >= move(max_transaction_fee), 6);
        }

        // Check that the transaction sequence number matches the sequence number of the account
        sequence_number_value = *(&mut move(sender_account).sequence_number);
        transaction_sequence_number_value = get_txn_sequence_number();
        assert(copy(transaction_sequence_number_value) >= copy(sequence_number_value), 3);
        assert(move(transaction_sequence_number_value) == move(sequence_number_value), 4);

        if(ChannelTransaction.is_channel_txn()){
            Self.channel_prologue();
        }
        return;
    }

    // The epilogue is invoked at the end of transactions.
    // It collects gas and bumps the sequence number
    epilogue() acquires T,Channel,ChannelGlobalEvents {
        let transaction_sender: address;
        let sender_account: &mut Self.T;
        let transaction_fee_account: &mut Self.T;
        let imm_sender_account: &Self.T;
        let gas_price: u64;
        let gas_units_remaining: u64;
        let starting_gas_units: u64;
        let transaction_fee_amount: u64;
        let balance_amount: u64;
        let transaction_fee: LibraCoin.T;
        let transaction_sequence_number_value: u64;


        // Not charge when tx execute on offchain vm.
        if(!ChannelTransaction.is_offchain()){
             transaction_sender = get_txn_sender();

            // Load the transaction sender's account
            sender_account = borrow_global_mut<T>(copy(transaction_sender));

        // Charge for gas
        gas_price = get_txn_gas_unit_price();
        starting_gas_units = get_txn_max_gas_units();
        gas_units_remaining = get_gas_remaining();
        transaction_fee_amount = move(gas_price) * (move(starting_gas_units) - move(gas_units_remaining));
        imm_sender_account = freeze(copy(sender_account));
        balance_amount = Self.balance_for_account(move(imm_sender_account));
        assert(move(balance_amount) >= copy(transaction_fee_amount), 6);

        transaction_fee = Self.withdraw_from_account(copy(sender_account), move(transaction_fee_amount));

        // Bump the sequence number
        transaction_sequence_number_value = get_txn_sequence_number();
        *(&mut move(sender_account).sequence_number) = move(transaction_sequence_number_value) + 1;
        // Pay the transaction fee into the transaction fee pot
        transaction_fee_account = borrow_global_mut<T>(0xFEE);
        LibraCoin.deposit(&mut move(transaction_fee_account).balance, move(transaction_fee));
        }
        if(ChannelTransaction.is_channel_txn()){
            Self.channel_epilogue();
        }
        return;
    }

    /// Events
    //
    // Derive a fresh unique id by using sender's EventHandleGenerator. The generated bytearray is indeed unique because it
    // was derived from the hash(sender's EventHandleGenerator || sender_address). This module guarantees that the
    // EventHandleGenerator is only going to be monotonically increased and there's no way to revert it or destroy it. Thus
    // such counter is going to give distinct value for each of the new event stream under each sender. And since we
    // hash it with the sender's address, the result is guaranteed to be globally unique.
    fresh_guid(counter: &mut Self.EventHandleGenerator, sender: address): bytearray {
        let count: &mut u64;
        let count_bytes: bytearray;
        let preimage: bytearray;
        let sender_bytes: bytearray;

        count = &mut move(counter).counter;
        sender_bytes = AddressUtil.address_to_bytes(move(sender));

        count_bytes = U64Util.u64_to_bytes(*copy(count));
        *move(count) = *copy(count) + 1;

        // EventHandleGenerator goes first just in case we want to extend address in the future.
        preimage = BytearrayUtil.bytearray_concat(move(count_bytes), move(sender_bytes));

        return move(preimage);
    }

    // Use EventHandleGenerator to generate a unique event handle that one can emit an event to.
    new_event_handle_impl<T: unrestricted>(counter: &mut Self.EventHandleGenerator, sender: address): Self.EventHandle<T> {
        return EventHandle<T> {counter: 0, guid: Self.fresh_guid(move(counter), move(sender))};
    }

    // Use sender's EventHandleGenerator to generate a unique event handle that one can emit an event to.
    public new_event_handle<T: unrestricted>(): Self.EventHandle<T> acquires T {
        let sender_account_ref: &mut Self.T;
        let sender_bytes: bytearray;
        sender_account_ref = borrow_global_mut<T>(get_txn_sender());
        return Self.new_event_handle_impl<T>(&mut (move(sender_account_ref)).event_generator, get_txn_sender());
    }

    // Emit an event with payload `msg` by using handle's key and counter. Will change the payload from bytearray to a
    // generic type parameter once we have generics.
    public emit_event<T: unrestricted>(handle_ref: &mut Self.EventHandle<T>, msg: T) {
        let count: &mut u64;
        let guid: bytearray;

        guid = *&copy(handle_ref).guid;
        count = &mut move(handle_ref).counter;

        Self.write_to_event_store<T>(move(guid), *copy(count), move(msg));
        *move(count) = *copy(count) + 1;
        return;
    }

    // Native procedure that writes to the actual event stream in Event store
    // This will replace the "native" portion of EmitEvent bytecode
    native write_to_event_store<T: unrestricted>(guid: bytearray, count: u64, msg: T);

    // Destroy a unique handle.
    public destroy_handle<T: unrestricted>(handle: Self.EventHandle<T>) {
        let guid: bytearray;
        let count: u64;
        EventHandle<T> { count, guid } = move(handle);
        return;
    }

    //Channel functions

    // execute in genesis function
    initialize_channel() acquires T {
        let channel_global_account: &mut Self.T;
        let channel_global_events: Self.ChannelGlobalEvents;
        let sender: address;

        sender = get_txn_sender();
        assert(copy(sender) == 0x1D9, 11);
        channel_global_account = borrow_global_mut<T>(0x1D9);
        channel_global_events = ChannelGlobalEvents{
            events: Self.new_event_handle_impl<Self.ChannelEvent>(&mut move(channel_global_account).event_generator, copy(sender)),
        };
        move_to_sender<ChannelGlobalEvents>(move(channel_global_events));
        return;
    }

    // Enable channel feature for sender
    public enable_channel(){
        assert(!Self.is_channel_enable(get_txn_sender()), 1000);
        move_to_sender<UserChannels>(UserChannels{
            channels: Vector.empty<address>(),
        });
        return;
    }

    // Check if channel feature enable for addr
    public is_channel_enable(addr: address): bool {
        return exists<UserChannels>(move(addr));
    }

    add_channel(addr: address, channel_address: address) acquires UserChannels {
        let user_channels: &mut Self.UserChannels;

        user_channels = borrow_global_mut<UserChannels>(copy(addr));
        assert(!Vector.contains<address>(&copy(user_channels).channels, &channel_address), 1001);
        Vector.push_back<address>(&mut move(user_channels).channels, move(channel_address));
        return;
    }

    remove_channel(addr: address, channel_address: address) acquires UserChannels {
        let user_channels: &mut Self.UserChannels;

        user_channels = borrow_global_mut<UserChannels>(copy(addr));
        assert(Vector.contains<address>(&move(user_channels).channels, &channel_address), 10002);
        //TODO wait Vector.remove
        return;
    }

    withdraw_from_participant(participant: address, amount: u64): LibraCoin.T acquires T {
        let account: &mut Self.T;

        account = borrow_global_mut<T>(move(participant));
        if (*&copy(account).delegated_withdrawal_capability) {
            // The sender has delegated the privilege to withdraw from her account elsewhere--abort.
            abort(11);
        } else {
            // The sender has retained her withdrawal privileges--proceed.
            return Self.withdraw_from_account(move(account), move(amount));
        }
    }

    // participants is a sorted vector.
    public generate_channel_address(participants: &Vector.T<address>): address {
        let bytes: bytearray;
        let length: u64;
        let idx: u64;
        let channel_address: address;
        let hash: bytearray;

        length = Vector.length<address>(copy(participants));
        bytes = AddressUtil.address_to_bytes(Vector.get<address>(copy(participants), 0));
        idx = 1;
        while (copy(idx) < copy(length)) {
            bytes = BytearrayUtil.bytearray_concat(copy(bytes), AddressUtil.address_to_bytes(Vector.get<address>(copy(participants), copy(idx))));
            idx = copy(idx) + 1;
        }
        hash = Hash.sha3_256(move(bytes));
        channel_address = AddressUtil.bytes_to_address(move(hash));
        return move(channel_address);
    }

    public new_participants_vector(one: address, two: address): Vector.T<address>{
        let participants: Vector.T<address>;

        assert(copy(one) != copy(two), 1003);
        participants = Vector.empty<address>();
        if(AddressUtil.compare_address(copy(one), copy(two)) == 0){
            Vector.push_back<address>(
                &mut participants,
                copy(one)
            );
            Vector.push_back<address>(
                &mut participants,
                copy(two)
            );
        }else{
            Vector.push_back<address>(
                &mut participants,
                copy(two)
            );
            Vector.push_back<address>(
                &mut participants,
                copy(one)
            );
        }
        return move(participants);
    }

    native move_to_channel<R:resource>(r: R);
    native move_from_channel<R:resource>():R;
    native destroy_resource(lock_owner: address, module_id: bytearray);

    //only support one participant currently.
    public open_channel(participant: address, sender_amount: u64, participant_amount: u64) acquires T,Channel, UserChannels, ChannelGlobalEvents {
        let txn_channel_address: address;
        let channel_address: address;
        let participants: Vector.T<address>;
        let sender: address;
        let channel: Self.Channel;
        let channel_mirror: Self.ChannelMirror;
        let sender_channel_account: Self.ChannelParticipantAccount;
        let participant_channel_account: Self.ChannelParticipantAccount;
        let channel_account: &mut Self.T;

        sender = get_txn_sender();

        assert(copy(sender) != copy(participant), 1003);
        assert(copy(sender) == ChannelTransaction.get_proposer(), 1004);

        assert(Self.is_channel_enable(copy(sender)), 1113);
        assert(Self.is_channel_enable(copy(participant)), 1114);

        participants = Self.new_participants_vector(copy(sender), copy(participant));

        txn_channel_address = ChannelTransaction.get_channel_address();
        channel_address = Self.generate_channel_address(&participants);

        assert(move(txn_channel_address) == copy(channel_address), 1005);
        assert(ChannelTransaction.get_txn_channel_sequence_number() == 0, 1006);

        Self.create_account(copy(channel_address));
        channel_account = borrow_global_mut<T>(copy(channel_address));

        channel = Channel {
           channel_sequence_number: 0,
           stage: 0,
           participants: move(participants),
           events: Self.new_event_handle_impl<Self.ChannelEvent>(&mut move(channel_account).event_generator, copy(channel_address)),
        };
        channel_mirror = ChannelMirror {
            channel_sequence_number: 0,
        };
        sender_channel_account = ChannelParticipantAccount{
            balance: Self.withdraw_from_sender(move(sender_amount)),
        };
        participant_channel_account = ChannelParticipantAccount{
            balance: Self.withdraw_from_participant(copy(participant), move(participant_amount)),
        };
        Self.move_to_channel<Self.Channel>(move(channel));
        ChannelUtil.create_module_list();
        ChannelUtil.move_to_shared<Self.ChannelMirror>(move(channel_mirror));
        ChannelUtil.move_to_participant<Self.ChannelParticipantAccount>(copy(sender), move(sender_channel_account));
        ChannelUtil.move_to_participant<Self.ChannelParticipantAccount>(copy(participant), move(participant_channel_account));
        Self.add_channel(move(sender), copy(channel_address));
        Self.add_channel(move(participant), copy(channel_address));
        Self.emit_channel_event(move(channel_address));
        return;
    }

    // If channel on chain total balance change, should call this function to trigger event.
    public emit_channel_event(channel_address: address) acquires Channel, ChannelGlobalEvents {
        let channel: &mut Self.Channel;
        channel = borrow_global_mut<Channel>(copy(channel_address));
        Self.do_emit_channel_event(move(channel_address), move(channel));
        return;
    }

    do_emit_channel_event(channel_address: address, channel: &mut Self.Channel) acquires ChannelGlobalEvents {
        let global_events: &mut Self.ChannelGlobalEvents;
        let event: Self.ChannelEvent;
        let balances: Vector.T<u64>;
        let len: u64;
        let index: u64;

        global_events = borrow_global_mut<ChannelGlobalEvents>(0x1D9);
        balances = Vector.empty<u64>();

        len = Vector.length<address>(&copy(channel).participants);
        index = 0;
        while (copy(index) < copy(len)) {
            Vector.push_back<u64>(&mut balances, Self.channel_balance(Vector.get<address>(&copy(channel).participants, copy(index))));
            index = copy(index) + 1;
        }

        event = ChannelEvent{
            channel_address: copy(channel_address),
            stage: *&copy(channel).stage,
            balances: move(balances),
        };

        Self.emit_event<Self.ChannelEvent>(&mut move(channel).events, copy(event));
        Self.emit_event<Self.ChannelEvent>(&mut move(global_events).events, copy(event));
        return;
    }

    // Deposit coin to proposer's ChannelParticipantAccount
    public deposit_to_channel(coin: LibraCoin.T){
        Self.deposit_to_participant(ChannelTransaction.get_proposer(), move(coin));
        return;
    }

    // TODO set this function to private.
    public deposit_to_participant(participant: address, coin: LibraCoin.T) {
        let channel_account: &mut Self.ChannelParticipantAccount;

        channel_account = ChannelUtil.borrow_from_participant_mut<Self.ChannelParticipantAccount>(copy(participant));
        LibraCoin.deposit(&mut move(channel_account).balance, move(coin));
        //Self.emit_channel_event(ChannelTransaction.get_channel_address());
        return;
    }

    // Withdraw LibraCoin from proposer's ChannelParticipantAccount
    public withdraw_from_channel(amount: u64): LibraCoin.T {
        let proposer: address;
        let channel_account: &mut Self.ChannelParticipantAccount;
        let withdraw_coin: LibraCoin.T;

        proposer = ChannelTransaction.get_proposer();
        channel_account = ChannelUtil.borrow_from_participant_mut<Self.ChannelParticipantAccount>(copy(proposer));
        withdraw_coin = LibraCoin.withdraw(&mut move(channel_account).balance, move(amount));
        //Self.emit_channel_event(ChannelTransaction.get_channel_address());
        return move(withdraw_coin);
    }

    // Channel participant balance.
    public channel_balance(participant: address): u64 {
        let channel_account: & Self.ChannelParticipantAccount;
        channel_account = ChannelUtil.borrow_from_participant<Self.ChannelParticipantAccount>(copy(participant));
        return LibraCoin.value(&move(channel_account).balance);
    }

    // Get current channel's sequence number.
    public channel_sequence_number(): u64{
        // get channel sequence number with ChannelMirror,
        // because Channel's channel sequence number may be old.
        let channel_mirror: &Self.ChannelMirror;
        channel_mirror = ChannelUtil.borrow_from_shared<Self.ChannelMirror>();
        return *&move(channel_mirror).channel_sequence_number;
    }

    // Check current channel is locked
    public channel_is_locked():bool acquires Channel {
        let channel: &Self.Channel;
        channel = borrow_global<Channel>(ChannelTransaction.get_channel_address());
        return *&copy(channel).stage == 1;
    }

    // Check current channel is locked
    public channel_is_closed():bool acquires Channel {
        let channel: &Self.Channel;
        channel = borrow_global<Channel>(ChannelTransaction.get_channel_address());
        return *&copy(channel).stage == 2;
    }

    public challenge() acquires Channel,ChannelLockedBy,ChannelGlobalEvents,T {
        let channel: &mut Self.Channel;
        let channel_address: address;
        let proposer: address;
        let txn_channel_sequence_number: u64;
        let locked_by: & Self.ChannelLockedBy;
        let challenged_by: Self.ChannelChallengedBy;

        channel_address = ChannelTransaction.get_channel_address();
        proposer = ChannelTransaction.get_proposer();
        txn_channel_sequence_number = ChannelTransaction.get_txn_channel_sequence_number();

        channel = borrow_global_mut<Channel>(copy(channel_address));
        locked_by = borrow_global<ChannelLockedBy>(copy(channel_address));

        // channel stage must is locked
        assert(*&copy(channel).stage == 1, 1007);
        //TODO locked_by is checked at channel_prologue, should check again?
        assert(*&copy(locked_by).participant != copy(proposer), 1008);
        assert(move(txn_channel_sequence_number) >= *(&copy(channel).channel_sequence_number), 1009);

        challenged_by = ChannelChallengedBy {
            participant: copy(proposer),
        };
        Self.move_to_channel<Self.ChannelChallengedBy>(move(challenged_by));
        Self.do_close(copy(channel_address), move(channel), *&copy(locked_by).participant);
        Self.confiscate_resource(*&copy(locked_by).participant);
        return;
    }

    public has_authorized_by_participants(): bool {
        let participant_signatures: Vector.T<bytearray>;
        let participant_signatures_ref: &Vector.T<bytearray>;
        let signature: bytearray;
        let len: u64;
        let index: u64;

        participant_signatures = ChannelTransaction.get_signatures();
        participant_signatures_ref = &participant_signatures;
        len = Vector.length<bytearray>(copy(participant_signatures_ref));
        index = 0;
        while (copy(index) < copy(len)) {
            signature = Vector.get<bytearray>(copy(participant_signatures_ref), copy(index));
            // signature is an empty bytearray if the txn is not authorized by the participant
            if (move(signature) == h"") {
                return false;
            }
            index = copy(index) + 1;
        }

        return true;
    }

    public resolve() acquires Channel, ChannelGlobalEvents {
        let channel: &mut Self.Channel;
        let channel_address: address;
        let txn_channel_sequence_number:u64;
        let locked_by: Self.ChannelLockedBy;

        channel_address = ChannelTransaction.get_channel_address();
        txn_channel_sequence_number = ChannelTransaction.get_txn_channel_sequence_number();

        channel = borrow_global_mut<Channel>(copy(channel_address));
        if(!ChannelTransaction.is_offchain() && !Self.has_authorized_by_participants()){
            *(&mut copy(channel).stage) = 3;
        } else {
            *(&mut copy(channel).stage) = 0;
            Self.do_emit_channel_event(copy(channel_address), copy(channel));
        }
        locked_by = Self.move_from_channel<Self.ChannelLockedBy>();
        Self.destroy_locked_by(move(locked_by));
        return;
    }

    destroy_locked_by(locked_by: Self.ChannelLockedBy){
        let participant: address;
        let time_lock: u64;
        ChannelLockedBy{participant, time_lock} = move(locked_by);
        return;
    }

    // Withdraw LibraCoin from participant's ChannelParticipantAccount
    // only used by challenge_succeed()
    withdraw_from_participant_channel(participant: address, amount: u64): LibraCoin.T {
        let channel_account: &mut Self.ChannelParticipantAccount;
        let withdraw_coin: LibraCoin.T;

        channel_account = ChannelUtil.borrow_from_participant_mut<Self.ChannelParticipantAccount>(copy(participant));
        withdraw_coin = LibraCoin.withdraw(&mut move(channel_account).balance, move(amount));
        return move(withdraw_coin);
    }

    confiscate_resource(violator: address) acquires T {
        let channel_account: Self.ChannelParticipantAccount;
        let balance: u64;
        let coin: LibraCoin.T;
        let proposer: address;
        let participant_balance: u64;
        let participant_coin: LibraCoin.T;

        proposer = ChannelTransaction.get_proposer();
        assert(get_txn_sender() == copy(proposer), 1233);
        balance = Self.channel_balance(copy(proposer));
        coin = Self.withdraw_from_channel(move(balance));
        assert(Self.channel_balance(copy(proposer)) == 0, 1234);
        Self.deposit(copy(proposer), move(coin));

        participant_balance = Self.channel_balance(copy(violator));
        participant_coin = Self.withdraw_from_participant_channel(copy(violator), move(participant_balance));
        assert(Self.channel_balance(copy(violator)) == 0, 1235);
        Self.deposit(move(proposer), move(participant_coin));

        return;
    }

    close_resources(violator: address) {
        let len: u64;
        let i: u64;
        let module_id: bytearray;

        len = ChannelUtil.channel_modules_len();
        i = 0;
        while (copy(i) < copy(len)) {
            module_id = ChannelUtil.channel_modules_pop();
            Self.destroy_resource(copy(violator), copy(module_id));
            i = copy(i) + 1;
        }

        return;
    }

    do_close(channel_address: address, channel: &mut Self.Channel, violator: address) acquires ChannelGlobalEvents {
        *(&mut copy(channel).stage) = 2;
        Self.close_resources(move(violator));
        Self.do_emit_channel_event(copy(channel_address), copy(channel));
        return;
    }

    public close(violator: address) acquires Channel, ChannelGlobalEvents, ChannelLockedBy {
        let channel_address: address;
        let channel: &mut Self.Channel;
        let sender: address;
        let locked_by: Self.ChannelLockedBy;
        let locked_by_ref: &Self.ChannelLockedBy;

        sender = get_txn_sender();
        channel_address = ChannelTransaction.get_channel_address();
        channel = borrow_global_mut<Channel>(copy(channel_address));
        locked_by_ref = borrow_global<ChannelLockedBy>(copy(channel_address));

        assert(*&copy(channel).stage == 1, 1007);
        assert(*&copy(locked_by_ref).participant == copy(sender), 1008);
        assert(*&copy(locked_by_ref).time_lock <= ChannelTransaction.get_current_block_height(), 1009);

        locked_by = Self.move_from_channel<Self.ChannelLockedBy>();
        Self.destroy_locked_by(move(locked_by));
        Self.do_close(copy(channel_address), copy(channel), move(violator));
        Self.do_emit_channel_event(move(channel_address), move(channel));
        return;
    }

    check_channel_locked_by() acquires ChannelLockedBy{
        let locked_by: & Self.ChannelLockedBy;
        locked_by = borrow_global<ChannelLockedBy>(ChannelTransaction.get_channel_address());
        // locker cannot propose txn before timeout
        if (*&copy(locked_by).time_lock > ChannelTransaction.get_current_block_height()) {
            assert(*&copy(locked_by).participant != ChannelTransaction.get_proposer(), 1008);
        }

        return;
    }

    // The prologue is invoked at the beginning of every channel transaction
    channel_prologue() acquires T,ChannelLockedBy,Channel {
        let txn_channel_sequence_number: u64;
        let channel_sequence_number: u64;
        let mirror_channel_sequence_number: u64;
        let channel_address: address;
        let channel: & Self.Channel;
        let channel_mirror: &Self.ChannelMirror;
        let proposer: address;
        let participants: &Vector.T<address>;
        let participant: address;
        let participant_account: &Self.T;
        let participant_public_keys: Vector.T<bytearray>;
        let participant_public_keys_ref: &Vector.T<bytearray>;
        let public_key: bytearray;
        let public_key_hash: bytearray;
        let len: u64;
        let index: u64;

        proposer = ChannelTransaction.get_proposer();
        txn_channel_sequence_number = ChannelTransaction.get_txn_channel_sequence_number();
        channel_address = ChannelTransaction.get_channel_address();

        // txn_sequence_number 0 should be open channel txn.
        if(copy(txn_channel_sequence_number) == 0){
            assert(!Self.exists(copy(channel_address)), 1011);
            //assert(!exists<Channel>(copy(channel_address)), 1011);
            return;
        }else{
            channel = borrow_global<Channel>(copy(channel_address));
            channel_mirror = ChannelUtil.borrow_from_shared<Self.ChannelMirror>();

            channel_sequence_number = *(&copy(channel).channel_sequence_number);
            mirror_channel_sequence_number = *(&copy(channel_mirror).channel_sequence_number);

            assert(copy(txn_channel_sequence_number) == copy(mirror_channel_sequence_number), 1012);
            assert(copy(mirror_channel_sequence_number) >= copy(channel_sequence_number), 1013);

            // Check that the transaction's public keys matches the participants' current auth key
            participants = &copy(channel).participants;
            // Check proposer is a participant.
            assert(Vector.contains<address>(copy(participants), &proposer), 1014);
            participant_public_keys = ChannelTransaction.get_public_keys();
            participant_public_keys_ref = &participant_public_keys;
            len = Vector.length<address>(copy(participants));
            index = 0;
            while (copy(index) < copy(len)) {
                public_key = Vector.get<bytearray>(copy(participant_public_keys_ref), copy(index));
                public_key_hash = Hash.sha3_256(copy(public_key));
                participant = Vector.get<address>(copy(participants), copy(index));
                participant_account = borrow_global<T>(copy(participant));
                assert(move(public_key_hash) == *(&move(participant_account).authentication_key), 1015);
                index = copy(index) + 1;
            }
            if (*&copy(channel).stage == 1 && !Self.has_authorized_by_participants()) {
                Self.check_channel_locked_by();
            }
            return;
        }
    }

    channel_epilogue() acquires Channel,ChannelGlobalEvents {
        let channel: &mut Self.Channel;
        let channel_mirror: &mut Self.ChannelMirror;
        let proposer: address;
        let txn_channel_sequence_number: u64;
        let new_channel_sequence_number: u64;
        let channel_address: address;
        let locked_by: Self.ChannelLockedBy;

        proposer = ChannelTransaction.get_proposer();
        channel_address = ChannelTransaction.get_channel_address();
        channel = borrow_global_mut<Channel>(copy(channel_address));
        channel_mirror = ChannelUtil.borrow_from_shared_mut<Self.ChannelMirror>();

        txn_channel_sequence_number = ChannelTransaction.get_txn_channel_sequence_number();

        new_channel_sequence_number = move(txn_channel_sequence_number) + 1;
        *(&mut copy(channel_mirror).channel_sequence_number) = copy(new_channel_sequence_number);

        if(!ChannelTransaction.is_offchain()){
            *(&mut copy(channel).channel_sequence_number) = copy(new_channel_sequence_number);
            if(!Self.has_authorized_by_participants()){
                if (*&copy(channel).stage == 0){
                    // set channel stage to locked
                    *(&mut copy(channel).stage) = 1;
                    Self.do_emit_channel_event(copy(channel_address), copy(channel));
                    locked_by = ChannelLockedBy{
                        participant: copy(proposer),
                        // TODO: is 1 block-time long enough? make it configurable?
                        time_lock: ChannelTransaction.get_current_block_height() + 3,
                    };
                    Self.move_to_channel<Self.ChannelLockedBy>(move(locked_by));
                } else {
                    if(*&copy(channel).stage == 2){
                        // if channel is locked at prologue, it must become closed at epilogue.
                    } else {
                        if(*&copy(channel).stage == 3){
                            // resolve without participant's signature
                            *(&mut copy(channel).stage) = 0;
                            Self.do_emit_channel_event(copy(channel_address), copy(channel));
                        } else {
                            abort(1016);
                        }
                    }
                }
            }
        }
        return;
    }

    // for test, will be removed after challenge test is ready
    public test(lock_owner: address) acquires T {
        Self.close_resources(copy(lock_owner));
        Self.confiscate_resource(copy(lock_owner));
        return;
    }

}
