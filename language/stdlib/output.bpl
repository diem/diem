
// ** prelude from <inline-prelude>

// ================================================================================
// Notation

// This files contains a Handlebars Rust template for the prover's Boogie prelude.
// The template language constructs allow the prelude to adjust the actual content
// to multiple options. We only use a few selected template constructs which are
// mostly self-explaining. See the handlebars crate documentation for more information.
//
// The object passed in as context for templates is the struct cli::Options and its
// sub-structs.

// ================================================================================
// Domains

// Debug tracking
// --------------

// Debug tracking is used to inject information used for model analysis. The generated code emits statements
// like this:
//
//     assume $DebugTrackLocal(file_id, byte_index, var_idx, $Value);
//
// While those tracking assumptions are trivially true for the provers logic, the solver (at least Z3)
// will construct a function mapping which appears in the model, e.g.:
//
//     $DebugTrackLocal -> {
//         1 440 0 (Vector (ValueArray |T@[Int]$Value!val!0| 0)) -> true
//         1 533 1 ($Integer 1) -> true
//         ...
//         else -> true
//     }
//
// This information can then be read out from the model.


// Tracks debug information for a parameter, local or a return parameter. Return parameter indices start at
// the overall number of locals (including parameters).
function $DebugTrackLocal(file_id: int, byte_index:  int, var_idx: int, $Value: $Value) : bool {
  true
}

// Tracks at which location a function was aborted.
function $DebugTrackAbort(file_id: int, byte_index: int) : bool {
  true
}

// Tracks the $Value of a specification (sub-)expression.
function $DebugTrackExp(module_id: int, node_id: int, $Value: $Value) : $Value { $Value }


// Path type
// ---------

type {:datatype} $Path;
function {:constructor} $Path(p: [int]int, size: int): $Path;
const $EmptyPath: $Path;
axiom size#$Path($EmptyPath) == 0;

function {:inline} $path_index_at(p: $Path, i: int): int {
    p#$Path(p)[i]
}

// Type Values
// -----------

type $TypeName;
type $FieldName = int;
type $LocalName;
type {:datatype} $TypeValue;
function {:constructor} $BooleanType() : $TypeValue;
function {:constructor} $IntegerType() : $TypeValue;
function {:constructor} $AddressType() : $TypeValue;
function {:constructor} $StrType() : $TypeValue;
function {:constructor} $VectorType(t: $TypeValue) : $TypeValue;
function {:constructor} $StructType(name: $TypeName, ps: $TypeValueArray, ts: $TypeValueArray) : $TypeValue;
function {:constructor} $TypeType(): $TypeValue;
function {:constructor} $ErrorType() : $TypeValue;

function {:inline} $DefaultTypeValue() : $TypeValue { $ErrorType() }
function {:builtin "MapConst"} $MapConstTypeValue(tv: $TypeValue): [int]$TypeValue;

type {:datatype} $TypeValueArray;
function {:constructor} $TypeValueArray(v: [int]$TypeValue, l: int): $TypeValueArray;
const $EmptyTypeValueArray: $TypeValueArray;
axiom l#$TypeValueArray($EmptyTypeValueArray) == 0;
axiom v#$TypeValueArray($EmptyTypeValueArray) == $MapConstTypeValue($DefaultTypeValue());


// Values
// ------

type {:datatype} $Value;

const $MAX_U8: int;
axiom $MAX_U8 == 255;
const $MAX_U64: int;
axiom $MAX_U64 == 18446744073709551615;
const $MAX_U128: int;
axiom $MAX_U128 == 340282366920938463463374607431768211455;

function {:constructor} $Boolean(b: bool): $Value;
function {:constructor} $Integer(i: int): $Value;
function {:constructor} $Address(a: int): $Value;
function {:constructor} $Vector(v: $ValueArray): $Value; // used to both represent move Struct and Vector
function {:constructor} $Range(lb: $Value, ub: $Value): $Value;
function {:constructor} $Type(t: $TypeValue): $Value;
function {:constructor} $Error(): $Value;

function {:inline} $DefaultValue(): $Value { $Error() }
function {:builtin "MapConst"} $MapConstValue(v: $Value): [int]$Value;

function {:inline} $IsValidU8(v: $Value): bool {
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U8
}

function {:inline} $IsValidU8Vector(vec: $Value): bool {
  $Vector_is_well_formed(vec)
  && (forall i: int :: {$select_vector(vec, i)} 0 <= i && i < $vlen(vec) ==> $IsValidU8($select_vector(vec, i)))
}

function {:inline} $IsValidU64(v: $Value): bool {
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U64
}

function {:inline} $IsValidU128(v: $Value): bool {
  is#$Integer(v) && i#$Integer(v) >= 0 && i#$Integer(v) <= $MAX_U128
}

function {:inline} $IsValidNum(v: $Value): bool {
  is#$Integer(v)
}


// Value Array
// -----------





// This is the implementation of $ValueArray using integer maps

type {:datatype} $ValueArray;

function {:constructor} $ValueArray(v: [int]$Value, l: int): $ValueArray;

function $EmptyValueArray(): $ValueArray;
axiom l#$ValueArray($EmptyValueArray()) == 0;
axiom v#$ValueArray($EmptyValueArray()) == $MapConstValue($Error());

function {:inline} $ReadValueArray(a: $ValueArray, i: int): $Value {
    (
        v#$ValueArray(a)[i]
    )
}

function {:inline} $LenValueArray(a: $ValueArray): int {
    (
        l#$ValueArray(a)
    )
}

function {:inline} $RemoveValueArray(a: $ValueArray): $ValueArray {
    (
        var l := l#$ValueArray(a) - 1;
        $ValueArray(
            (lambda i: int ::
                if i >= 0 && i < l then v#$ValueArray(a)[i] else $DefaultValue()),
            l
        )
    )
}

function {:inline} $RemoveIndexValueArray(a: $ValueArray, i: int): $ValueArray {
    (
        var l := l#$ValueArray(a) - 1;
        $ValueArray(
            (lambda j: int ::
                if j >= 0 && j < l then
                    if j < i then v#$ValueArray(a)[j] else v#$ValueArray(a)[j+1]
                else $DefaultValue()),
            l
        )
    )
}

function {:inline} $ConcatValueArray(a1: $ValueArray, a2: $ValueArray): $ValueArray {
    (
        var l1, m1, l2, m2 := l#$ValueArray(a1), v#$ValueArray(a1), l#$ValueArray(a2), v#$ValueArray(a2);
        $ValueArray(
            (lambda i: int ::
                if i >= 0 && i < l1 + l2 then
                    if i < l1 then m1[i] else m2[i - l1]
                else
                    $DefaultValue()),
            l1 + l2)
    )
}

function {:inline} $ReverseValueArray(a: $ValueArray): $ValueArray {
    (
        var l := l#$ValueArray(a);
        $ValueArray(
            (lambda i: int :: if 0 <= i && i < l then v#$ValueArray(a)[l - i - 1] else $DefaultValue()),
            l
        )
    )
}

function {:inline} $SliceValueArray(a: $ValueArray, i: int, j: int): $ValueArray { // return the sliced vector of a for the range [i, j)
    $ValueArray((lambda k:int :: if 0 <= k && k < j-i then v#$ValueArray(a)[i+k] else $DefaultValue()), (if j-i < 0 then 0 else j-i))
}

function {:inline} $ExtendValueArray(a: $ValueArray, elem: $Value): $ValueArray {
    (var len := l#$ValueArray(a);
     $ValueArray(v#$ValueArray(a)[len := elem], len + 1))
}

function {:inline} $UpdateValueArray(a: $ValueArray, i: int, elem: $Value): $ValueArray {
    $ValueArray(v#$ValueArray(a)[i := elem], l#$ValueArray(a))
}

function {:inline} $SwapValueArray(a: $ValueArray, i: int, j: int): $ValueArray {
    $ValueArray(v#$ValueArray(a)[i := v#$ValueArray(a)[j]][j := v#$ValueArray(a)[i]], l#$ValueArray(a))
}

function {:inline} $IsEmpty(a: $ValueArray): bool {
    l#$ValueArray(a) == 0
}

// All invalid elements of array are DefaultValue. This is useful in specialized
// cases. This is used to defined normalization for $Vector
function {:inline} $IsNormalizedValueArray(a: $ValueArray, len: int): bool {
    (forall i: int :: i < 0 || i >= len ==> v#$ValueArray(a)[i] == $DefaultValue())
}


 //end of backend.vector_using_sequences


// Stratified Functions on Values
// ------------------------------

// TODO: templatize this or move it back to the translator. For now we
//   prefer to handcode this so its easier to evolve the model independent of the
//   translator.

const $StratificationDepth: int;
axiom $StratificationDepth == 4;



// Generate a stratified version of IsEqual for depth of 4.

function  $IsEqual_stratified(v1: $Value, v2: $Value): bool {
    (v1 == v2) ||
    (is#$Vector(v1) &&
     is#$Vector(v2) &&
     $vlen(v1) == $vlen(v2) &&
     (forall i: int :: 0 <= i && i < $vlen(v1) ==> $IsEqual_level1($select_vector(v1,i), $select_vector(v2,i))))
}

function  $IsEqual_level1(v1: $Value, v2: $Value): bool {
    (v1 == v2) ||
    (is#$Vector(v1) &&
     is#$Vector(v2) &&
     $vlen(v1) == $vlen(v2) &&
     (forall i: int :: 0 <= i && i < $vlen(v1) ==> $IsEqual_level2($select_vector(v1,i), $select_vector(v2,i))))
}

function  $IsEqual_level2(v1: $Value, v2: $Value): bool {
    (v1 == v2) ||
    (is#$Vector(v1) &&
     is#$Vector(v2) &&
     $vlen(v1) == $vlen(v2) &&
     (forall i: int :: 0 <= i && i < $vlen(v1) ==> $IsEqual_level3($select_vector(v1,i), $select_vector(v2,i))))
}

function {:inline} $IsEqual_level3(v1: $Value, v2: $Value): bool {
    v1 == v2
}


function {:inline} $IsEqual(v1: $Value, v2: $Value): bool {
    $IsEqual_stratified(v1, v2)
}



// Generate stratified ReadValue for the depth of 4.


function  $ReadValue_stratified(p: $Path, v: $Value) : $Value {
    if (0 == size#$Path(p)) then
        v
    else
        $ReadValue_level1(p, $select_vector(v,$path_index_at(p, 0)))
}

function  $ReadValue_level1(p: $Path, v: $Value) : $Value {
    if (1 == size#$Path(p)) then
        v
    else
        $ReadValue_level2(p, $select_vector(v,$path_index_at(p, 1)))
}

function  $ReadValue_level2(p: $Path, v: $Value) : $Value {
    if (2 == size#$Path(p)) then
        v
    else
        $ReadValue_level3(p, $select_vector(v,$path_index_at(p, 2)))
}

function {:inline} $ReadValue_level3(p: $Path, v: $Value): $Value {
    v
}


function {:inline} $ReadValue(p: $Path, v: $Value): $Value {
    $ReadValue_stratified(p, v)
}

// Generate stratified $UpdateValue for the depth of 4.


function  $UpdateValue_stratified(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    (var poffset := offset + 0;
    if (poffset == size#$Path(p)) then
        new_v
    else
        $update_vector(v, $path_index_at(p, poffset),
                       $UpdateValue_level1(p, offset, $select_vector(v,$path_index_at(p, poffset)), new_v)))
}

function  $UpdateValue_level1(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    (var poffset := offset + 1;
    if (poffset == size#$Path(p)) then
        new_v
    else
        $update_vector(v, $path_index_at(p, poffset),
                       $UpdateValue_level2(p, offset, $select_vector(v,$path_index_at(p, poffset)), new_v)))
}

function  $UpdateValue_level2(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    (var poffset := offset + 2;
    if (poffset == size#$Path(p)) then
        new_v
    else
        $update_vector(v, $path_index_at(p, poffset),
                       $UpdateValue_level3(p, offset, $select_vector(v,$path_index_at(p, poffset)), new_v)))
}

function {:inline} $UpdateValue_level3(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    new_v
}


function {:inline} $UpdateValue(p: $Path, offset: int, v: $Value, new_v: $Value): $Value {
    $UpdateValue_stratified(p, offset, v, new_v)
}

// Generate stratified $IsPathPrefix for the depth of 4.


function  $IsPathPrefix_stratified(p1: $Path, p2: $Path): bool {
    if (0 == size#$Path(p1)) then
        true
    else if (p#$Path(p1)[0] == p#$Path(p2)[0]) then
        $IsPathPrefix_level1(p1, p2)
    else
        false
}

function  $IsPathPrefix_level1(p1: $Path, p2: $Path): bool {
    if (1 == size#$Path(p1)) then
        true
    else if (p#$Path(p1)[1] == p#$Path(p2)[1]) then
        $IsPathPrefix_level2(p1, p2)
    else
        false
}

function  $IsPathPrefix_level2(p1: $Path, p2: $Path): bool {
    if (2 == size#$Path(p1)) then
        true
    else if (p#$Path(p1)[2] == p#$Path(p2)[2]) then
        $IsPathPrefix_level3(p1, p2)
    else
        false
}

function {:inline} $IsPathPrefix_level3(p1: $Path, p2: $Path): bool {
    true
}


function {:inline} $IsPathPrefix(p1: $Path, p2: $Path): bool {
    $IsPathPrefix_stratified(p1, p2)
}

// Generate stratified $ConcatPath for the depth of 4.


function  $ConcatPath_stratified(p1: $Path, p2: $Path): $Path {
    if (0 == size#$Path(p2)) then
        p1
    else
        $ConcatPath_level1($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[0]], size#$Path(p1) + 1), p2)
}

function  $ConcatPath_level1(p1: $Path, p2: $Path): $Path {
    if (1 == size#$Path(p2)) then
        p1
    else
        $ConcatPath_level2($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[1]], size#$Path(p1) + 1), p2)
}

function  $ConcatPath_level2(p1: $Path, p2: $Path): $Path {
    if (2 == size#$Path(p2)) then
        p1
    else
        $ConcatPath_level3($Path(p#$Path(p1)[size#$Path(p1) := p#$Path(p2)[2]], size#$Path(p1) + 1), p2)
}

function {:inline} $ConcatPath_level3(p1: $Path, p2: $Path): $Path {
    p1
}


function {:inline} $ConcatPath(p1: $Path, p2: $Path): $Path {
    $ConcatPath_stratified(p1, p2)
}

// Vector related functions on Values
// ----------------------------------

function {:inline} $vlen(v: $Value): int {
    $LenValueArray(v#$Vector(v))
}

// Check that all invalid elements of vector are DefaultValue
function {:inline} $is_normalized_vector(v: $Value): bool {
    $IsNormalizedValueArray(v#$Vector(v), $vlen(v))
}

// Sometimes, we need the length as a Value, not an int.
function {:inline} $vlen_value(v: $Value): $Value {
    $Integer($vlen(v))
}
function {:inline} $mk_vector(): $Value {
    $Vector($EmptyValueArray())
}
function {:inline} $push_back_vector(v: $Value, elem: $Value): $Value {
    $Vector($ExtendValueArray(v#$Vector(v), elem))
}
function {:inline} $pop_back_vector(v: $Value): $Value {
    $Vector($RemoveValueArray(v#$Vector(v)))
}
function {:inline} $append_vector(v1: $Value, v2: $Value): $Value {
    $Vector($ConcatValueArray(v#$Vector(v1), v#$Vector(v2)))
}
function {:inline} $reverse_vector(v: $Value): $Value {
    $Vector($ReverseValueArray(v#$Vector(v)))
}
function {:inline} $update_vector(v: $Value, i: int, elem: $Value): $Value {
    $Vector($UpdateValueArray(v#$Vector(v), i, elem))
}
// $update_vector_by_value requires index to be a Value, not int.
function {:inline} $update_vector_by_value(v: $Value, i: $Value, elem: $Value): $Value {
    $Vector($UpdateValueArray(v#$Vector(v), i#$Integer(i), elem))
}
function {:inline} $select_vector(v: $Value, i: int) : $Value {
    $ReadValueArray(v#$Vector(v), i)
}
// $select_vector_by_value requires index to be a Value, not int.
function {:inline} $select_vector_by_value(v: $Value, i: $Value) : $Value {
    $select_vector(v, i#$Integer(i))
}
function {:inline} $swap_vector(v: $Value, i: int, j: int): $Value {
    $Vector($SwapValueArray(v#$Vector(v), i, j))
}
function {:inline} $slice_vector(v: $Value, r: $Value) : $Value {
    $Vector($SliceValueArray(v#$Vector(v), i#$Integer(lb#$Range(r)), i#$Integer(ub#$Range(r))))
}
function {:inline} $InVectorRange(v: $Value, i: int): bool {
    i >= 0 && i < $vlen(v)
}
function {:inline} $remove_vector(v: $Value, i:int): $Value {
    $Vector($RemoveIndexValueArray(v#$Vector(v), i))
}
function {:inline} $contains_vector(v: $Value, e: $Value): bool {
    (exists i:int :: 0 <= i && i < $vlen(v) && $IsEqual($select_vector(v,i), e))
}

function {:inline} $InRange(r: $Value, i: int): bool {
   i#$Integer(lb#$Range(r)) <= i && i < i#$Integer(ub#$Range(r))
}


// ============================================================================================
// Memory

type {:datatype} $Location;
function {:constructor} $Global(t: $TypeValue, a: int): $Location;
function {:constructor} $Local(i: int): $Location;
function {:constructor} $Param(i: int): $Location;

type {:datatype} $Reference;
function {:constructor} $Reference(l: $Location, p: $Path, v: $Value): $Reference;
const $DefaultReference: $Reference;

type {:datatype} $Memory;
function {:constructor} $Memory(domain: [$Location]bool, contents: [$Location]$Value): $Memory;

function $Memory__is_well_formed(m: $Memory): bool;

function {:builtin "MapConst"} $ConstMemoryDomain(v: bool): [$Location]bool;
function {:builtin "MapConst"} $ConstMemoryContent(v: $Value): [$Location]$Value;

const $EmptyMemory: $Memory;
axiom domain#$Memory($EmptyMemory) == $ConstMemoryDomain(false);
axiom contents#$Memory($EmptyMemory) == $ConstMemoryContent($DefaultValue());

var $m: $Memory;
var $abort_flag: bool;

procedure {:inline 1} $InitVerification() {
  // Set abort_flag to false
  $abort_flag := false;
}

// ============================================================================================
// Specifications

// TODO: unify some of this with instruction procedures to avoid duplication

// Tests whether resource exists.
function {:inline} $ResourceExistsRaw(m: $Memory, resource: $TypeValue, addr: int): bool {
    domain#$Memory(m)[$Global(resource, addr)]
}
function {:inline} $ResourceExists(m: $Memory, resource: $TypeValue, address: $Value): $Value {
    $Boolean($ResourceExistsRaw(m, resource, a#$Address(address)))
}

// Obtains Value of given resource.
function {:inline} $ResourceValue(m: $Memory, resource: $TypeValue, address: $Value): $Value {
  contents#$Memory(m)[$Global(resource, a#$Address(address))]
}

// Applies a field selection to a Value.
function {:inline} $SelectField(val: $Value, field: $FieldName): $Value { //breaks abstracts, we don't know $Fieldname = int
    $select_vector(val, field)
}

// Dereferences a reference.
function {:inline} $Dereference(ref: $Reference): $Value {
    v#$Reference(ref)
}

// Check whether sender account exists.
function {:inline} $ExistsTxnSenderAccount(m: $Memory, txn: $Transaction): bool {
   domain#$Memory(m)[$Global($LibraAccount_T_type_value(), sender#$Transaction(txn))]
}

function {:inline} $TxnSender(txn: $Transaction): $Value {
    $Address(sender#$Transaction(txn))
}

// Forward declaration of type Value of LibraAccount. This is declared so we can define
// $ExistsTxnSenderAccount and $LibraAccount_save_account
const unique $LibraAccount_T: $TypeName;
function $LibraAccount_T_type_value(): $TypeValue;
axiom is#$StructType($LibraAccount_T_type_value()) && name#$StructType($LibraAccount_T_type_value()) == $LibraAccount_T;
function $LibraAccount_Balance_type_value(tv: $TypeValue): $TypeValue;

// ============================================================================================
// Instructions

procedure {:inline 1} $Exists(address: $Value, t: $TypeValue) returns (dst: $Value)
free requires is#$Address(address);
{
    dst := $ResourceExists($m, t, address);
}

procedure {:inline 1} $MoveToRaw(ta: $TypeValue, a: int, v: $Value)
{
    var l: $Location;

    l := $Global(ta, a);
    if ($ResourceExistsRaw($m, ta, a)) {
        $abort_flag := true;
        return;
    }
    $m := $Memory(domain#$Memory($m)[l := true], contents#$Memory($m)[l := v]);
}

procedure {:inline 1} $MoveTo(ta: $TypeValue, v: $Value, signer: $Value)
{
    var addr: $Value;

    call addr := $Signer_borrow_address(signer);
    call $MoveToRaw(ta, a#$Address(addr), v);
}

procedure {:inline 1} $MoveFrom(address: $Value, ta: $TypeValue) returns (dst: $Value)
free requires is#$Address(address);
{
    var a: int;
    var l: $Location;
    a := a#$Address(address);
    l := $Global(ta, a);
    if (!$ResourceExistsRaw($m, ta, a)) {
        $abort_flag := true;
        return;
    }
    dst := contents#$Memory($m)[l];
    $m := $Memory(domain#$Memory($m)[l := false], contents#$Memory($m)[l := $DefaultValue()]);
}

procedure {:inline 1} $BorrowGlobal(address: $Value, ta: $TypeValue) returns (dst: $Reference)
free requires is#$Address(address);
{
    var a: int;
    var l: $Location;
    a := a#$Address(address);
    l := $Global(ta, a);
    if (!$ResourceExistsRaw($m, ta, a)) {
        $abort_flag := true;
        return;
    }
    dst := $Reference(l, $EmptyPath, contents#$Memory($m)[l]);
}

procedure {:inline 1} $BorrowLoc(l: int, v: $Value) returns (dst: $Reference)
{
    dst := $Reference($Local(l), $EmptyPath, v);
}

procedure {:inline 1} $BorrowField(src: $Reference, f: $FieldName) returns (dst: $Reference)
{
    var p: $Path;
    var size: int;

    p := p#$Reference(src);
    size := size#$Path(p);
    p := $Path(p#$Path(p)[size := f], size+1);
    dst := $Reference(l#$Reference(src), p, $select_vector(v#$Reference(src), f)); //breaks abstraction
}

procedure {:inline 1} $GetGlobal(address: $Value, ta: $TypeValue) returns (dst: $Value)
free requires is#$Address(address);
{
    var r: $Reference;

    call r := $BorrowGlobal(address, ta);
    call dst := $ReadRef(r);
}

procedure {:inline 1} $GetFieldFromReference(src: $Reference, f: $FieldName) returns (dst: $Value)
{
    var r: $Reference;

    call r := $BorrowField(src, f);
    call dst := $ReadRef(r);
}

procedure {:inline 1} $GetFieldFromValue(src: $Value, f: $FieldName) returns (dst: $Value)
{
    dst := $select_vector(src, f); //breaks abstraction
}

procedure {:inline 1} $WriteRef(to: $Reference, new_v: $Value) returns (to': $Reference)
{
    to' := $Reference(l#$Reference(to), p#$Reference(to), new_v);
}

procedure {:inline 1} $ReadRef(from: $Reference) returns (v: $Value)
{
    v := v#$Reference(from);
}

procedure {:inline 1} $CopyOrMoveRef(local: $Reference) returns (dst: $Reference)
{
    dst := local;
}

procedure {:inline 1} $CopyOrMoveValue(local: $Value) returns (dst: $Value)
{
    dst := local;
}

procedure {:inline 1} $WritebackToGlobal(src: $Reference)
{
    var l: $Location;
    var v: $Value;

    l := l#$Reference(src);
    if (is#$Global(l)) {
        v := $UpdateValue(p#$Reference(src), 0, contents#$Memory($m)[l], v#$Reference(src));
        $m := $Memory(domain#$Memory($m), contents#$Memory($m)[l := v]);
    }
}

procedure {:inline 1} $WritebackToValue(src: $Reference, idx: int, vdst: $Value) returns (vdst': $Value)
{
    if (l#$Reference(src) == $Local(idx)) {
        vdst' := $UpdateValue(p#$Reference(src), 0, vdst, v#$Reference(src));
    } else {
        vdst' := vdst;
    }
}

procedure {:inline 1} $WritebackToReference(src: $Reference, dst: $Reference) returns (dst': $Reference)
{
    var srcPath, dstPath: $Path;

    srcPath := p#$Reference(src);
    dstPath := p#$Reference(dst);
    if (l#$Reference(dst) == l#$Reference(src) && size#$Path(dstPath) <= size#$Path(srcPath) && $IsPathPrefix(dstPath, srcPath)) {
        dst' := $Reference(
                    l#$Reference(dst),
                    dstPath,
                    $UpdateValue(srcPath, size#$Path(dstPath), v#$Reference(dst), v#$Reference(src)));
    } else {
        dst' := dst;
    }
}

procedure {:inline 1} $Splice1(idx1: int, src1: $Reference, dst: $Reference) returns (dst': $Reference) {
    dst' := $Reference(l#$Reference(src1), $ConcatPath(p#$Reference(src1), p#$Reference(dst)), v#$Reference(dst));
}

procedure {:inline 1} $CastU8(src: $Value) returns (dst: $Value)
free requires is#$Integer(src);
{
    if (i#$Integer(src) > $MAX_U8) {
        $abort_flag := true;
        return;
    }
    dst := src;
}

procedure {:inline 1} $CastU64(src: $Value) returns (dst: $Value)
free requires is#$Integer(src);
{
    if (i#$Integer(src) > $MAX_U64) {
        $abort_flag := true;
        return;
    }
    dst := src;
}

procedure {:inline 1} $CastU128(src: $Value) returns (dst: $Value)
free requires is#$Integer(src);
{
    if (i#$Integer(src) > $MAX_U128) {
        $abort_flag := true;
        return;
    }
    dst := src;
}

procedure {:inline 1} $AddU8(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU8(src1) && $IsValidU8(src2);
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U8) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU64(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU64(src1) && $IsValidU64(src2);
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U64) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU64_unchecked(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU64(src1) && $IsValidU64(src2);
{
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU128(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU128(src1) && $IsValidU128(src2);
{
    if (i#$Integer(src1) + i#$Integer(src2) > $MAX_U128) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $AddU128_unchecked(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU128(src1) && $IsValidU128(src2);
{
    dst := $Integer(i#$Integer(src1) + i#$Integer(src2));
}

procedure {:inline 1} $Sub(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    if (i#$Integer(src1) < i#$Integer(src2)) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) - i#$Integer(src2));
}

// This deals only with narrow special cases. Src2 must be constant
// 32 or 64, which is what we use now.  Obviously, it could be extended
// to src2 == any integer Value from 0..127.
// Left them out for brevity
function $power_of_2(power: $Value): int {
    (var p := i#$Integer(power);
     if p == 32 then 4294967296
     else if p == 64 then 18446744073709551616
     // Value is undefined, otherwise.
     else -1
     )
}

procedure {:inline 1} $Shl(src1: $Value, src2: $Value) returns (dst: $Value)
requires is#$Integer(src1) && is#$Integer(src2);
{
    var po2: int;
    po2 := $power_of_2(src2);
    assert po2 >= 1;   // po2 < 0 if src2 not 32 or 63
    dst := $Integer(i#$Integer(src2) * po2);
}

procedure {:inline 1} $Shr(src1: $Value, src2: $Value) returns (dst: $Value)
requires is#$Integer(src1) && is#$Integer(src2);
{
    var po2: int;
    po2 := $power_of_2(src2);
    assert po2 >= 1;   // po2 < 0 if src2 not 32 or 63
    dst := $Integer(i#$Integer(src2) div po2);
}

procedure {:inline 1} $MulU8(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU8(src1) && $IsValidU8(src2);
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U8) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}

procedure {:inline 1} $MulU64(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU64(src1) && $IsValidU64(src2);
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U64) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}

procedure {:inline 1} $MulU128(src1: $Value, src2: $Value) returns (dst: $Value)
free requires $IsValidU128(src1) && $IsValidU128(src2);
{
    if (i#$Integer(src1) * i#$Integer(src2) > $MAX_U128) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) * i#$Integer(src2));
}

procedure {:inline 1} $Div(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    if (i#$Integer(src2) == 0) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) div i#$Integer(src2));
}

procedure {:inline 1} $Mod(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    if (i#$Integer(src2) == 0) {
        $abort_flag := true;
        return;
    }
    dst := $Integer(i#$Integer(src1) mod i#$Integer(src2));
}

procedure {:inline 1} $ArithBinaryUnimplemented(src1: $Value, src2: $Value) returns (dst: $Value);
free requires is#$Integer(src1) && is#$Integer(src2);
ensures is#$Integer(dst);

procedure {:inline 1} $Lt(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) < i#$Integer(src2));
}

procedure {:inline 1} $Gt(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) > i#$Integer(src2));
}

procedure {:inline 1} $Le(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) <= i#$Integer(src2));
}

procedure {:inline 1} $Ge(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Integer(src1) && is#$Integer(src2);
{
    dst := $Boolean(i#$Integer(src1) >= i#$Integer(src2));
}

procedure {:inline 1} $And(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Boolean(src1) && is#$Boolean(src2);
{
    dst := $Boolean(b#$Boolean(src1) && b#$Boolean(src2));
}

procedure {:inline 1} $Or(src1: $Value, src2: $Value) returns (dst: $Value)
free requires is#$Boolean(src1) && is#$Boolean(src2);
{
    dst := $Boolean(b#$Boolean(src1) || b#$Boolean(src2));
}

procedure {:inline 1} $Not(src: $Value) returns (dst: $Value)
free requires is#$Boolean(src);
{
    dst := $Boolean(!b#$Boolean(src));
}

// Pack and Unpack are auto-generated for each type T


// Transaction
// -----------

type {:datatype} $Transaction;
var $txn: $Transaction;
function {:constructor} $Transaction(sender: int) : $Transaction;


// ==================================================================================
// Native Vector Type

function {:inline} $Vector_type_value(tv: $TypeValue): $TypeValue {
    $VectorType(tv)
}



// This is uses the implementation of $ValueArray using integer maps
function {:inline} $Vector_is_well_formed(v: $Value): bool {
    is#$Vector(v) &&
    (
        var va := v#$Vector(v);
        (
            var l := l#$ValueArray(va);
            0 <= l && l <= $MAX_U64 &&
            (forall x: int :: {v#$ValueArray(va)[x]} x < 0 || x >= l ==> v#$ValueArray(va)[x] == $DefaultValue())
        )
    )
}



procedure {:inline 1} $Vector_empty(ta: $TypeValue) returns (v: $Value) {
    v := $mk_vector();
}

procedure {:inline 1} $Vector_is_empty(ta: $TypeValue, v: $Value) returns (b: $Value) {
    assume is#$Vector(v);
    b := $Boolean($vlen(v) == 0);
}

procedure {:inline 1} $Vector_push_back(ta: $TypeValue, v: $Value, val: $Value) returns (v': $Value) {
    assume is#$Vector(v);
    v' := $push_back_vector(v, val);
}

procedure {:inline 1} $Vector_pop_back(ta: $TypeValue, v: $Value) returns (e: $Value, v': $Value) {
    var len: int;
    assume is#$Vector(v);
    len := $vlen(v);
    if (len == 0) {
        $abort_flag := true;
        return;
    }
    e := $select_vector(v, len-1);
    v' := $pop_back_vector(v);
}

procedure {:inline 1} $Vector_append(ta: $TypeValue, v: $Value, other: $Value) returns (v': $Value) {
    assume is#$Vector(v);
    assume is#$Vector(other);
    v' := $append_vector(v, other);
}

procedure {:inline 1} $Vector_reverse(ta: $TypeValue, v: $Value) returns (v': $Value) {
    assume is#$Vector(v);
    v' := $reverse_vector(v);
}

procedure {:inline 1} $Vector_length(ta: $TypeValue, v: $Value) returns (l: $Value) {
    assume is#$Vector(v);
    l := $Integer($vlen(v));
}

procedure {:inline 1} $Vector_borrow(ta: $TypeValue, src: $Value, i: $Value) returns (dst: $Value) {
    var i_ind: int;

    assume is#$Vector(src);
    assume is#$Integer(i);
    i_ind := i#$Integer(i);
    if (i_ind < 0 || i_ind >= $vlen(src)) {
        $abort_flag := true;
        return;
    }
    dst := $select_vector(src, i_ind);
}

procedure {:inline 1} $Vector_borrow_mut(ta: $TypeValue, v: $Value, index: $Value) returns (dst: $Reference, v': $Value)
free requires is#$Integer(index);
{
    var i_ind: int;

    i_ind := i#$Integer(index);
    assume is#$Vector(v);
    if (i_ind < 0 || i_ind >= $vlen(v)) {
        $abort_flag := true;
        return;
    }
    dst := $Reference($Local(0), $Path(p#$Path($EmptyPath)[0 := i_ind], 1), $select_vector(v, i_ind));
    v' := v;
}

procedure {:inline 1} $Vector_destroy_empty(ta: $TypeValue, v: $Value) {
    if ($vlen(v) != 0) {
      $abort_flag := true;
    }
}

procedure {:inline 1} $Vector_swap(ta: $TypeValue, v: $Value, i: $Value, j: $Value) returns (v': $Value)
free requires is#$Integer(i) && is#$Integer(j);
{
    var i_ind: int;
    var j_ind: int;
    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    j_ind := i#$Integer(j);
    if (i_ind >= $vlen(v) || j_ind >= $vlen(v) || i_ind < 0 || j_ind < 0) {
        $abort_flag := true;
        return;
    }
    v' := $swap_vector(v, i_ind, j_ind);
}

procedure {:inline 1} $Vector_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value)
free requires is#$Integer(i);
{
    var i_ind: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    if (i_ind < 0 || i_ind >= $vlen(v)) {
        $abort_flag := true;
        return;
    }
    e := $select_vector(v, i_ind);
    v' := $remove_vector(v, i_ind);
}

procedure {:inline 1} $Vector_swap_remove(ta: $TypeValue, v: $Value, i: $Value) returns (e: $Value, v': $Value)
free requires is#$Integer(i);
{
    var i_ind: int;
    var len: int;

    assume is#$Vector(v);
    i_ind := i#$Integer(i);
    len := $vlen(v);
    if (i_ind < 0 || i_ind >= len) {
        $abort_flag := true;
        return;
    }
    e := $select_vector(v, i_ind);
    v' := $pop_back_vector($swap_vector(v, i_ind, len-1));
}

procedure {:inline 1} $Vector_contains(ta: $TypeValue, v: $Value, e: $Value) returns (res: $Value)  {
    assume is#$Vector(v);
    res := $Boolean($contains_vector(v, e));
}

// FIXME: This procedure sometimes (not always) make the test (performance_200511) very slow (> 10 mins) or hang
// although this is not used in the test script (performance_200511). The test finishes in 20 secs when it works fine.
procedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: $Value, e: $Value) returns (res1: $Value, res2: $Value);
requires is#$Vector(v);
ensures is#$Boolean(res1);
ensures is#$Integer(res2);
ensures 0 <= i#$Integer(res2) && i#$Integer(res2) < $vlen(v);
ensures res1 == $Boolean($contains_vector(v, e));
ensures b#$Boolean(res1) ==> $IsEqual($select_vector(v,i#$Integer(res2)), e);
ensures b#$Boolean(res1) ==> (forall i:int :: 0<=i && i<i#$Integer(res2) ==> !$IsEqual($select_vector(v,i), e));
ensures !b#$Boolean(res1) ==> i#$Integer(res2) == 0;

// FIXME: This alternative definition has the same issue as the other one above.
// TODO: Delete this when unnecessary
//procedure {:inline 1} $Vector_index_of(ta: $TypeValue, v: $Value, e: $Value) returns (res1: $Value, res2: $Value) {
//    var b: bool;
//    var i: int;
//    assume is#$Vector(v);
//    b := $contains_vector(v, e);
//    if (b) {
//        havoc i;
//        assume 0 <= i && i < $vlen(v);
//        assume $IsEqual($select_vector(v,i), e);
//        assume (forall j:int :: 0<=j && j<i ==> !$IsEqual($select_vector(v,j), e));
//    }
//    else {
//        i := 0;
//    }
//    res1 := $Boolean(b);
//    res2 := $Integer(i);
//}

// ==================================================================================
// Native hash

// Hash is modeled as an otherwise uninterpreted injection.
// In truth, it is not an injection since the domain has greater cardinality
// (arbitrary length vectors) than the co-domain (vectors of length 32).  But it is
// common to assume in code there are no hash collisions in practice.  Fortunately,
// Boogie is not smart enough to recognized that there is an inconsistency.
// FIXME: If we were using a reliable extensional theory of arrays, and if we could use ==
// instead of $IsEqual, we might be able to avoid so many quantified formulas by
// using a sha2_inverse function in the ensures conditions of Hash_sha2_256 to
// assert that sha2/3 are injections without using global quantified axioms.


function {:inline} $Hash_sha2($m: $Memory, $txn: $Transaction, val: $Value): $Value {
    $Hash_sha2_core(val)
}

function $Hash_sha2_core(val: $Value): $Value;

// This says that Hash_sha2 respects isEquals (this would be automatic if we had an
// extensional theory of arrays and used ==, which has the substitution property
// for functions).
axiom (forall v1,v2: $Value :: $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2)
       && $IsEqual(v1, v2) ==> $IsEqual($Hash_sha2_core(v1), $Hash_sha2_core(v2)));

// This says that Hash_sha2 is an injection
axiom (forall v1,v2: $Value :: $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2)
        && $IsEqual($Hash_sha2_core(v1), $Hash_sha2_core(v2)) ==> $IsEqual(v1, v2));

// This procedure has no body. We want Boogie to just use its requires
// and ensures properties when verifying code that calls it.
procedure $Hash_sha2_256(val: $Value) returns (res: $Value);
// It will still work without this, but this helps verifier find more reasonable counterexamples.
free requires $IsValidU8Vector(val);
ensures res == $Hash_sha2_core(val);     // returns Hash_sha2 Value
ensures $IsValidU8Vector(res);    // result is a legal vector of U8s.
ensures $vlen(res) == 32;               // result is 32 bytes.

// similarly for Hash_sha3
function {:inline} $Hash_sha3($m: $Memory, $txn: $Transaction, val: $Value): $Value {
    $Hash_sha3_core(val)
}
function $Hash_sha3_core(val: $Value): $Value;

axiom (forall v1,v2: $Value :: $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2)
       && $IsEqual(v1, v2) ==> $IsEqual($Hash_sha3_core(v1), $Hash_sha3_core(v2)));

axiom (forall v1,v2: $Value :: $Vector_is_well_formed(v1) && $Vector_is_well_formed(v2)
        && $IsEqual($Hash_sha3_core(v1), $Hash_sha3_core(v2)) ==> $IsEqual(v1, v2));

procedure $Hash_sha3_256(val: $Value) returns (res: $Value);
ensures res == $Hash_sha3_core(val);     // returns Hash_sha3 Value
ensures $IsValidU8Vector(res);    // result is a legal vector of U8s.
ensures $vlen(res) == 32;               // result is 32 bytes.

// ==================================================================================
// Native libra_account

// TODO: this function clashes with a similar version in older libraries. This is solved by a hack where the
// translator appends _OLD to the name when encountering this. The hack shall be removed once old library
// sources are not longer used.
procedure {:inline 1} $LibraAccount_save_account_OLD(ta: $TypeValue, balance: $Value, account: $Value, addr: $Value) {
    var a: int;
    var t_T: $TypeValue;
    var l_T: $Location;
    var t_Balance: $TypeValue;
    var l_Balance: $Location;

    a := a#$Address(addr);
    t_T := $LibraAccount_T_type_value();
    if ($ResourceExistsRaw($m, t_T, a)) {
        $abort_flag := true;
        return;
    }

    t_Balance := $LibraAccount_Balance_type_value(ta);
    if ($ResourceExistsRaw($m, t_Balance, a)) {
        $abort_flag := true;
        return;
    }

    l_T := $Global(t_T, a);
    l_Balance := $Global(t_Balance, a);
    $m := $Memory(domain#$Memory($m)[l_T := true][l_Balance := true], contents#$Memory($m)[l_T := account][l_Balance := balance]);
}

procedure {:inline 1} $LibraAccount_save_account(
       t_Token: $TypeValue, t_AT: $TypeValue, account_type: $Value, balance: $Value,
       account: $Value, event_generator: $Value, addr: $Value) {
    // TODO: implement this
    assert false;
}

procedure {:inline 1} $LibraAccount_create_signer(
  addr: $Value
) returns (signer: $Value) {
    // A signer is currently identical to an address.
    signer := addr;
}

procedure {:inline 1} $LibraAccount_destroy_signer(
  signer: $Value
) {
  return;
}

procedure {:inline 1} $LibraAccount_write_to_event_store(ta: $TypeValue, guid: $Value, count: $Value, msg: $Value) {
    // TODO: this is used in old library sources, remove it once those sources are not longer used in tests.
    // This function is modeled as a no-op because the actual side effect of this native function is not observable from the Move side.
}

procedure {:inline 1} $Event_write_to_event_store(ta: $TypeValue, guid: $Value, count: $Value, msg: $Value) {
    // This function is modeled as a no-op because the actual side effect of this native function is not observable from the Move side.
}

// ==================================================================================
// Native Signer

procedure {:inline 1} $Signer_borrow_address(signer: $Value) returns (res: $Value)
    free requires is#$Address(signer);
{
    res := signer;
}

// ==================================================================================
// Native signature

// Signature related functionality is handled via uninterpreted functions. This is sound
// currently because we verify every code path based on signature verification with
// an arbitrary interpretation.

function $Signature_spec_ed25519_validate_pubkey($m: $Memory, $txn: $Transaction, public_key: $Value): $Value;
function $Signature_spec_ed25519_verify($m: $Memory, $txn: $Transaction,
                                        signature: $Value, public_key: $Value, message: $Value): $Value;

axiom (forall $m: $Memory, $txn: $Transaction, public_key: $Value ::
        is#$Boolean($Signature_spec_ed25519_validate_pubkey($m, $txn, public_key)));

axiom (forall $m: $Memory, $txn: $Transaction, signature, public_key, message: $Value ::
        is#$Boolean($Signature_spec_ed25519_verify($m, $txn, signature, public_key, message)));


procedure {:inline 1} $Signature_ed25519_validate_pubkey(public_key: $Value) returns (res: $Value) {
    res := $Signature_spec_ed25519_validate_pubkey($m, $txn, public_key);
}

procedure {:inline 1} $Signature_ed25519_verify(
        signature: $Value, public_key: $Value, message: $Value) returns (res: $Value) {
    res := $Signature_spec_ed25519_verify($m, $txn, signature, public_key, message);
}

// ==================================================================================
// Native LCS::serialize

// native define serialize<MoveValue>(v: &MoveValue): vector<u8>;

// Serialize is modeled as an uninterpreted function, with an additional
// axiom to say it's an injection.

function {:inline} $LCS_serialize($m: $Memory, $txn: $Transaction, ta: $TypeValue, v: $Value): $Value {
    $LCS_serialize_core(v)
}

function $LCS_serialize_core(v: $Value): $Value;
function $LCS_serialize_core_inv(v: $Value): $Value;
// Needed only because IsEqual(v1, v2) is weaker than v1 == v2 in case there is a vector nested inside v1 or v2.
axiom (forall v1, v2: $Value :: $IsEqual(v1, v2) ==> $LCS_serialize_core(v1) == $LCS_serialize_core(v2));
// Injectivity
axiom (forall v: $Value :: $LCS_serialize_core_inv($LCS_serialize_core(v)) == v);

// This says that serialize returns a non-empty vec<u8>

axiom (forall v: $Value :: ( var r := $LCS_serialize_core(v); $IsValidU8Vector(r) && $vlen(r) > 0 &&
                            $vlen(r) <= 4 ));


// Serialized addresses should have the same length
const $serialized_address_len: int;
axiom (forall v: $Value :: (var r := $LCS_serialize_core(v); is#$Address(v) ==> $vlen(r) == $serialized_address_len));

procedure $LCS_to_bytes(ta: $TypeValue, v: $Value) returns (res: $Value);
ensures res == $LCS_serialize($m, $txn, ta, v);
ensures $IsValidU8Vector(res);    // result is a legal vector of U8s.

// ==================================================================================
// Native Signer::spec_address_of

function {:inline} $Signer_spec_address_of($m: $Memory, $txn: $Transaction, signer: $Value): $Value
{
    // A signer is currently identical to an address.
    signer
}

// ==================================================================================
// Mocked out Event module

procedure {:inline 1} $Event_new_event_handle(t: $TypeValue, signer: $Value) returns (res: $Value) {
}

procedure {:inline 1} $Event_publish_generator(account: $Value) {
}

procedure {:inline 1} $Event_emit_event(t: $TypeValue, handler: $Value, msg: $Value) returns (res: $Value) {
    res := handler;
}



// ** spec vars of module Signer



// ** spec funs of module Signer



// ** structs of module Signer



// ** functions of module Signer

procedure {:inline 1} $Signer_address_of_def(s: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(23, 407, 0, s); }

    // bytecode translation starts here
    // $t4 := move(s)
    call $tmp := $CopyOrMoveValue(s);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := Signer::borrow_address($t1)
    call $t2 := $Signer_borrow_address($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(23, 324);
      goto Abort;
    }
    assume is#$Address($t2);


    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(23, 460, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Signer_address_of(s: $Value) returns ($ret0: $Value)
free requires is#$Address(s);
{
    call $ret0 := $Signer_address_of_def(s);
}



// ** spec vars of module CoreAddresses



// ** spec funs of module CoreAddresses

function {:inline} $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS(): $Value {
    $Address(173345816)
}

function {:inline} $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS(): $Value {
    $Address(173345816)
}

function {:inline} $CoreAddresses_SPEC_TREASURY_COMPLIANCE_ADDRESS(): $Value {
    $Address(186537453)
}

function {:inline} $CoreAddresses_SPEC_VM_RESERVED_ADDRESS(): $Value {
    $Address(0)
}



// ** structs of module CoreAddresses



// ** functions of module CoreAddresses

procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0xa550c18
    $tmp := $Address(173345816);
    $t0 := $tmp;

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(5, 890, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $CoreAddresses_CURRENCY_INFO_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_CURRENCY_INFO_ADDRESS_def();
}

procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0xa550c18
    $tmp := $Address(173345816);
    $t0 := $tmp;

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(5, 330, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $CoreAddresses_LIBRA_ROOT_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_LIBRA_ROOT_ADDRESS_def();
}

procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0xb1e55ed
    $tmp := $Address(186537453);
    $t0 := $tmp;

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(5, 1358, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS_def();
}

procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 0x0
    $tmp := $Address(0);
    $t0 := $tmp;

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(5, 1894, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $CoreAddresses_VM_RESERVED_ADDRESS() returns ($ret0: $Value)
{
    call $ret0 := $CoreAddresses_VM_RESERVED_ADDRESS_def();
}



// ** spec vars of module LibraTimestamp



// ** spec funs of module LibraTimestamp

function {:inline} $LibraTimestamp_spec_is_genesis($m: $Memory, $txn: $Transaction): $Value {
    $Boolean(!b#$Boolean($ResourceExists($m, $LibraTimestamp_TimeHasStarted_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))
}

function {:inline} $LibraTimestamp_spec_is_not_initialized($m: $Memory, $txn: $Transaction): $Value {
    $Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))) || b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($m, $txn), $Integer(0)))))
}

function {:inline} $LibraTimestamp_root_ctm_initialized($m: $Memory, $txn: $Transaction): $Value {
    $ResourceExists($m, $LibraTimestamp_CurrentTimeMicroseconds_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraTimestamp_spec_now_microseconds($m: $Memory, $txn: $Transaction): $Value {
    $SelectField($ResourceValue($m, $LibraTimestamp_CurrentTimeMicroseconds_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()), $LibraTimestamp_CurrentTimeMicroseconds_microseconds)
}



// ** structs of module LibraTimestamp

const unique $LibraTimestamp_CurrentTimeMicroseconds: $TypeName;
const $LibraTimestamp_CurrentTimeMicroseconds_microseconds: $FieldName;
axiom $LibraTimestamp_CurrentTimeMicroseconds_microseconds == 0;
function $LibraTimestamp_CurrentTimeMicroseconds_type_value(): $TypeValue {
    $StructType($LibraTimestamp_CurrentTimeMicroseconds, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraTimestamp_CurrentTimeMicroseconds_microseconds))
}
function {:inline} $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraTimestamp_CurrentTimeMicroseconds_microseconds))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed($ResourceValue(m, $LibraTimestamp_CurrentTimeMicroseconds_type_value(), a))
);

procedure {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_pack($file_id: int, $byte_index: int, $var_idx: int, microseconds: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(microseconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := microseconds], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraTimestamp_CurrentTimeMicroseconds_unpack($struct: $Value) returns (microseconds: $Value)
{
    assume is#$Vector($struct);
    microseconds := $SelectField($struct, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64(microseconds);
}

const unique $LibraTimestamp_TimeHasStarted: $TypeName;
const $LibraTimestamp_TimeHasStarted_dummy_field: $FieldName;
axiom $LibraTimestamp_TimeHasStarted_dummy_field == 0;
function $LibraTimestamp_TimeHasStarted_type_value(): $TypeValue {
    $StructType($LibraTimestamp_TimeHasStarted, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $LibraTimestamp_TimeHasStarted_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraTimestamp_TimeHasStarted_dummy_field))
}
function {:inline} $LibraTimestamp_TimeHasStarted_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraTimestamp_TimeHasStarted_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraTimestamp_TimeHasStarted_is_well_formed($ResourceValue(m, $LibraTimestamp_TimeHasStarted_type_value(), a))
);

procedure {:inline 1} $LibraTimestamp_TimeHasStarted_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraTimestamp_TimeHasStarted_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraTimestamp_TimeHasStarted_dummy_field);
    assume is#$Boolean(dummy_field);
}



// ** functions of module LibraTimestamp

procedure {:inline 1} $LibraTimestamp_initialize_def(association: $Value) returns (){
    // declare local variables
    var timer: $Value; // $LibraTimestamp_CurrentTimeMicroseconds_type_value()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $LibraTimestamp_CurrentTimeMicroseconds_type_value()
    var $t14: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 1223, 0, association); }

    // bytecode translation starts here
    // $t14 := move(association)
    call $tmp := $CopyOrMoveValue(association);
    $t14 := $tmp;

    // $t4 := copy($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;

    // $t5 := Signer::address_of($t4)
    call $t5 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 1368);
      goto Abort;
    }
    assume is#$Address($t5);


    // $t6 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 1410);
      goto Abort;
    }
    assume is#$Address($t6);


    // $t7 := ==($t5, $t6)
    $tmp := $Boolean($IsEqual($t5, $t6));
    $t7 := $tmp;

    // $t2 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 1353, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 0
    $tmp := $Integer(0);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(16, 1353); }
    goto Abort;

    // L0:
L0:

    // $t11 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t11 := $tmp;

    // $t12 := 0
    $tmp := $Integer(0);
    $t12 := $tmp;

    // $t13 := pack LibraTimestamp::CurrentTimeMicroseconds($t12)
    call $tmp := $LibraTimestamp_CurrentTimeMicroseconds_pack(0, 0, 0, $t12);
    $t13 := $tmp;

    // move_to<LibraTimestamp::CurrentTimeMicroseconds>($t13, $t11)
    call $MoveTo($LibraTimestamp_CurrentTimeMicroseconds_type_value(), $t13, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 1606);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraTimestamp_initialize(association: $Value) returns ()
free requires is#$Address(association);
free ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, association), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
free ensures b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, association), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old(($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($m, $txn), $Integer(0)))));
{
    call $LibraTimestamp_initialize_def(association);
}

procedure {:inline 1} $LibraTimestamp_is_genesis_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3978);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := exists<LibraTimestamp::TimeHasStarted>($t0)
    call $tmp := $Exists($t0, $LibraTimestamp_TimeHasStarted_type_value());
    $t1 := $tmp;

    // $t2 := !($t1)
    call $tmp := $Not($t1);
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(16, 3939, 3, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraTimestamp_is_genesis() returns ($ret0: $Value)
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_is_genesis($m, $txn)))));
{
    call $ret0 := $LibraTimestamp_is_genesis_def();
}

procedure {:inline 1} $LibraTimestamp_is_not_initialized_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $BooleanType()
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t1 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 4222);
      goto Abort;
    }
    assume is#$Address($t1);


    // $t2 := exists<LibraTimestamp::CurrentTimeMicroseconds>($t1)
    call $tmp := $Exists($t1, $LibraTimestamp_CurrentTimeMicroseconds_type_value());
    $t2 := $tmp;

    // $t3 := !($t2)
    call $tmp := $Not($t2);
    $t3 := $tmp;

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t4 := true
    $tmp := $Boolean(true);
    $t4 := $tmp;

    // $t0 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 4174, 0, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t5 := LibraTimestamp::now_microseconds()
    call $t5 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3656);
      goto Abort;
    }
    assume $IsValidU64($t5);


    // $t6 := 0
    $tmp := $Integer(0);
    $t6 := $tmp;

    // $t7 := ==($t5, $t6)
    $tmp := $Boolean($IsEqual($t5, $t6));
    $t7 := $tmp;

    // $t0 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 4174, 0, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(16, 4174, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraTimestamp_is_not_initialized() returns ($ret0: $Value)
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_is_not_initialized($m, $txn)))));
{
    call $ret0 := $LibraTimestamp_is_not_initialized_def();
}

procedure {:inline 1} $LibraTimestamp_now_microseconds_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $LibraTimestamp_CurrentTimeMicroseconds_type_value()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3777);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<LibraTimestamp::CurrentTimeMicroseconds>($t0)
    call $tmp := $GetGlobal($t0, $LibraTimestamp_CurrentTimeMicroseconds_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3723);
      goto Abort;
    }
    assume $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds($t1)
    call $tmp := $GetFieldFromValue($t1, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(16, 3723, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraTimestamp_now_microseconds() returns ($ret0: $Value)
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $LibraTimestamp_CurrentTimeMicroseconds_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $LibraTimestamp_CurrentTimeMicroseconds_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraTimestamp_spec_now_microseconds($m, $txn)))));
{
    call $ret0 := $LibraTimestamp_now_microseconds_def();
}

procedure {:inline 1} $LibraTimestamp_reset_time_has_started_for_test_def() returns (){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $LibraTimestamp_TimeHasStarted_type_value()
    var $t2: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t0 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 2592);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := move_from<LibraTimestamp::TimeHasStarted>($t0)
    call $tmp := $MoveFrom($t0, $LibraTimestamp_TimeHasStarted_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 2551);
      goto Abort;
    }
    assume $LibraTimestamp_TimeHasStarted_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := unpack LibraTimestamp::TimeHasStarted($t1)
    call $t2 := $LibraTimestamp_TimeHasStarted_unpack($t1);
    $t2 := $t2;

    // destroy($t2)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraTimestamp_reset_time_has_started_for_test() returns ()
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
{
    call $LibraTimestamp_reset_time_has_started_for_test_def();
}

procedure {:inline 1} $LibraTimestamp_set_time_has_started_def(association: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $LibraTimestamp_TimeHasStarted_type_value()
    var $t26: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 1746, 0, association); }

    // bytecode translation starts here
    // $t26 := move(association)
    call $tmp := $CopyOrMoveValue(association);
    $t26 := $tmp;

    // $t6 := copy($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t6 := $tmp;

    // $t7 := Signer::address_of($t6)
    call $t7 := $Signer_address_of($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 1858);
      goto Abort;
    }
    assume is#$Address($t7);


    // $t8 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t8 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 1900);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := ==($t7, $t8)
    $tmp := $Boolean($IsEqual($t7, $t8));
    $t9 := $tmp;

    // $t1 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 1843, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t11 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t11 := $tmp;

    // destroy($t11)

    // $t12 := 0
    $tmp := $Integer(0);
    $t12 := $tmp;

    // abort($t12)
    if (true) { assume $DebugTrackAbort(16, 1843); }
    goto Abort;

    // L0:
L0:

    // $t13 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 2079);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := exists<LibraTimestamp::CurrentTimeMicroseconds>($t13)
    call $tmp := $Exists($t13, $LibraTimestamp_CurrentTimeMicroseconds_type_value());
    $t14 := $tmp;

    // if ($t14) goto L2 else goto L3
    $tmp := $t14;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t15 := LibraTimestamp::now_microseconds()
    call $t15 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3656);
      goto Abort;
    }
    assume $IsValidU64($t15);


    // $t16 := 0
    $tmp := $Integer(0);
    $t16 := $tmp;

    // $t17 := ==($t15, $t16)
    $tmp := $Boolean($IsEqual($t15, $t16));
    $t17 := $tmp;

    // $t5 := $t17
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 2032, 5, $tmp); }

    // goto L5
    goto L5;

    // L4:
L4:

    // $t18 := false
    $tmp := $Boolean(false);
    $t18 := $tmp;

    // $t5 := $t18
    call $tmp := $CopyOrMoveValue($t18);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 2032, 5, $tmp); }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t3 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 2012, 3, $tmp); }

    // if ($t3) goto L6 else goto L7
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // $t21 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t21 := $tmp;

    // destroy($t21)

    // $t22 := 1
    $tmp := $Integer(1);
    $t22 := $tmp;

    // abort($t22)
    if (true) { assume $DebugTrackAbort(16, 2012); }
    goto Abort;

    // L6:
L6:

    // $t23 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t23 := $tmp;

    // $t24 := false
    $tmp := $Boolean(false);
    $t24 := $tmp;

    // $t25 := pack LibraTimestamp::TimeHasStarted($t24)
    call $tmp := $LibraTimestamp_TimeHasStarted_pack(0, 0, 0, $t24);
    $t25 := $tmp;

    // move_to<LibraTimestamp::TimeHasStarted>($t25, $t23)
    call $MoveTo($LibraTimestamp_TimeHasStarted_type_value(), $t25, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 2182);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraTimestamp_set_time_has_started(association: $Value) returns ()
free requires is#$Address(association);
free ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, association), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!$IsEqual($LibraTimestamp_spec_now_microseconds($m, $txn), $Integer(0))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, association), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn))))))
    || b#$Boolean(old(($Boolean(!$IsEqual($LibraTimestamp_spec_now_microseconds($m, $txn), $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))));
{
    call $LibraTimestamp_set_time_has_started_def(association);
}

procedure {:inline 1} $LibraTimestamp_update_global_time_def(account: $Value, proposer: $Value, timestamp: $Value) returns (){
    // declare local variables
    var global_timer: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t28: $Value; // $IntegerType()
    var $t29: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $BooleanType()
    var $t35: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Reference; // ReferenceType($LibraTimestamp_CurrentTimeMicroseconds_type_value())
    var $t39: $Reference; // ReferenceType($IntegerType())
    var $t40: $Value; // $AddressType()
    var $t41: $Value; // $AddressType()
    var $t42: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(16, 2741, 0, account); }
    if (true) { assume $DebugTrackLocal(16, 2741, 1, proposer); }
    if (true) { assume $DebugTrackLocal(16, 2741, 2, timestamp); }

    // bytecode translation starts here
    // $t40 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t40 := $tmp;

    // $t41 := move(proposer)
    call $tmp := $CopyOrMoveValue(proposer);
    $t41 := $tmp;

    // $t42 := move(timestamp)
    call $tmp := $CopyOrMoveValue(timestamp);
    $t42 := $tmp;

    // $t10 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 2965);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t12 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3003);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t4 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 2950, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := 2
    $tmp := $Integer(2);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(16, 2950); }
    goto Abort;

    // L0:
L0:

    // $t16 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t16 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3122);
      goto Abort;
    }
    assume is#$Address($t16);


    // $t17 := borrow_global<LibraTimestamp::CurrentTimeMicroseconds>($t16)
    call $t17 := $BorrowGlobal($t16, $LibraTimestamp_CurrentTimeMicroseconds_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3064);
      goto Abort;
    }
    assume $LibraTimestamp_CurrentTimeMicroseconds_is_well_formed($Dereference($t17));

    // UnpackRef($t17)

    // global_timer := $t17
    call global_timer := $CopyOrMoveRef($t17);
    if (true) { assume $DebugTrackLocal(16, 3049, 3, $Dereference(global_timer)); }

    // $t19 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t19 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(16, 3184);
      goto Abort;
    }
    assume is#$Address($t19);


    // $t20 := ==($t41, $t19)
    $tmp := $Boolean($IsEqual($t41, $t19));
    $t20 := $tmp;

    // if ($t20) goto L2 else goto L3
    $tmp := $t20;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t22 := copy(global_timer)
    call $t22 := $CopyOrMoveRef(global_timer);

    // $t23 := get_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds($t22)
    call $tmp := $GetFieldFromReference($t22, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64($tmp);
    $t23 := $tmp;

    // Reference(global_timer) <- $t22
    call global_timer := $WritebackToReference($t22, global_timer);

    // $t24 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;

    // $t25 := ==($t42, $t24)
    $tmp := $Boolean($IsEqual($t42, $t24));
    $t25 := $tmp;

    // $t6 := $t25
    call $tmp := $CopyOrMoveValue($t25);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 3302, 6, $tmp); }

    // if ($t6) goto L5 else goto L6
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // $t27 := move(global_timer)
    call $t27 := $CopyOrMoveRef(global_timer);

    // destroy($t27)

    // LibraTimestamp::CurrentTimeMicroseconds <- $t27
    call $WritebackToGlobal($t27);

    // PackRef($t27)

    // $t28 := 3
    $tmp := $Integer(3);
    $t28 := $tmp;

    // abort($t28)
    if (true) { assume $DebugTrackAbort(16, 3302); }
    goto Abort;

    // L5:
L5:

    // goto L7
    goto L7;

    // L4:
L4:

    // $t29 := copy(global_timer)
    call $t29 := $CopyOrMoveRef(global_timer);

    // $t30 := get_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds($t29)
    call $tmp := $GetFieldFromReference($t29, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64($tmp);
    $t30 := $tmp;

    // Reference(global_timer) <- $t29
    call global_timer := $WritebackToReference($t29, global_timer);

    // $t31 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t31 := $tmp;

    // $t33 := <($t31, $t42)
    call $tmp := $Lt($t31, $t42);
    $t33 := $tmp;

    // $t8 := $t33
    call $tmp := $CopyOrMoveValue($t33);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(16, 3446, 8, $tmp); }

    // if ($t8) goto L7 else goto L8
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // $t35 := move(global_timer)
    call $t35 := $CopyOrMoveRef(global_timer);

    // destroy($t35)

    // LibraTimestamp::CurrentTimeMicroseconds <- $t35
    call $WritebackToGlobal($t35);

    // PackRef($t35)

    // $t36 := 3
    $tmp := $Integer(3);
    $t36 := $tmp;

    // abort($t36)
    if (true) { assume $DebugTrackAbort(16, 3446); }
    goto Abort;

    // L7:
L7:

    // $t38 := move(global_timer)
    call $t38 := $CopyOrMoveRef(global_timer);

    // $t39 := borrow_field<LibraTimestamp::CurrentTimeMicroseconds>.microseconds($t38)
    call $t39 := $BorrowField($t38, $LibraTimestamp_CurrentTimeMicroseconds_microseconds);
    assume $IsValidU64($Dereference($t39));

    // LibraTimestamp::CurrentTimeMicroseconds <- $t38
    call $WritebackToGlobal($t38);

    // UnpackRef($t39)

    // write_ref($t39, $t42)
    call $t39 := $WriteRef($t39, $t42);
    if (true) { assume $DebugTrackLocal(16, 3532, 3, $Dereference(global_timer)); }

    // LibraTimestamp::CurrentTimeMicroseconds <- $t39
    call $WritebackToGlobal($t39);

    // Reference($t38) <- $t39
    call $t38 := $WritebackToReference($t39, $t38);

    // PackRef($t38)

    // PackRef($t39)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraTimestamp_update_global_time(account: $Value, proposer: $Value, timestamp: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(proposer);
free requires $IsValidU64(timestamp);
free ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, account), $CoreAddresses_SPEC_VM_RESERVED_ADDRESS())))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!$IsEqual(timestamp, $LibraTimestamp_spec_now_microseconds($m, $txn))))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(b#$Boolean($Boolean(!$IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!b#$Boolean($Boolean(i#$Integer(timestamp) > i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn))))))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, account), $CoreAddresses_SPEC_VM_RESERVED_ADDRESS())))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn))))))
    || b#$Boolean(old(($Boolean(b#$Boolean($Boolean($IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!$IsEqual(timestamp, $LibraTimestamp_spec_now_microseconds($m, $txn))))))))
    || b#$Boolean(old(($Boolean(b#$Boolean($Boolean(!$IsEqual(proposer, $CoreAddresses_SPEC_VM_RESERVED_ADDRESS()))) && b#$Boolean($Boolean(!b#$Boolean($Boolean(i#$Integer(timestamp) > i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($LibraTimestamp_root_ctm_initialized($m, $txn))) ==> b#$Boolean($Boolean(i#$Integer(old($LibraTimestamp_spec_now_microseconds($m, $txn))) <= i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($LibraTimestamp_spec_now_microseconds($m, $txn), timestamp))));
{
    call $LibraTimestamp_update_global_time_def(account, proposer, timestamp);
}



// ** spec vars of module Roles



// ** spec funs of module Roles

function {:inline} $Roles_spec_get_role_id($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    (var addr := $Signer_spec_address_of($m, $txn, account); $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))
}

function {:inline} $Roles_spec_has_role_id($m: $Memory, $txn: $Transaction, account: $Value, role_id: $Value): $Value {
    (var addr := $Signer_spec_address_of($m, $txn, account); $Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id), role_id)))))
}

function {:inline} $Roles_SPEC_LIBRA_ROOT_ROLE_ID(): $Value {
    $Integer(0)
}

function {:inline} $Roles_SPEC_TREASURY_COMPLIANCE_ROLE_ID(): $Value {
    $Integer(1)
}

function {:inline} $Roles_SPEC_DESIGNATED_DEALER_ROLE_ID(): $Value {
    $Integer(2)
}

function {:inline} $Roles_SPEC_VALIDATOR_ROLE_ID(): $Value {
    $Integer(3)
}

function {:inline} $Roles_SPEC_VALIDATOR_OPERATOR_ROLE_ID(): $Value {
    $Integer(4)
}

function {:inline} $Roles_SPEC_PARENT_VASP_ROLE_ID(): $Value {
    $Integer(5)
}

function {:inline} $Roles_SPEC_CHILD_VASP_ROLE_ID(): $Value {
    $Integer(6)
}

function {:inline} $Roles_SPEC_UNHOSTED_ROLE_ID(): $Value {
    $Integer(7)
}

function {:inline} $Roles_spec_has_libra_root_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_LIBRA_ROOT_ROLE_ID())
}

function {:inline} $Roles_spec_has_treasury_compliance_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_TREASURY_COMPLIANCE_ROLE_ID())
}

function {:inline} $Roles_spec_has_designated_dealer_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_DESIGNATED_DEALER_ROLE_ID())
}

function {:inline} $Roles_spec_has_validator_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_VALIDATOR_ROLE_ID())
}

function {:inline} $Roles_spec_has_validator_operator_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_VALIDATOR_OPERATOR_ROLE_ID())
}

function {:inline} $Roles_spec_has_parent_VASP_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_PARENT_VASP_ROLE_ID())
}

function {:inline} $Roles_spec_has_child_VASP_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_CHILD_VASP_ROLE_ID())
}

function {:inline} $Roles_spec_has_unhosted_role($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_role_id($m, $txn, account, $Roles_SPEC_UNHOSTED_ROLE_ID())
}

function {:inline} $Roles_spec_has_register_new_currency_privilege($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_treasury_compliance_role($m, $txn, account)
}

function {:inline} $Roles_spec_has_update_dual_attestation_threshold_privilege($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_treasury_compliance_role($m, $txn, account)
}

function {:inline} $Roles_spec_has_on_chain_config_privilege($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_libra_root_role($m, $txn, account)
}



// ** structs of module Roles

const unique $Roles_RoleId: $TypeName;
const $Roles_RoleId_role_id: $FieldName;
axiom $Roles_RoleId_role_id == 0;
function $Roles_RoleId_type_value(): $TypeValue {
    $StructType($Roles_RoleId, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $Roles_RoleId_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $Roles_RoleId_role_id))
}
function {:inline} $Roles_RoleId_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $Roles_RoleId_role_id))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Roles_RoleId_is_well_formed($ResourceValue(m, $Roles_RoleId_type_value(), a))
);

procedure {:inline 1} $Roles_RoleId_pack($file_id: int, $byte_index: int, $var_idx: int, role_id: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(role_id);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := role_id], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Roles_RoleId_unpack($struct: $Value) returns (role_id: $Value)
{
    assume is#$Vector($struct);
    role_id := $SelectField($struct, $Roles_RoleId_role_id);
    assume $IsValidU64(role_id);
}



// ** functions of module Roles

procedure {:inline 1} $Roles_grant_root_association_role_def(association: $Value) returns (){
    // declare local variables
    var owner_address: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $Roles_RoleId_type_value()
    var $t21: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 2016, 0, association); }

    // bytecode translation starts here
    // $t21 := move(association)
    call $tmp := $CopyOrMoveValue(association);
    $t21 := $tmp;

    // $t6 := LibraTimestamp::is_genesis()
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 2125);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t2 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2102, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(21, 2102); }
    goto Abort;

    // L0:
L0:

    // $t10 := copy($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 2190);
      goto Abort;
    }
    assume is#$Address($t11);


    // owner_address := $t11
    call $tmp := $CopyOrMoveValue($t11);
    owner_address := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2166, 1, $tmp); }

    // $t13 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 2262);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := ==(owner_address, $t13)
    $tmp := $Boolean($IsEqual(owner_address, $t13));
    $t14 := $tmp;

    // $t4 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2223, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t16 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 1
    $tmp := $Integer(1);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(21, 2223); }
    goto Abort;

    // L2:
L2:

    // $t18 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t18 := $tmp;

    // $t19 := 0
    $tmp := $Integer(0);
    $t19 := $tmp;

    // $t20 := pack Roles::RoleId($t19)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t19);
    $t20 := $tmp;

    // move_to<Roles::RoleId>($t20, $t18)
    call $MoveTo($Roles_RoleId_type_value(), $t20, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 2374);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_grant_root_association_role(association: $Value) returns ()
free requires is#$Address(association);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_grant_root_association_role_def(association);
}

procedure {:inline 1} $Roles_grant_treasury_compliance_role_def(treasury_compliance_account: $Value, lr_account: $Value) returns (){
    // declare local variables
    var owner_address: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $Roles_RoleId_type_value()
    var $t30: $Value; // $AddressType()
    var $t31: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 2616, 0, treasury_compliance_account); }
    if (true) { assume $DebugTrackLocal(21, 2616, 1, lr_account); }

    // bytecode translation starts here
    // $t30 := move(treasury_compliance_account)
    call $tmp := $CopyOrMoveValue(treasury_compliance_account);
    $t30 := $tmp;

    // $t31 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t31 := $tmp;

    // $t9 := LibraTimestamp::is_genesis()
    call $t9 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 2789);
      goto Abort;
    }
    assume is#$Boolean($t9);


    // $t3 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2766, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t11 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t11 := $tmp;

    // destroy($t11)

    // $t12 := move($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t12 := $tmp;

    // destroy($t12)

    // $t13 := 0
    $tmp := $Integer(0);
    $t13 := $tmp;

    // abort($t13)
    if (true) { assume $DebugTrackAbort(21, 2766); }
    goto Abort;

    // L0:
L0:

    // $t14 := move($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t14 := $tmp;

    // $t15 := Roles::has_libra_root_role($t14)
    call $t15 := $Roles_has_libra_root_role($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 8079);
      goto Abort;
    }
    assume is#$Boolean($t15);


    // $t5 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2826, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t17 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t17 := $tmp;

    // destroy($t17)

    // $t18 := 3
    $tmp := $Integer(3);
    $t18 := $tmp;

    // abort($t18)
    if (true) { assume $DebugTrackAbort(21, 2826); }
    goto Abort;

    // L2:
L2:

    // $t19 := copy($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t19 := $tmp;

    // $t20 := Signer::address_of($t19)
    call $t20 := $Signer_address_of($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 2925);
      goto Abort;
    }
    assume is#$Address($t20);


    // owner_address := $t20
    call $tmp := $CopyOrMoveValue($t20);
    owner_address := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2901, 2, $tmp); }

    // $t22 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t22 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 3013);
      goto Abort;
    }
    assume is#$Address($t22);


    // $t23 := ==(owner_address, $t22)
    $tmp := $Boolean($IsEqual(owner_address, $t22));
    $t23 := $tmp;

    // $t7 := $t23
    call $tmp := $CopyOrMoveValue($t23);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 2974, 7, $tmp); }

    // if ($t7) goto L4 else goto L5
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t25 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t25 := $tmp;

    // destroy($t25)

    // $t26 := 2
    $tmp := $Integer(2);
    $t26 := $tmp;

    // abort($t26)
    if (true) { assume $DebugTrackAbort(21, 2974); }
    goto Abort;

    // L4:
L4:

    // $t27 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t27 := $tmp;

    // $t28 := 1
    $tmp := $Integer(1);
    $t28 := $tmp;

    // $t29 := pack Roles::RoleId($t28)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t28);
    $t29 := $tmp;

    // move_to<Roles::RoleId>($t29, $t27)
    call $MoveTo($Roles_RoleId_type_value(), $t29, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 3138);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_grant_treasury_compliance_role(treasury_compliance_account: $Value, lr_account: $Value) returns ()
free requires is#$Address(treasury_compliance_account);
free requires is#$Address(lr_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_grant_treasury_compliance_role_def(treasury_compliance_account, lr_account);
}

procedure {:inline 1} $Roles_has_child_VASP_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8896, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 6
    $tmp := $Integer(6);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8977, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_child_VASP_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_child_VASP_role_def(account);
}

procedure {:inline 1} $Roles_has_designated_dealer_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8346, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 2
    $tmp := $Integer(2);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8434, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_designated_dealer_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_designated_dealer_role_def(account);
}

procedure {:inline 1} $Roles_has_libra_root_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8068, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 0
    $tmp := $Integer(0);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8149, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_libra_root_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_libra_root_role_def(account);
}

procedure {:inline 1} $Roles_has_on_chain_config_privilege_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 9458, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := Roles::has_libra_root_role($t1)
    call $t2 := $Roles_has_libra_root_role($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 8079);
      goto Abort;
    }
    assume is#$Boolean($t2);


    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(21, 9550, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_on_chain_config_privilege(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_on_chain_config_privilege_def(account);
}

procedure {:inline 1} $Roles_has_parent_VASP_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8764, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 5
    $tmp := $Integer(5);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8846, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_parent_VASP_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_parent_VASP_role_def(account);
}

procedure {:inline 1} $Roles_has_register_new_currency_privilege_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 9152, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := Roles::has_treasury_compliance_role($t1)
    call $t2 := $Roles_has_treasury_compliance_role($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 8209);
      goto Abort;
    }
    assume is#$Boolean($t2);


    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(21, 9250, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_register_new_currency_privilege(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_register_new_currency_privilege_def(account);
}

procedure {:inline 1} $Roles_has_role_def(account: $Value, role_id: $Value) returns ($ret0: $Value){
    // declare local variables
    var addr: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Roles_RoleId_type_value()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 7845, 0, account); }
    if (true) { assume $DebugTrackLocal(21, 7845, 1, role_id); }

    // bytecode translation starts here
    // $t16 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t16 := $tmp;

    // $t17 := move(role_id)
    call $tmp := $CopyOrMoveValue(role_id);
    $t17 := $tmp;

    // $t4 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t4 := $tmp;

    // $t5 := Signer::address_of($t4)
    call $t5 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7947);
      goto Abort;
    }
    assume is#$Address($t5);


    // addr := $t5
    call $tmp := $CopyOrMoveValue($t5);
    addr := $tmp;
    if (true) { assume $DebugTrackLocal(21, 7932, 2, $tmp); }

    // $t7 := exists<Roles::RoleId>(addr)
    call $tmp := $Exists(addr, $Roles_RoleId_type_value());
    $t7 := $tmp;

    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t9 := get_global<Roles::RoleId>(addr)
    call $tmp := $GetGlobal(addr, $Roles_RoleId_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 8010);
      goto Abort;
    }
    assume $Roles_RoleId_is_well_formed($tmp);
    $t9 := $tmp;

    // $t10 := get_field<Roles::RoleId>.role_id($t9)
    call $tmp := $GetFieldFromValue($t9, $Roles_RoleId_role_id);
    assume $IsValidU64($tmp);
    $t10 := $tmp;

    // $t11 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;

    // $t13 := ==($t11, $t17)
    $tmp := $Boolean($IsEqual($t11, $t17));
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 7975, 3, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t14 := false
    $tmp := $Boolean(false);
    $t14 := $tmp;

    // $t3 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 7975, 3, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 7975, 18, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_role(account: $Value, role_id: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free requires $IsValidU64(role_id);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_role_def(account, role_id);
}

procedure {:inline 1} $Roles_has_treasury_compliance_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8198, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 1
    $tmp := $Integer(1);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8288, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_treasury_compliance_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_treasury_compliance_role_def(account);
}

procedure {:inline 1} $Roles_has_unhosted_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 9026, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 7
    $tmp := $Integer(7);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 9105, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_unhosted_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_unhosted_role_def(account);
}

procedure {:inline 1} $Roles_has_update_dual_attestation_threshold_privilege_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 9299, 0, account); }

    // bytecode translation starts here
    // $t3 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := Roles::has_treasury_compliance_role($t1)
    call $t2 := $Roles_has_treasury_compliance_role($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 8209);
      goto Abort;
    }
    assume is#$Boolean($t2);


    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(21, 9409, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_update_dual_attestation_threshold_privilege(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_update_dual_attestation_threshold_privilege_def(account);
}

procedure {:inline 1} $Roles_has_validator_operator_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8618, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 4
    $tmp := $Integer(4);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8707, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_validator_operator_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_validator_operator_role_def(account);
}

procedure {:inline 1} $Roles_has_validator_role_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 8490, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := 3
    $tmp := $Integer(3);
    $t2 := $tmp;

    // $t3 := Roles::has_role($t1, $t2)
    call $t3 := $Roles_has_role($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7856);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(21, 8570, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Roles_has_validator_role(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $ret0 := $Roles_has_validator_role_def(account);
}

procedure {:inline 1} $Roles_new_child_vasp_role_def(creating_account: $Value, new_account: $Value) returns (){
    // declare local variables
    var calling_role: $Value; // $Roles_RoleId_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Roles_RoleId_type_value()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Roles_RoleId_type_value()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $Roles_RoleId_type_value()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Roles_RoleId_type_value()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 6185, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(21, 6185, 1, new_account); }

    // bytecode translation starts here
    // $t29 := move(creating_account)
    call $tmp := $CopyOrMoveValue(creating_account);
    $t29 := $tmp;

    // $t30 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t30 := $tmp;

    // $t7 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;

    // $t8 := Signer::address_of($t7)
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 6363);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := get_global<Roles::RoleId>($t8)
    call $tmp := $GetGlobal($t8, $Roles_RoleId_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 6333);
      goto Abort;
    }
    assume $Roles_RoleId_is_well_formed($tmp);
    $t9 := $tmp;

    // calling_role := $t9
    call $tmp := $CopyOrMoveValue($t9);
    calling_role := $tmp;
    if (true) { assume $DebugTrackLocal(21, 6318, 2, $tmp); }

    // $t10 := copy($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 6506);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := exists<Roles::RoleId>($t11)
    call $tmp := $Exists($t11, $Roles_RoleId_type_value());
    $t12 := $tmp;

    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 6475, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 4
    $tmp := $Integer(4);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(21, 6475); }
    goto Abort;

    // L0:
L0:

    // $t18 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t18 := $tmp;

    // $t19 := get_field<Roles::RoleId>.role_id($t18)
    call $tmp := $GetFieldFromValue($t18, $Roles_RoleId_role_id);
    assume $IsValidU64($tmp);
    $t19 := $tmp;

    // $t20 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;

    // $t21 := 5
    $tmp := $Integer(5);
    $t21 := $tmp;

    // $t22 := ==($t20, $t21)
    $tmp := $Boolean($IsEqual($t20, $t21));
    $t22 := $tmp;

    // $t5 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 6565, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t24 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := 3
    $tmp := $Integer(3);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(21, 6565); }
    goto Abort;

    // L2:
L2:

    // $t26 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;

    // $t27 := 6
    $tmp := $Integer(6);
    $t27 := $tmp;

    // $t28 := pack Roles::RoleId($t27)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t27);
    $t28 := $tmp;

    // move_to<Roles::RoleId>($t28, $t26)
    call $MoveTo($Roles_RoleId_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 6648);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_new_child_vasp_role(creating_account: $Value, new_account: $Value) returns ()
free requires is#$Address(creating_account);
free requires is#$Address(new_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_new_child_vasp_role_def(creating_account, new_account);
}

procedure {:inline 1} $Roles_new_designated_dealer_role_def(creating_account: $Value, new_account: $Value) returns (){
    // declare local variables
    var calling_role: $Value; // $Roles_RoleId_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Roles_RoleId_type_value()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Roles_RoleId_type_value()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $Roles_RoleId_type_value()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Roles_RoleId_type_value()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 3558, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(21, 3558, 1, new_account); }

    // bytecode translation starts here
    // $t29 := move(creating_account)
    call $tmp := $CopyOrMoveValue(creating_account);
    $t29 := $tmp;

    // $t30 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t30 := $tmp;

    // $t7 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;

    // $t8 := Signer::address_of($t7)
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 3743);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := get_global<Roles::RoleId>($t8)
    call $tmp := $GetGlobal($t8, $Roles_RoleId_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 3713);
      goto Abort;
    }
    assume $Roles_RoleId_is_well_formed($tmp);
    $t9 := $tmp;

    // calling_role := $t9
    call $tmp := $CopyOrMoveValue($t9);
    calling_role := $tmp;
    if (true) { assume $DebugTrackLocal(21, 3698, 2, $tmp); }

    // $t10 := copy($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 3886);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := exists<Roles::RoleId>($t11)
    call $tmp := $Exists($t11, $Roles_RoleId_type_value());
    $t12 := $tmp;

    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 3855, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 4
    $tmp := $Integer(4);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(21, 3855); }
    goto Abort;

    // L0:
L0:

    // $t18 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t18 := $tmp;

    // $t19 := get_field<Roles::RoleId>.role_id($t18)
    call $tmp := $GetFieldFromValue($t18, $Roles_RoleId_role_id);
    assume $IsValidU64($tmp);
    $t19 := $tmp;

    // $t20 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;

    // $t21 := 1
    $tmp := $Integer(1);
    $t21 := $tmp;

    // $t22 := ==($t20, $t21)
    $tmp := $Boolean($IsEqual($t20, $t21));
    $t22 := $tmp;

    // $t5 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 3945, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t24 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := 3
    $tmp := $Integer(3);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(21, 3945); }
    goto Abort;

    // L2:
L2:

    // $t26 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;

    // $t27 := 2
    $tmp := $Integer(2);
    $t27 := $tmp;

    // $t28 := pack Roles::RoleId($t27)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t27);
    $t28 := $tmp;

    // move_to<Roles::RoleId>($t28, $t26)
    call $MoveTo($Roles_RoleId_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 4036);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_new_designated_dealer_role(creating_account: $Value, new_account: $Value) returns ()
free requires is#$Address(creating_account);
free requires is#$Address(new_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_new_designated_dealer_role_def(creating_account, new_account);
}

procedure {:inline 1} $Roles_new_parent_vasp_role_def(creating_account: $Value, new_account: $Value) returns (){
    // declare local variables
    var calling_role: $Value; // $Roles_RoleId_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Roles_RoleId_type_value()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Roles_RoleId_type_value()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $Roles_RoleId_type_value()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Roles_RoleId_type_value()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 5538, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(21, 5538, 1, new_account); }

    // bytecode translation starts here
    // $t29 := move(creating_account)
    call $tmp := $CopyOrMoveValue(creating_account);
    $t29 := $tmp;

    // $t30 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t30 := $tmp;

    // $t7 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;

    // $t8 := Signer::address_of($t7)
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5717);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := get_global<Roles::RoleId>($t8)
    call $tmp := $GetGlobal($t8, $Roles_RoleId_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5687);
      goto Abort;
    }
    assume $Roles_RoleId_is_well_formed($tmp);
    $t9 := $tmp;

    // calling_role := $t9
    call $tmp := $CopyOrMoveValue($t9);
    calling_role := $tmp;
    if (true) { assume $DebugTrackLocal(21, 5672, 2, $tmp); }

    // $t10 := copy($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5860);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := exists<Roles::RoleId>($t11)
    call $tmp := $Exists($t11, $Roles_RoleId_type_value());
    $t12 := $tmp;

    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 5829, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 4
    $tmp := $Integer(4);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(21, 5829); }
    goto Abort;

    // L0:
L0:

    // $t18 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t18 := $tmp;

    // $t19 := get_field<Roles::RoleId>.role_id($t18)
    call $tmp := $GetFieldFromValue($t18, $Roles_RoleId_role_id);
    assume $IsValidU64($tmp);
    $t19 := $tmp;

    // $t20 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;

    // $t21 := 0
    $tmp := $Integer(0);
    $t21 := $tmp;

    // $t22 := ==($t20, $t21)
    $tmp := $Boolean($IsEqual($t20, $t21));
    $t22 := $tmp;

    // $t5 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 5919, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t24 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := 3
    $tmp := $Integer(3);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(21, 5919); }
    goto Abort;

    // L2:
L2:

    // $t26 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;

    // $t27 := 5
    $tmp := $Integer(5);
    $t27 := $tmp;

    // $t28 := pack Roles::RoleId($t27)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t27);
    $t28 := $tmp;

    // move_to<Roles::RoleId>($t28, $t26)
    call $MoveTo($Roles_RoleId_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 6001);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_new_parent_vasp_role(creating_account: $Value, new_account: $Value) returns ()
free requires is#$Address(creating_account);
free requires is#$Address(new_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_new_parent_vasp_role_def(creating_account, new_account);
}

procedure {:inline 1} $Roles_new_unhosted_role_def(_creating_account: $Value, new_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $Roles_RoleId_type_value()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 6875, 0, _creating_account); }
    if (true) { assume $DebugTrackLocal(21, 6875, 1, new_account); }

    // bytecode translation starts here
    // $t14 := move(_creating_account)
    call $tmp := $CopyOrMoveValue(_creating_account);
    $t14 := $tmp;

    // $t15 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t15 := $tmp;

    // $t4 := copy($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t4 := $tmp;

    // $t5 := Signer::address_of($t4)
    call $t5 := $Signer_address_of($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7068);
      goto Abort;
    }
    assume is#$Address($t5);


    // $t6 := exists<Roles::RoleId>($t5)
    call $tmp := $Exists($t5, $Roles_RoleId_type_value());
    $t6 := $tmp;

    // $t7 := !($t6)
    call $tmp := $Not($t6);
    $t7 := $tmp;

    // $t2 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 7037, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 4
    $tmp := $Integer(4);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(21, 7037); }
    goto Abort;

    // L0:
L0:

    // $t11 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t11 := $tmp;

    // $t12 := 7
    $tmp := $Integer(7);
    $t12 := $tmp;

    // $t13 := pack Roles::RoleId($t12)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t12);
    $t13 := $tmp;

    // move_to<Roles::RoleId>($t13, $t11)
    call $MoveTo($Roles_RoleId_type_value(), $t13, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 7127);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_new_unhosted_role(_creating_account: $Value, new_account: $Value) returns ()
free requires is#$Address(_creating_account);
free requires is#$Address(new_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_new_unhosted_role_def(_creating_account, new_account);
}

procedure {:inline 1} $Roles_new_validator_operator_role_def(creating_account: $Value, new_account: $Value) returns (){
    // declare local variables
    var calling_role: $Value; // $Roles_RoleId_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Roles_RoleId_type_value()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Roles_RoleId_type_value()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $Roles_RoleId_type_value()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Roles_RoleId_type_value()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 4870, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(21, 4870, 1, new_account); }

    // bytecode translation starts here
    // $t29 := move(creating_account)
    call $tmp := $CopyOrMoveValue(creating_account);
    $t29 := $tmp;

    // $t30 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t30 := $tmp;

    // $t7 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;

    // $t8 := Signer::address_of($t7)
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5056);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := get_global<Roles::RoleId>($t8)
    call $tmp := $GetGlobal($t8, $Roles_RoleId_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5026);
      goto Abort;
    }
    assume $Roles_RoleId_is_well_formed($tmp);
    $t9 := $tmp;

    // calling_role := $t9
    call $tmp := $CopyOrMoveValue($t9);
    calling_role := $tmp;
    if (true) { assume $DebugTrackLocal(21, 5011, 2, $tmp); }

    // $t10 := copy($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5199);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := exists<Roles::RoleId>($t11)
    call $tmp := $Exists($t11, $Roles_RoleId_type_value());
    $t12 := $tmp;

    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 5168, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 4
    $tmp := $Integer(4);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(21, 5168); }
    goto Abort;

    // L0:
L0:

    // $t18 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t18 := $tmp;

    // $t19 := get_field<Roles::RoleId>.role_id($t18)
    call $tmp := $GetFieldFromValue($t18, $Roles_RoleId_role_id);
    assume $IsValidU64($tmp);
    $t19 := $tmp;

    // $t20 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;

    // $t21 := 0
    $tmp := $Integer(0);
    $t21 := $tmp;

    // $t22 := ==($t20, $t21)
    $tmp := $Boolean($IsEqual($t20, $t21));
    $t22 := $tmp;

    // $t5 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 5258, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t24 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := 3
    $tmp := $Integer(3);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(21, 5258); }
    goto Abort;

    // L2:
L2:

    // $t26 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;

    // $t27 := 4
    $tmp := $Integer(4);
    $t27 := $tmp;

    // $t28 := pack Roles::RoleId($t27)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t27);
    $t28 := $tmp;

    // move_to<Roles::RoleId>($t28, $t26)
    call $MoveTo($Roles_RoleId_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 5340);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_new_validator_operator_role(creating_account: $Value, new_account: $Value) returns ()
free requires is#$Address(creating_account);
free requires is#$Address(new_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_new_validator_operator_role_def(creating_account, new_account);
}

procedure {:inline 1} $Roles_new_validator_role_def(creating_account: $Value, new_account: $Value) returns (){
    // declare local variables
    var calling_role: $Value; // $Roles_RoleId_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Roles_RoleId_type_value()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Roles_RoleId_type_value()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $Roles_RoleId_type_value()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Roles_RoleId_type_value()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(21, 4223, 0, creating_account); }
    if (true) { assume $DebugTrackLocal(21, 4223, 1, new_account); }

    // bytecode translation starts here
    // $t29 := move(creating_account)
    call $tmp := $CopyOrMoveValue(creating_account);
    $t29 := $tmp;

    // $t30 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t30 := $tmp;

    // $t7 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;

    // $t8 := Signer::address_of($t7)
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 4399);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := get_global<Roles::RoleId>($t8)
    call $tmp := $GetGlobal($t8, $Roles_RoleId_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 4369);
      goto Abort;
    }
    assume $Roles_RoleId_is_well_formed($tmp);
    $t9 := $tmp;

    // calling_role := $t9
    call $tmp := $CopyOrMoveValue($t9);
    calling_role := $tmp;
    if (true) { assume $DebugTrackLocal(21, 4354, 2, $tmp); }

    // $t10 := copy($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 4542);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := exists<Roles::RoleId>($t11)
    call $tmp := $Exists($t11, $Roles_RoleId_type_value());
    $t12 := $tmp;

    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 4511, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 4
    $tmp := $Integer(4);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(21, 4511); }
    goto Abort;

    // L0:
L0:

    // $t18 := move(calling_role)
    call $tmp := $CopyOrMoveValue(calling_role);
    $t18 := $tmp;

    // $t19 := get_field<Roles::RoleId>.role_id($t18)
    call $tmp := $GetFieldFromValue($t18, $Roles_RoleId_role_id);
    assume $IsValidU64($tmp);
    $t19 := $tmp;

    // $t20 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;

    // $t21 := 0
    $tmp := $Integer(0);
    $t21 := $tmp;

    // $t22 := ==($t20, $t21)
    $tmp := $Boolean($IsEqual($t20, $t21));
    $t22 := $tmp;

    // $t5 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(21, 4601, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t24 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := 3
    $tmp := $Integer(3);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(21, 4601); }
    goto Abort;

    // L2:
L2:

    // $t26 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;

    // $t27 := 3
    $tmp := $Integer(3);
    $t27 := $tmp;

    // $t28 := pack Roles::RoleId($t27)
    call $tmp := $Roles_RoleId_pack(0, 0, 0, $t27);
    $t28 := $tmp;

    // move_to<Roles::RoleId>($t28, $t26)
    call $MoveTo($Roles_RoleId_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(21, 4683);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Roles_new_validator_role(creating_account: $Value, new_account: $Value) returns ()
free requires is#$Address(creating_account);
free requires is#$Address(new_account);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Roles_RoleId_type_value(), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Roles_RoleId_type_value(), addr)) && b#$Boolean($Boolean($IsEqual(old($SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id)), $SelectField($ResourceValue($m, $Roles_RoleId_type_value(), addr), $Roles_RoleId_role_id))))))))))));
{
    call $Roles_new_validator_role_def(creating_account, new_account);
}



// ** spec vars of module Vector



// ** spec funs of module Vector

function {:inline} $Vector_spec_contains($tv0: $TypeValue, v: $Value, e: $Value): $Value {
    $Boolean((var $range_1 := v; (exists $i_0: int :: $InVectorRange($range_1, $i_0) && (var x := $select_vector($range_1, $i_0); b#$Boolean($Boolean($IsEqual(x, e)))))))
}

function {:inline} $Vector_eq_push_back($tv0: $TypeValue, v1: $Value, v2: $Value, e: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(v1), $Integer(i#$Integer($vlen_value(v2)) + i#$Integer($Integer(1)))))) && b#$Boolean($Boolean($IsEqual($select_vector_by_value(v1, $Integer(i#$Integer($vlen_value(v1)) - i#$Integer($Integer(1)))), e))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v1, $Range($Integer(0), $Integer(i#$Integer($vlen_value(v1)) - i#$Integer($Integer(1))))), $slice_vector(v2, $Range($Integer(0), $vlen_value(v2)))))))
}

function {:inline} $Vector_eq_append($tv0: $TypeValue, v: $Value, v1: $Value, v2: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(v), $Integer(i#$Integer($vlen_value(v1)) + i#$Integer($vlen_value(v2)))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v, $Range($Integer(0), $vlen_value(v1))), v1))))) && b#$Boolean($Boolean($IsEqual($slice_vector(v, $Range($vlen_value(v1), $vlen_value(v))), v2))))
}

function {:inline} $Vector_eq_pop_front($tv0: $TypeValue, v1: $Value, v2: $Value): $Value {
    $Boolean(b#$Boolean($Boolean($IsEqual($Integer(i#$Integer($vlen_value(v1)) + i#$Integer($Integer(1))), $vlen_value(v2)))) && b#$Boolean($Boolean($IsEqual(v1, $slice_vector(v2, $Range($Integer(1), $vlen_value(v2)))))))
}



// ** structs of module Vector



// ** functions of module Vector

procedure {:inline 1} $Vector_singleton_def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value){
    // declare local variables
    var v: $Value; // $Vector_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t4: $Value; // $tv0
    var $t5: $Value; // $Vector_type_value($tv0)
    var $t6: $Value; // $tv0
    var $t7: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(28, 1249, 0, e); }

    // bytecode translation starts here
    // $t6 := move(e)
    call $tmp := $CopyOrMoveValue(e);
    $t6 := $tmp;

    // $t2 := Vector::empty<#0>()
    call $t2 := $Vector_empty($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 179);
      goto Abort;
    }
    assume $Vector_is_well_formed($t2);


    // v := $t2
    call $tmp := $CopyOrMoveValue($t2);
    v := $tmp;
    if (true) { assume $DebugTrackLocal(28, 1322, 1, $tmp); }

    // $t3 := borrow_local(v)
    call $t3 := $BorrowLoc(1, v);
    assume $Vector_is_well_formed($Dereference($t3));

    // UnpackRef($t3)

    // PackRef($t3)

    // $t7 := read_ref($t3)
    call $tmp := $ReadRef($t3);
    assume $Vector_is_well_formed($tmp);
    $t7 := $tmp;

    // $t7 := Vector::push_back<#0>($t7, $t6)
    call $t7 := $Vector_push_back($tv0, $t7, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(28, 542);
      goto Abort;
    }
    assume $Vector_is_well_formed($t7);


    // write_ref($t3, $t7)
    call $t3 := $WriteRef($t3, $t7);

    // LocalRoot(v) <- $t3
    call v := $WritebackToValue($t3, 1, v);

    // UnpackRef($t3)

    // PackRef($t3)

    // return v
    $ret0 := v;
    if (true) { assume $DebugTrackLocal(28, 1373, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Vector_singleton($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
{
    call $ret0 := $Vector_singleton_def($tv0, e);
}



// ** spec vars of module Offer



// ** spec funs of module Offer

function {:inline} $Offer_is_allowed_recipient($m: $Memory, $txn: $Transaction, $tv0: $TypeValue, offer_addr: $Value, recipient: $Value): $Value {
    $Boolean(b#$Boolean($Boolean($IsEqual(recipient, $SelectField($ResourceValue($m, $Offer_Offer_type_value($tv0), offer_addr), $Offer_Offer_for)))) || b#$Boolean($Boolean($IsEqual(recipient, offer_addr))))
}



// ** structs of module Offer

const unique $Offer_Offer: $TypeName;
const $Offer_Offer_offered: $FieldName;
axiom $Offer_Offer_offered == 0;
const $Offer_Offer_for: $FieldName;
axiom $Offer_Offer_for == 1;
function $Offer_Offer_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Offer_Offer, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0][1 := $AddressType()], 2))
}
function {:inline} $Offer_Offer_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $Offer_Offer_for))
}
function {:inline} $Offer_Offer_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $Offer_Offer_for))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Offer_Offer_is_well_formed($ResourceValue(m, $Offer_Offer_type_value($tv0), a))
);

procedure {:inline 1} $Offer_Offer_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, offered: $Value, for: $Value) returns ($struct: $Value)
{
    assume is#$Address(for);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := offered][1 := for], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Offer_Offer_unpack($tv0: $TypeValue, $struct: $Value) returns (offered: $Value, for: $Value)
{
    assume is#$Vector($struct);
    offered := $SelectField($struct, $Offer_Offer_offered);
    for := $SelectField($struct, $Offer_Offer_for);
    assume is#$Address(for);
}



// ** functions of module Offer

procedure {:inline 1} $Offer_address_of_def($tv0: $TypeValue, offer_address: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $Offer_Offer_type_value($tv0)
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(18, 1494, 0, offer_address); }

    // bytecode translation starts here
    // $t5 := move(offer_address)
    call $tmp := $CopyOrMoveValue(offer_address);
    $t5 := $tmp;

    // $t2 := get_global<Offer::Offer<#0>>($t5)
    call $tmp := $GetGlobal($t5, $Offer_Offer_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 1579);
      goto Abort;
    }
    assume $Offer_Offer_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<Offer::Offer<#0>>.for($t2)
    call $tmp := $GetFieldFromValue($t2, $Offer_Offer_for);
    assume is#$Address($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(18, 1579, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Offer_address_of($tv0: $TypeValue, offer_address: $Value) returns ($ret0: $Value)
free requires is#$Address(offer_address);
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall ty: $Value :: is#$Type(ty) ==> b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr)))))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall ty: $Value :: is#$Type(ty) ==> b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr)) && b#$Boolean($Boolean($IsEqual($ResourceValue($m, $Offer_Offer_type_value(t#$Type(ty)), addr), old($ResourceValue($m, $Offer_Offer_type_value(t#$Type(ty)), addr))))))))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $SelectField($ResourceValue($m, $Offer_Offer_type_value($tv0), offer_address), $Offer_Offer_for)))));
{
    call $ret0 := $Offer_address_of_def($tv0, offer_address);
}

procedure {:inline 1} $Offer_create_def($tv0: $TypeValue, account: $Value, offered: $Value, for: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $tv0
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Offer_Offer_type_value($tv0)
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $tv0
    var $t9: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(18, 501, 0, account); }
    if (true) { assume $DebugTrackLocal(18, 501, 1, offered); }
    if (true) { assume $DebugTrackLocal(18, 501, 2, for); }

    // bytecode translation starts here
    // $t7 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t7 := $tmp;

    // $t8 := move(offered)
    call $tmp := $CopyOrMoveValue(offered);
    $t8 := $tmp;

    // $t9 := move(for)
    call $tmp := $CopyOrMoveValue(for);
    $t9 := $tmp;

    // $t3 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;

    // $t6 := pack Offer::Offer<#0>($t8, $t9)
    call $tmp := $Offer_Offer_pack(0, 0, 0, $tv0, $t8, $t9);
    $t6 := $tmp;

    // move_to<Offer::Offer<#0>>($t6, $t3)
    call $MoveTo($Offer_Offer_type_value($tv0), $t6, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 584);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Offer_create($tv0: $TypeValue, account: $Value, offered: $Value, for: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(for);
free ensures b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($ResourceExists($m, $Offer_Offer_type_value($tv0), $Signer_spec_address_of($m, $txn, account))))));
free ensures !$abort_flag ==> (b#$Boolean($ResourceExists($m, $Offer_Offer_type_value($tv0), $Signer_spec_address_of($m, $txn, account))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ResourceValue($m, $Offer_Offer_type_value($tv0), $Signer_spec_address_of($m, $txn, account)), $Vector($ExtendValueArray($ExtendValueArray($EmptyValueArray(), offered), for))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall ty: $Value :: is#$Type(ty) ==> b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr)) && b#$Boolean($Boolean($IsEqual($ResourceValue($m, $Offer_Offer_type_value(t#$Type(ty)), addr), old($ResourceValue($m, $Offer_Offer_type_value(t#$Type(ty)), addr))))))))))))))));
{
    call $Offer_create_def($tv0, account, offered, for);
}

procedure {:inline 1} $Offer_exists_at_def($tv0: $TypeValue, offer_address: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(18, 1272, 0, offer_address); }

    // bytecode translation starts here
    // $t3 := move(offer_address)
    call $tmp := $CopyOrMoveValue(offer_address);
    $t3 := $tmp;

    // $t2 := exists<Offer::Offer<#0>>($t3)
    call $tmp := $Exists($t3, $Offer_Offer_type_value($tv0));
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(18, 1338, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Offer_exists_at($tv0: $TypeValue, offer_address: $Value) returns ($ret0: $Value)
free requires is#$Address(offer_address);
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall ty: $Value :: is#$Type(ty) ==> b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr)))))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall ty: $Value :: is#$Type(ty) ==> b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr))) ==> b#$Boolean($Boolean(b#$Boolean($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr)) && b#$Boolean($Boolean($IsEqual($ResourceValue($m, $Offer_Offer_type_value(t#$Type(ty)), addr), old($ResourceValue($m, $Offer_Offer_type_value(t#$Type(ty)), addr))))))))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address)))));
{
    call $ret0 := $Offer_exists_at_def($tv0, offer_address);
}

procedure {:inline 1} $Offer_redeem_def($tv0: $TypeValue, account: $Value, offer_address: $Value) returns ($ret0: $Value){
    // declare local variables
    var for: $Value; // $AddressType()
    var offered: $Value; // $tv0
    var sender: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Offer_Offer_type_value($tv0)
    var $t10: $Value; // $tv0
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $tv0
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(18, 875, 0, account); }
    if (true) { assume $DebugTrackLocal(18, 875, 1, offer_address); }

    // bytecode translation starts here
    // $t25 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t25 := $tmp;

    // $t26 := move(offer_address)
    call $tmp := $CopyOrMoveValue(offer_address);
    $t26 := $tmp;

    // $t9 := move_from<Offer::Offer<#0>>($t26)
    call $tmp := $MoveFrom($t26, $Offer_Offer_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 1012);
      goto Abort;
    }
    assume $Offer_Offer_is_well_formed($tmp);
    $t9 := $tmp;

    // ($t10, $t11) := unpack Offer::Offer<#0>($t9)
    call $t10, $t11 := $Offer_Offer_unpack($tv0, $t9);
    $t10 := $t10;
    $t11 := $t11;

    // for := $t11
    call $tmp := $CopyOrMoveValue($t11);
    for := $tmp;
    if (true) { assume $DebugTrackLocal(18, 1004, 2, $tmp); }

    // offered := $t10
    call $tmp := $CopyOrMoveValue($t10);
    offered := $tmp;
    if (true) { assume $DebugTrackLocal(18, 995, 3, $tmp); }

    // $t12 := move($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t12 := $tmp;

    // $t13 := Signer::address_of($t12)
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(18, 1079);
      goto Abort;
    }
    assume is#$Address($t13);


    // sender := $t13
    call $tmp := $CopyOrMoveValue($t13);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(18, 1062, 4, $tmp); }

    // $t16 := ==(sender, for)
    $tmp := $Boolean($IsEqual(sender, for));
    $t16 := $tmp;

    // if ($t16) goto L0 else goto L1
    $tmp := $t16;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t17 := true
    $tmp := $Boolean(true);
    $t17 := $tmp;

    // $t7 := $t17
    call $tmp := $CopyOrMoveValue($t17);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(18, 1111, 7, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t20 := ==(sender, $t26)
    $tmp := $Boolean($IsEqual(sender, $t26));
    $t20 := $tmp;

    // $t7 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(18, 1111, 7, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // $t5 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(18, 1104, 5, $tmp); }

    // if ($t5) goto L4 else goto L5
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t23 := 0
    $tmp := $Integer(0);
    $t23 := $tmp;

    // abort($t23)
    if (true) { assume $DebugTrackAbort(18, 1104); }
    goto Abort;

    // L4:
L4:

    // return offered
    $ret0 := offered;
    if (true) { assume $DebugTrackLocal(18, 1182, 27, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Offer_redeem($tv0: $TypeValue, account: $Value, offer_address: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free requires is#$Address(offer_address);
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Offer_is_allowed_recipient($m, $txn, $tv0, offer_address, $Signer_spec_address_of($m, $txn, account)))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Offer_is_allowed_recipient($m, $txn, $tv0, offer_address, $Signer_spec_address_of($m, $txn, account))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall ty: $Value :: is#$Type(ty) ==> b#$Boolean($Boolean((forall addr: $Value :: is#$Address(addr) ==> b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr))))) ==> b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value(t#$Type(ty)), addr)))))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean(old($ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address))) && b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Offer_Offer_type_value($tv0), offer_address)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, old($SelectField($ResourceValue($m, $Offer_Offer_type_value($tv0), offer_address), $Offer_Offer_offered))))));
{
    call $ret0 := $Offer_redeem_def($tv0, account, offer_address);
}



// ** spec vars of module LCS



// ** spec funs of module LCS



// ** structs of module LCS



// ** functions of module LCS



// ** spec vars of module Event



// ** spec funs of module Event



// ** structs of module Event

const unique $Event_EventHandle: $TypeName;
const $Event_EventHandle_counter: $FieldName;
axiom $Event_EventHandle_counter == 0;
const $Event_EventHandle_guid: $FieldName;
axiom $Event_EventHandle_guid == 1;
function $Event_EventHandle_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Event_EventHandle, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())], 2))
}
function {:inline} $Event_EventHandle_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Event_EventHandle_counter))
      && $Vector_is_well_formed($SelectField($this, $Event_EventHandle_guid)) && (forall $$0: int :: {$select_vector($SelectField($this, $Event_EventHandle_guid),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Event_EventHandle_guid)) ==> $IsValidU8($select_vector($SelectField($this, $Event_EventHandle_guid),$$0)))
}
function {:inline} $Event_EventHandle_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Event_EventHandle_counter))
      && $Vector_is_well_formed($SelectField($this, $Event_EventHandle_guid)) && (forall $$0: int :: {$select_vector($SelectField($this, $Event_EventHandle_guid),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Event_EventHandle_guid)) ==> $IsValidU8($select_vector($SelectField($this, $Event_EventHandle_guid),$$0)))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Event_EventHandle_is_well_formed($ResourceValue(m, $Event_EventHandle_type_value($tv0), a))
);

procedure {:inline 1} $Event_EventHandle_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, counter: $Value, guid: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(counter);
    assume $Vector_is_well_formed(guid) && (forall $$0: int :: {$select_vector(guid,$$0)} $$0 >= 0 && $$0 < $vlen(guid) ==> $IsValidU8($select_vector(guid,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := counter][1 := guid], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Event_EventHandle_unpack($tv0: $TypeValue, $struct: $Value) returns (counter: $Value, guid: $Value)
{
    assume is#$Vector($struct);
    counter := $SelectField($struct, $Event_EventHandle_counter);
    assume $IsValidU64(counter);
    guid := $SelectField($struct, $Event_EventHandle_guid);
    assume $Vector_is_well_formed(guid) && (forall $$0: int :: {$select_vector(guid,$$0)} $$0 >= 0 && $$0 < $vlen(guid) ==> $IsValidU8($select_vector(guid,$$0)));
}

const unique $Event_EventHandleGenerator: $TypeName;
const $Event_EventHandleGenerator_counter: $FieldName;
axiom $Event_EventHandleGenerator_counter == 0;
const $Event_EventHandleGenerator_addr: $FieldName;
axiom $Event_EventHandleGenerator_addr == 1;
function $Event_EventHandleGenerator_type_value(): $TypeValue {
    $StructType($Event_EventHandleGenerator, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $AddressType()], 2))
}
function {:inline} $Event_EventHandleGenerator_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Event_EventHandleGenerator_counter))
      && is#$Address($SelectField($this, $Event_EventHandleGenerator_addr))
}
function {:inline} $Event_EventHandleGenerator_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Event_EventHandleGenerator_counter))
      && is#$Address($SelectField($this, $Event_EventHandleGenerator_addr))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Event_EventHandleGenerator_is_well_formed($ResourceValue(m, $Event_EventHandleGenerator_type_value(), a))
);

procedure {:inline 1} $Event_EventHandleGenerator_pack($file_id: int, $byte_index: int, $var_idx: int, counter: $Value, addr: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(counter);
    assume is#$Address(addr);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := counter][1 := addr], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Event_EventHandleGenerator_unpack($struct: $Value) returns (counter: $Value, addr: $Value)
{
    assume is#$Vector($struct);
    counter := $SelectField($struct, $Event_EventHandleGenerator_counter);
    assume $IsValidU64(counter);
    addr := $SelectField($struct, $Event_EventHandleGenerator_addr);
    assume is#$Address(addr);
}



// ** functions of module Event



// ** spec vars of module LibraConfig



// ** spec funs of module LibraConfig

function {:inline} $LibraConfig_spec_has_config($m: $Memory, $txn: $Transaction): $Value {
    $ResourceExists($m, $LibraConfig_Configuration_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_spec_get($m: $Memory, $txn: $Transaction, $tv0: $TypeValue): $Value {
    $SelectField($ResourceValue($m, $LibraConfig_LibraConfig_type_value($tv0), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()), $LibraConfig_LibraConfig_payload)
}

function {:inline} $LibraConfig_spec_is_published($m: $Memory, $txn: $Transaction, $tv0: $TypeValue): $Value {
    $ResourceExists($m, $LibraConfig_LibraConfig_type_value($tv0), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}

function {:inline} $LibraConfig_spec_has_on_chain_config_privilege($m: $Memory, $txn: $Transaction, account: $Value): $Value {
    $Roles_spec_has_libra_root_role($m, $txn, account)
}



// ** structs of module LibraConfig

const unique $LibraConfig_LibraConfig: $TypeName;
const $LibraConfig_LibraConfig_payload: $FieldName;
axiom $LibraConfig_LibraConfig_payload == 0;
function $LibraConfig_LibraConfig_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($LibraConfig_LibraConfig, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1))
}
function {:inline} $LibraConfig_LibraConfig_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
}
function {:inline} $LibraConfig_LibraConfig_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraConfig_LibraConfig_is_well_formed($ResourceValue(m, $LibraConfig_LibraConfig_type_value($tv0), a))
);

procedure {:inline 1} $LibraConfig_LibraConfig_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, payload: $Value) returns ($struct: $Value)
{
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := payload], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_LibraConfig_unpack($tv0: $TypeValue, $struct: $Value) returns (payload: $Value)
{
    assume is#$Vector($struct);
    payload := $SelectField($struct, $LibraConfig_LibraConfig_payload);
}

const unique $LibraConfig_Configuration: $TypeName;
const $LibraConfig_Configuration_epoch: $FieldName;
axiom $LibraConfig_Configuration_epoch == 0;
const $LibraConfig_Configuration_last_reconfiguration_time: $FieldName;
axiom $LibraConfig_Configuration_last_reconfiguration_time == 1;
const $LibraConfig_Configuration_events: $FieldName;
axiom $LibraConfig_Configuration_events == 2;
function $LibraConfig_Configuration_type_value(): $TypeValue {
    $StructType($LibraConfig_Configuration, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $IntegerType()][2 := $Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value())], 3))
}
function {:inline} $LibraConfig_Configuration_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $LibraConfig_Configuration_epoch))
      && $IsValidU64($SelectField($this, $LibraConfig_Configuration_last_reconfiguration_time))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraConfig_Configuration_events))
}
function {:inline} $LibraConfig_Configuration_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $LibraConfig_Configuration_epoch))
      && $IsValidU64($SelectField($this, $LibraConfig_Configuration_last_reconfiguration_time))
      && $Event_EventHandle_is_well_formed($SelectField($this, $LibraConfig_Configuration_events))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraConfig_Configuration_is_well_formed($ResourceValue(m, $LibraConfig_Configuration_type_value(), a))
);

procedure {:inline 1} $LibraConfig_Configuration_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value, last_reconfiguration_time: $Value, events: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(epoch);
    assume $IsValidU64(last_reconfiguration_time);
    assume $Event_EventHandle_is_well_formed(events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := epoch][1 := last_reconfiguration_time][2 := events], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_Configuration_unpack($struct: $Value) returns (epoch: $Value, last_reconfiguration_time: $Value, events: $Value)
{
    assume is#$Vector($struct);
    epoch := $SelectField($struct, $LibraConfig_Configuration_epoch);
    assume $IsValidU64(epoch);
    last_reconfiguration_time := $SelectField($struct, $LibraConfig_Configuration_last_reconfiguration_time);
    assume $IsValidU64(last_reconfiguration_time);
    events := $SelectField($struct, $LibraConfig_Configuration_events);
    assume $Event_EventHandle_is_well_formed(events);
}

const unique $LibraConfig_ModifyConfigCapability: $TypeName;
const $LibraConfig_ModifyConfigCapability_dummy_field: $FieldName;
axiom $LibraConfig_ModifyConfigCapability_dummy_field == 0;
function $LibraConfig_ModifyConfigCapability_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($LibraConfig_ModifyConfigCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $LibraConfig_ModifyConfigCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraConfig_ModifyConfigCapability_dummy_field))
}
function {:inline} $LibraConfig_ModifyConfigCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraConfig_ModifyConfigCapability_dummy_field))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraConfig_ModifyConfigCapability_is_well_formed($ResourceValue(m, $LibraConfig_ModifyConfigCapability_type_value($tv0), a))
);

procedure {:inline 1} $LibraConfig_ModifyConfigCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_ModifyConfigCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraConfig_ModifyConfigCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $LibraConfig_NewEpochEvent: $TypeName;
const $LibraConfig_NewEpochEvent_epoch: $FieldName;
axiom $LibraConfig_NewEpochEvent_epoch == 0;
function $LibraConfig_NewEpochEvent_type_value(): $TypeValue {
    $StructType($LibraConfig_NewEpochEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $LibraConfig_NewEpochEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraConfig_NewEpochEvent_epoch))
}
function {:inline} $LibraConfig_NewEpochEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraConfig_NewEpochEvent_epoch))
}

procedure {:inline 1} $LibraConfig_NewEpochEvent_pack($file_id: int, $byte_index: int, $var_idx: int, epoch: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(epoch);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := epoch], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraConfig_NewEpochEvent_unpack($struct: $Value) returns (epoch: $Value)
{
    assume is#$Vector($struct);
    epoch := $SelectField($struct, $LibraConfig_NewEpochEvent_epoch);
    assume $IsValidU64(epoch);
}



// ** functions of module LibraConfig

procedure {:inline 1} $LibraConfig_initialize_def(config_account: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value())
    var $t21: $Value; // $LibraConfig_Configuration_type_value()
    var $t22: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 1177, 0, config_account); }

    // bytecode translation starts here
    // $t22 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t22 := $tmp;

    // $t5 := LibraTimestamp::is_genesis()
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1272);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // $t1 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 1249, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;

    // destroy($t7)

    // $t8 := 0
    $tmp := $Integer(0);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(15, 1249); }
    goto Abort;

    // L0:
L0:

    // $t9 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t9 := $tmp;

    // $t10 := Signer::address_of($t9)
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1358);
      goto Abort;
    }
    assume is#$Address($t10);


    // $t11 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1403);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := ==($t10, $t11)
    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;

    // $t3 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 1343, 3, $tmp); }

    // if ($t3) goto L2 else goto L3
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t14 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t14 := $tmp;

    // destroy($t14)

    // $t15 := 2
    $tmp := $Integer(2);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(15, 1343); }
    goto Abort;

    // L2:
L2:

    // $t16 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t16 := $tmp;

    // $t17 := 0
    $tmp := $Integer(0);
    $t17 := $tmp;

    // $t18 := 0
    $tmp := $Integer(0);
    $t18 := $tmp;

    // $t19 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t19 := $tmp;

    // $t20 := Event::new_event_handle<LibraConfig::NewEpochEvent>($t19)
    call $t20 := $Event_new_event_handle($LibraConfig_NewEpochEvent_type_value(), $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1645);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t20);


    // $t21 := pack LibraConfig::Configuration($t17, $t18, $t20)
    call $tmp := $LibraConfig_Configuration_pack(0, 0, 0, $t17, $t18, $t20);
    $t21 := $tmp;

    // move_to<LibraConfig::Configuration>($t21, $t16)
    call $MoveTo($LibraConfig_Configuration_type_value(), $t21, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1462);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_initialize(config_account: $Value) returns ()
free requires is#$Address(config_account);
{
    call $LibraConfig_initialize_def(config_account);
}

procedure {:inline 1} $LibraConfig_claim_delegated_modify_config_def($tv0: $TypeValue, account: $Value, offer_address: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 6417, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 6417, 1, offer_address); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t6 := $tmp;

    // $t7 := move(offer_address)
    call $tmp := $CopyOrMoveValue(offer_address);
    $t7 := $tmp;

    // $t2 := copy($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;

    // $t3 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;

    // $t5 := Offer::redeem<LibraConfig::ModifyConfigCapability<#0>>($t3, $t7)
    call $t5 := $Offer_redeem($LibraConfig_ModifyConfigCapability_type_value($tv0), $t3, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 6542);
      goto Abort;
    }
    assume $LibraConfig_ModifyConfigCapability_is_well_formed($t5);


    // move_to<LibraConfig::ModifyConfigCapability<#0>>($t5, $t2)
    call $MoveTo($LibraConfig_ModifyConfigCapability_type_value($tv0), $t5, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 6518);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_claim_delegated_modify_config($tv0: $TypeValue, account: $Value, offer_address: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(offer_address);
{
    call $LibraConfig_claim_delegated_modify_config_def($tv0, account, offer_address);
}

procedure {:inline 1} $LibraConfig_emit_reconfiguration_event_def() returns (){
    // declare local variables
    var config_ref: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t1: $Value; // $AddressType()
    var $t2: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t3: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t9: $Reference; // ReferenceType($IntegerType())
    var $t10: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t11: $Reference; // ReferenceType($Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value()))
    var $t12: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $LibraConfig_NewEpochEvent_type_value()
    var $t16: $Value; // $Event_EventHandle_type_value($LibraConfig_NewEpochEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t1 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 8717);
      goto Abort;
    }
    assume is#$Address($t1);


    // $t2 := borrow_global<LibraConfig::Configuration>($t1)
    call $t2 := $BorrowGlobal($t1, $LibraConfig_Configuration_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 8669);
      goto Abort;
    }
    assume $LibraConfig_Configuration_is_well_formed($Dereference($t2));

    // UnpackRef($t2)

    // config_ref := $t2
    call config_ref := $CopyOrMoveRef($t2);
    if (true) { assume $DebugTrackLocal(15, 8656, 0, $Dereference(config_ref)); }

    // $t3 := copy(config_ref)
    call $t3 := $CopyOrMoveRef(config_ref);

    // $t4 := get_field<LibraConfig::Configuration>.epoch($t3)
    call $tmp := $GetFieldFromReference($t3, $LibraConfig_Configuration_epoch);
    assume $IsValidU64($tmp);
    $t4 := $tmp;

    // Reference(config_ref) <- $t3
    call config_ref := $WritebackToReference($t3, config_ref);

    // $t5 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t5 := $tmp;

    // $t6 := 1
    $tmp := $Integer(1);
    $t6 := $tmp;

    // $t7 := +($t5, $t6)
    call $tmp := $AddU64($t5, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 8784);
      goto Abort;
    }
    $t7 := $tmp;

    // $t8 := copy(config_ref)
    call $t8 := $CopyOrMoveRef(config_ref);

    // $t9 := borrow_field<LibraConfig::Configuration>.epoch($t8)
    call $t9 := $BorrowField($t8, $LibraConfig_Configuration_epoch);
    assume $IsValidU64($Dereference($t9));

    // Reference(config_ref) <- $t8
    call config_ref := $WritebackToReference($t8, config_ref);

    // UnpackRef($t9)

    // write_ref($t9, $t7)
    call $t9 := $WriteRef($t9, $t7);
    if (true) { assume $DebugTrackLocal(15, 8748, 0, $Dereference(config_ref)); }

    // Reference(config_ref) <- $t9
    call config_ref := $WritebackToReference($t9, config_ref);

    // Reference($t8) <- $t9
    call $t8 := $WritebackToReference($t9, $t8);

    // PackRef($t9)

    // $t10 := copy(config_ref)
    call $t10 := $CopyOrMoveRef(config_ref);

    // $t11 := borrow_field<LibraConfig::Configuration>.events($t10)
    call $t11 := $BorrowField($t10, $LibraConfig_Configuration_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t11));

    // Reference(config_ref) <- $t10
    call config_ref := $WritebackToReference($t10, config_ref);

    // UnpackRef($t11)

    // $t12 := move(config_ref)
    call $t12 := $CopyOrMoveRef(config_ref);

    // $t13 := get_field<LibraConfig::Configuration>.epoch($t12)
    call $tmp := $GetFieldFromReference($t12, $LibraConfig_Configuration_epoch);
    assume $IsValidU64($tmp);
    $t13 := $tmp;

    // LibraConfig::Configuration <- $t12
    call $WritebackToGlobal($t12);

    // $t14 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t14 := $tmp;

    // $t15 := pack LibraConfig::NewEpochEvent($t14)
    call $tmp := $LibraConfig_NewEpochEvent_pack(0, 0, 0, $t14);
    $t15 := $tmp;

    // PackRef($t11)

    // $t16 := read_ref($t11)
    call $tmp := $ReadRef($t11);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t16 := $tmp;

    // $t16 := Event::emit_event<LibraConfig::NewEpochEvent>($t16, $t15)
    call $t16 := $Event_emit_event($LibraConfig_NewEpochEvent_type_value(), $t16, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 8805);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t16);


    // write_ref($t11, $t16)
    call $t11 := $WriteRef($t11, $t16);
    if (true) { assume $DebugTrackLocal(15, 8586, 0, $Dereference(config_ref)); }

    // LibraConfig::Configuration <- $t11
    call $WritebackToGlobal($t11);

    // Reference($t10) <- $t11
    call $t10 := $WritebackToReference($t11, $t10);

    // Reference($t12) <- $t11
    call $t12 := $WritebackToReference($t11, $t12);

    // UnpackRef($t11)

    // PackRef($t11)

    // PackRef($t12)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_emit_reconfiguration_event() returns ()
{
    call $LibraConfig_emit_reconfiguration_event_def();
}

procedure {:inline 1} $LibraConfig_get_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var addr: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t10: $Value; // $tv0
    var $t11: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t3 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t3 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1891);
      goto Abort;
    }
    assume is#$Address($t3);


    // addr := $t3
    call $tmp := $CopyOrMoveValue($t3);
    addr := $tmp;
    if (true) { assume $DebugTrackLocal(15, 1869, 0, $tmp); }

    // $t5 := exists<LibraConfig::LibraConfig<#0>>(addr)
    call $tmp := $Exists(addr, $LibraConfig_LibraConfig_type_value($tv0));
    $t5 := $tmp;

    // $t1 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 1921, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := 3
    $tmp := $Integer(3);
    $t7 := $tmp;

    // abort($t7)
    if (true) { assume $DebugTrackAbort(15, 1921); }
    goto Abort;

    // L0:
L0:

    // $t9 := get_global<LibraConfig::LibraConfig<#0>>(addr)
    call $tmp := $GetGlobal(addr, $LibraConfig_LibraConfig_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 1998);
      goto Abort;
    }
    assume $LibraConfig_LibraConfig_is_well_formed($tmp);
    $t9 := $tmp;

    // $t10 := get_field<LibraConfig::LibraConfig<#0>>.payload($t9)
    call $tmp := $GetFieldFromValue($t9, $LibraConfig_LibraConfig_payload);
    $t10 := $tmp;

    // $t11 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;

    // return $t11
    $ret0 := $t11;
    if (true) { assume $DebugTrackLocal(15, 1996, 12, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraConfig_get($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $LibraConfig_get_def($tv0);
}

procedure {:inline 1} $LibraConfig_publish_new_config_def($tv0: $TypeValue, config_account: $Value, payload: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $tv0
    var $t23: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 4690, 0, config_account); }
    if (true) { assume $DebugTrackLocal(15, 4690, 1, payload); }

    // bytecode translation starts here
    // $t24 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t24 := $tmp;

    // $t25 := move(payload)
    call $tmp := $CopyOrMoveValue(payload);
    $t25 := $tmp;

    // $t6 := copy($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t6 := $tmp;

    // $t7 := Roles::has_on_chain_config_privilege($t6)
    call $t7 := $Roles_has_on_chain_config_privilege($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 4826);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t2 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 4812, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 5
    $tmp := $Integer(5);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(15, 4812); }
    goto Abort;

    // L0:
L0:

    // $t11 := copy($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t11 := $tmp;

    // $t12 := Signer::address_of($t11)
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 4919);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 4964);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := ==($t12, $t13)
    $tmp := $Boolean($IsEqual($t12, $t13));
    $t14 := $tmp;

    // $t4 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 4904, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t16 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 2
    $tmp := $Integer(2);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(15, 4904); }
    goto Abort;

    // L2:
L2:

    // $t18 := copy($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t18 := $tmp;

    // $t19 := false
    $tmp := $Boolean(false);
    $t19 := $tmp;

    // $t20 := pack LibraConfig::ModifyConfigCapability<#0>($t19)
    call $tmp := $LibraConfig_ModifyConfigCapability_pack(0, 0, 0, $tv0, $t19);
    $t20 := $tmp;

    // move_to<LibraConfig::ModifyConfigCapability<#0>>($t20, $t18)
    call $MoveTo($LibraConfig_ModifyConfigCapability_type_value($tv0), $t20, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5023);
      goto Abort;
    }

    // $t21 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t21 := $tmp;

    // $t23 := pack LibraConfig::LibraConfig<#0>($t25)
    call $tmp := $LibraConfig_LibraConfig_pack(0, 0, 0, $tv0, $t25);
    $t23 := $tmp;

    // move_to<LibraConfig::LibraConfig<#0>>($t23, $t21)
    call $MoveTo($LibraConfig_LibraConfig_type_value($tv0), $t23, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5091);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_publish_new_config($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ()
free requires is#$Address(config_account);
free ensures !$abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $tv0))))));
free ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($m, $txn, $tv0)));
{
    call $LibraConfig_publish_new_config_def($tv0, config_account, payload);
}

procedure {:inline 1} $LibraConfig_publish_new_config_with_capability_def($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $tv0
    var $t20: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 3398, 0, config_account); }
    if (true) { assume $DebugTrackLocal(15, 3398, 1, payload); }

    // bytecode translation starts here
    // $t23 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t23 := $tmp;

    // $t24 := move(payload)
    call $tmp := $CopyOrMoveValue(payload);
    $t24 := $tmp;

    // $t6 := copy($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t6 := $tmp;

    // $t7 := Roles::has_on_chain_config_privilege($t6)
    call $t7 := $Roles_has_on_chain_config_privilege($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 3583);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t2 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 3569, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 5
    $tmp := $Integer(5);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(15, 3569); }
    goto Abort;

    // L0:
L0:

    // $t11 := copy($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t11 := $tmp;

    // $t12 := Signer::address_of($t11)
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 3676);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 3721);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := ==($t12, $t13)
    $tmp := $Boolean($IsEqual($t12, $t13));
    $t14 := $tmp;

    // $t4 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 3661, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t16 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 2
    $tmp := $Integer(2);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(15, 3661); }
    goto Abort;

    // L2:
L2:

    // $t18 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t18 := $tmp;

    // $t20 := pack LibraConfig::LibraConfig<#0>($t24)
    call $tmp := $LibraConfig_LibraConfig_pack(0, 0, 0, $tv0, $t24);
    $t20 := $tmp;

    // move_to<LibraConfig::LibraConfig<#0>>($t20, $t18)
    call $MoveTo($LibraConfig_LibraConfig_type_value($tv0), $t20, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 3780);
      goto Abort;
    }

    // $t21 := false
    $tmp := $Boolean(false);
    $t21 := $tmp;

    // $t22 := pack LibraConfig::ModifyConfigCapability<#0>($t21)
    call $tmp := $LibraConfig_ModifyConfigCapability_pack(0, 0, 0, $tv0, $t21);
    $t22 := $tmp;

    // return $t22
    $ret0 := $t22;
    if (true) { assume $DebugTrackLocal(15, 4106, 25, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraConfig_publish_new_config_with_capability($tv0: $TypeValue, config_account: $Value, payload: $Value) returns ($ret0: $Value)
free requires is#$Address(config_account);
free ensures !$abort_flag ==> (b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $tv0))))));
free ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($m, $txn, $tv0)));
{
    call $ret0 := $LibraConfig_publish_new_config_with_capability_def($tv0, config_account, payload);
}

procedure {:inline 1} $LibraConfig_publish_new_config_with_delegate_def($tv0: $TypeValue, config_account: $Value, payload: $Value, delegate: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $tv0
    var $t25: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $tv0
    var $t28: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 5535, 0, config_account); }
    if (true) { assume $DebugTrackLocal(15, 5535, 1, payload); }
    if (true) { assume $DebugTrackLocal(15, 5535, 2, delegate); }

    // bytecode translation starts here
    // $t26 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t26 := $tmp;

    // $t27 := move(payload)
    call $tmp := $CopyOrMoveValue(payload);
    $t27 := $tmp;

    // $t28 := move(delegate)
    call $tmp := $CopyOrMoveValue(delegate);
    $t28 := $tmp;

    // $t7 := copy($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t7 := $tmp;

    // $t8 := Roles::has_on_chain_config_privilege($t7)
    call $t8 := $Roles_has_on_chain_config_privilege($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5713);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t3 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 5699, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := 5
    $tmp := $Integer(5);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(15, 5699); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t12 := $tmp;

    // $t13 := Signer::address_of($t12)
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5806);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t14 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5851);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := ==($t13, $t14)
    $tmp := $Boolean($IsEqual($t13, $t14));
    $t15 := $tmp;

    // $t5 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 5791, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t17 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t17 := $tmp;

    // destroy($t17)

    // $t18 := 2
    $tmp := $Integer(2);
    $t18 := $tmp;

    // abort($t18)
    if (true) { assume $DebugTrackAbort(15, 5791); }
    goto Abort;

    // L2:
L2:

    // $t19 := copy($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t19 := $tmp;

    // $t20 := false
    $tmp := $Boolean(false);
    $t20 := $tmp;

    // $t21 := pack LibraConfig::ModifyConfigCapability<#0>($t20)
    call $tmp := $LibraConfig_ModifyConfigCapability_pack(0, 0, 0, $tv0, $t20);
    $t21 := $tmp;

    // Offer::create<LibraConfig::ModifyConfigCapability<#0>>($t19, $t21, $t28)
    call $Offer_create($LibraConfig_ModifyConfigCapability_type_value($tv0), $t19, $t21, $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5917);
      goto Abort;
    }

    // $t23 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t23 := $tmp;

    // $t25 := pack LibraConfig::LibraConfig<#0>($t27)
    call $tmp := $LibraConfig_LibraConfig_pack(0, 0, 0, $tv0, $t27);
    $t25 := $tmp;

    // move_to<LibraConfig::LibraConfig<#0>>($t25, $t23)
    call $MoveTo($LibraConfig_LibraConfig_type_value($tv0), $t25, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 5993);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_publish_new_config_with_delegate($tv0: $TypeValue, config_account: $Value, payload: $Value, delegate: $Value) returns ()
free requires is#$Address(config_account);
free requires is#$Address(delegate);
{
    call $LibraConfig_publish_new_config_with_delegate_def($tv0, config_account, payload, delegate);
}

procedure {:inline 1} $LibraConfig_publish_new_treasury_compliance_config_def($tv0: $TypeValue, config_account: $Value, tc_account: $Value, payload: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $tv0
    var $t13: $Value; // $LibraConfig_LibraConfig_type_value($tv0)
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 4219, 0, config_account); }
    if (true) { assume $DebugTrackLocal(15, 4219, 1, tc_account); }
    if (true) { assume $DebugTrackLocal(15, 4219, 2, payload); }

    // bytecode translation starts here
    // $t17 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t17 := $tmp;

    // $t18 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t18 := $tmp;

    // $t19 := move(payload)
    call $tmp := $CopyOrMoveValue(payload);
    $t19 := $tmp;

    // $t5 := copy($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;

    // $t6 := Roles::has_on_chain_config_privilege($t5)
    call $t6 := $Roles_has_on_chain_config_privilege($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 4405);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 4391, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t18)
    call $tmp := $CopyOrMoveValue($t18);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 5
    $tmp := $Integer(5);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(15, 4391); }
    goto Abort;

    // L0:
L0:

    // $t11 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t11 := $tmp;

    // $t13 := pack LibraConfig::LibraConfig<#0>($t19)
    call $tmp := $LibraConfig_LibraConfig_pack(0, 0, 0, $tv0, $t19);
    $t13 := $tmp;

    // move_to<LibraConfig::LibraConfig<#0>>($t13, $t11)
    call $MoveTo($LibraConfig_LibraConfig_type_value($tv0), $t13, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 4483);
      goto Abort;
    }

    // $t14 := move($t18)
    call $tmp := $CopyOrMoveValue($t18);
    $t14 := $tmp;

    // $t15 := false
    $tmp := $Boolean(false);
    $t15 := $tmp;

    // $t16 := pack LibraConfig::ModifyConfigCapability<#0>($t15)
    call $tmp := $LibraConfig_ModifyConfigCapability_pack(0, 0, 0, $tv0, $t15);
    $t16 := $tmp;

    // move_to<LibraConfig::ModifyConfigCapability<#0>>($t16, $t14)
    call $MoveTo($LibraConfig_ModifyConfigCapability_type_value($tv0), $t16, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 4541);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_publish_new_treasury_compliance_config($tv0: $TypeValue, config_account: $Value, tc_account: $Value, payload: $Value) returns ()
free requires is#$Address(config_account);
free requires is#$Address(tc_account);
{
    call $LibraConfig_publish_new_treasury_compliance_config_def($tv0, config_account, tc_account, payload);
}

procedure {:inline 1} $LibraConfig_reconfigure_def(lr_account: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 6617, 0, lr_account); }

    // bytecode translation starts here
    // $t7 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t7 := $tmp;

    // $t3 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;

    // $t4 := Roles::has_libra_root_role($t3)
    call $t4 := $Roles_has_libra_root_role($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 6796);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // $t1 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 6782, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t6 := 1
    $tmp := $Integer(1);
    $t6 := $tmp;

    // abort($t6)
    if (true) { assume $DebugTrackAbort(15, 6782); }
    goto Abort;

    // L0:
L0:

    // LibraConfig::reconfigure_()
    call $LibraConfig_reconfigure_();
    assume $abort_flag == false;

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_reconfigure(lr_account: $Value) returns ()
free requires is#$Address(lr_account);
{
    call $LibraConfig_reconfigure_def(lr_account);
}

procedure {:inline 1} $LibraConfig_reconfigure__def() returns (){
    // declare local variables
    var config_ref: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var current_block_time: $Value; // $IntegerType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $t6: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Reference; // ReferenceType($LibraConfig_Configuration_type_value())
    var $t18: $Reference; // ReferenceType($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t4 := LibraTimestamp::is_not_initialized()
    call $t4 := $LibraTimestamp_is_not_initialized();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 7056);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // return ()
    return;

    // L2:
L2:

    // $t5 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t5 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 7184);
      goto Abort;
    }
    assume is#$Address($t5);


    // $t6 := borrow_global<LibraConfig::Configuration>($t5)
    call $t6 := $BorrowGlobal($t5, $LibraConfig_Configuration_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 7136);
      goto Abort;
    }
    assume $LibraConfig_Configuration_is_well_formed($Dereference($t6));

    // UnpackRef($t6)

    // config_ref := $t6
    call config_ref := $CopyOrMoveRef($t6);
    if (true) { assume $DebugTrackLocal(15, 7123, 0, $Dereference(config_ref)); }

    // $t7 := LibraTimestamp::now_microseconds()
    call $t7 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 7458);
      goto Abort;
    }
    assume $IsValidU64($t7);


    // current_block_time := $t7
    call $tmp := $CopyOrMoveValue($t7);
    current_block_time := $tmp;
    if (true) { assume $DebugTrackLocal(15, 7421, 1, $tmp); }

    // $t9 := copy(config_ref)
    call $t9 := $CopyOrMoveRef(config_ref);

    // $t10 := get_field<LibraConfig::Configuration>.last_reconfiguration_time($t9)
    call $tmp := $GetFieldFromReference($t9, $LibraConfig_Configuration_last_reconfiguration_time);
    assume $IsValidU64($tmp);
    $t10 := $tmp;

    // Reference(config_ref) <- $t9
    call config_ref := $WritebackToReference($t9, config_ref);

    // $t11 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;

    // $t12 := >(current_block_time, $t11)
    call $tmp := $Gt(current_block_time, $t11);
    $t12 := $tmp;

    // $t2 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 7485, 2, $tmp); }

    // if ($t2) goto L3 else goto L4
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // $t14 := move(config_ref)
    call $t14 := $CopyOrMoveRef(config_ref);

    // destroy($t14)

    // LibraConfig::Configuration <- $t14
    call $WritebackToGlobal($t14);

    // PackRef($t14)

    // $t15 := 6
    $tmp := $Integer(6);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(15, 7485); }
    goto Abort;

    // L3:
L3:

    // $t17 := move(config_ref)
    call $t17 := $CopyOrMoveRef(config_ref);

    // $t18 := borrow_field<LibraConfig::Configuration>.last_reconfiguration_time($t17)
    call $t18 := $BorrowField($t17, $LibraConfig_Configuration_last_reconfiguration_time);
    assume $IsValidU64($Dereference($t18));

    // LibraConfig::Configuration <- $t17
    call $WritebackToGlobal($t17);

    // UnpackRef($t18)

    // write_ref($t18, current_block_time)
    call $t18 := $WriteRef($t18, current_block_time);
    if (true) { assume $DebugTrackLocal(15, 7580, 0, $Dereference(config_ref)); }

    // LibraConfig::Configuration <- $t18
    call $WritebackToGlobal($t18);

    // Reference($t17) <- $t18
    call $t17 := $WritebackToReference($t18, $t17);

    // PackRef($t17)

    // PackRef($t18)

    // LibraConfig::emit_reconfiguration_event()
    call $LibraConfig_emit_reconfiguration_event();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 8590);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_reconfigure_() returns ()
{
    call $LibraConfig_reconfigure__def();
}

procedure {:inline 1} $LibraConfig_set_def($tv0: $TypeValue, account: $Value, payload: $Value) returns (){
    // declare local variables
    var addr: $Value; // $AddressType()
    var config: $Reference; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var signer_address: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $AddressType()
    var $t22: $Reference; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var $t23: $Value; // $tv0
    var $t24: $Reference; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var $t25: $Reference; // ReferenceType($tv0)
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 2192, 0, account); }
    if (true) { assume $DebugTrackLocal(15, 2192, 1, payload); }

    // bytecode translation starts here
    // $t26 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t26 := $tmp;

    // $t27 := move(payload)
    call $tmp := $CopyOrMoveValue(payload);
    $t27 := $tmp;

    // $t9 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 2336);
      goto Abort;
    }
    assume is#$Address($t9);


    // addr := $t9
    call $tmp := $CopyOrMoveValue($t9);
    addr := $tmp;
    if (true) { assume $DebugTrackLocal(15, 2314, 2, $tmp); }

    // $t11 := exists<LibraConfig::LibraConfig<#0>>(addr)
    call $tmp := $Exists(addr, $LibraConfig_LibraConfig_type_value($tv0));
    $t11 := $tmp;

    // $t5 := $t11
    call $tmp := $CopyOrMoveValue($t11);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 2366, 5, $tmp); }

    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t13 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t13 := $tmp;

    // destroy($t13)

    // $t14 := 3
    $tmp := $Integer(3);
    $t14 := $tmp;

    // abort($t14)
    if (true) { assume $DebugTrackAbort(15, 2366); }
    goto Abort;

    // L0:
L0:

    // $t15 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t15 := $tmp;

    // $t16 := Signer::address_of($t15)
    call $t16 := $Signer_address_of($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 2470);
      goto Abort;
    }
    assume is#$Address($t16);


    // signer_address := $t16
    call $tmp := $CopyOrMoveValue($t16);
    signer_address := $tmp;
    if (true) { assume $DebugTrackLocal(15, 2445, 4, $tmp); }

    // $t18 := exists<LibraConfig::ModifyConfigCapability<#0>>(signer_address)
    call $tmp := $Exists(signer_address, $LibraConfig_ModifyConfigCapability_type_value($tv0));
    $t18 := $tmp;

    // $t7 := $t18
    call $tmp := $CopyOrMoveValue($t18);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 2499, 7, $tmp); }

    // if ($t7) goto L2 else goto L3
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t20 := 4
    $tmp := $Integer(4);
    $t20 := $tmp;

    // abort($t20)
    if (true) { assume $DebugTrackAbort(15, 2499); }
    goto Abort;

    // L2:
L2:

    // $t22 := borrow_global<LibraConfig::LibraConfig<#0>>(addr)
    call $t22 := $BorrowGlobal(addr, $LibraConfig_LibraConfig_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 2614);
      goto Abort;
    }
    assume $LibraConfig_LibraConfig_is_well_formed($Dereference($t22));

    // UnpackRef($t22)

    // config := $t22
    call config := $CopyOrMoveRef($t22);
    if (true) { assume $DebugTrackLocal(15, 2605, 3, $Dereference(config)); }

    // $t24 := move(config)
    call $t24 := $CopyOrMoveRef(config);

    // $t25 := borrow_field<LibraConfig::LibraConfig<#0>>.payload($t24)
    call $t25 := $BorrowField($t24, $LibraConfig_LibraConfig_payload);

    // LibraConfig::LibraConfig <- $t24
    call $WritebackToGlobal($t24);

    // UnpackRef($t25)

    // write_ref($t25, $t27)
    call $t25 := $WriteRef($t25, $t27);
    if (true) { assume $DebugTrackLocal(15, 2668, 3, $Dereference(config)); }

    // LibraConfig::LibraConfig <- $t25
    call $WritebackToGlobal($t25);

    // Reference($t24) <- $t25
    call $t24 := $WritebackToReference($t25, $t24);

    // PackRef($t24)

    // PackRef($t25)

    // LibraConfig::reconfigure_()
    call $LibraConfig_reconfigure_();
    assume $abort_flag == false;

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_set($tv0: $TypeValue, account: $Value, payload: $Value) returns ()
free requires is#$Address(account);
{
    call $LibraConfig_set_def($tv0, account, payload);
}

procedure {:inline 1} $LibraConfig_set_with_capability_def($tv0: $TypeValue, _cap: $Value, payload: $Value) returns (){
    // declare local variables
    var addr: $Value; // $AddressType()
    var config: $Reference; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Reference; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var $t13: $Value; // $tv0
    var $t14: $Reference; // ReferenceType($LibraConfig_LibraConfig_type_value($tv0))
    var $t15: $Reference; // ReferenceType($tv0)
    var $t16: $Value; // $LibraConfig_ModifyConfigCapability_type_value($tv0)
    var $t17: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(15, 2801, 0, _cap); }
    if (true) { assume $DebugTrackLocal(15, 2801, 1, payload); }

    // bytecode translation starts here
    // $t16 := move(_cap)
    call $tmp := $CopyOrMoveValue(_cap);
    $t16 := $tmp;

    // $t17 := move(payload)
    call $tmp := $CopyOrMoveValue(payload);
    $t17 := $tmp;

    // $t6 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t6 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 3000);
      goto Abort;
    }
    assume is#$Address($t6);


    // addr := $t6
    call $tmp := $CopyOrMoveValue($t6);
    addr := $tmp;
    if (true) { assume $DebugTrackLocal(15, 2978, 2, $tmp); }

    // $t8 := exists<LibraConfig::LibraConfig<#0>>(addr)
    call $tmp := $Exists(addr, $LibraConfig_LibraConfig_type_value($tv0));
    $t8 := $tmp;

    // $t4 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(15, 3030, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := 3
    $tmp := $Integer(3);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(15, 3030); }
    goto Abort;

    // L0:
L0:

    // $t12 := borrow_global<LibraConfig::LibraConfig<#0>>(addr)
    call $t12 := $BorrowGlobal(addr, $LibraConfig_LibraConfig_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(15, 3118);
      goto Abort;
    }
    assume $LibraConfig_LibraConfig_is_well_formed($Dereference($t12));

    // UnpackRef($t12)

    // config := $t12
    call config := $CopyOrMoveRef($t12);
    if (true) { assume $DebugTrackLocal(15, 3109, 3, $Dereference(config)); }

    // $t14 := move(config)
    call $t14 := $CopyOrMoveRef(config);

    // $t15 := borrow_field<LibraConfig::LibraConfig<#0>>.payload($t14)
    call $t15 := $BorrowField($t14, $LibraConfig_LibraConfig_payload);

    // LibraConfig::LibraConfig <- $t14
    call $WritebackToGlobal($t14);

    // UnpackRef($t15)

    // write_ref($t15, $t17)
    call $t15 := $WriteRef($t15, $t17);
    if (true) { assume $DebugTrackLocal(15, 3172, 3, $Dereference(config)); }

    // LibraConfig::LibraConfig <- $t15
    call $WritebackToGlobal($t15);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // PackRef($t14)

    // PackRef($t15)

    // LibraConfig::reconfigure_()
    call $LibraConfig_reconfigure_();
    assume $abort_flag == false;

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraConfig_set_with_capability($tv0: $TypeValue, _cap: $Value, payload: $Value) returns ()
free requires $LibraConfig_ModifyConfigCapability_is_well_formed(_cap);
{
    call $LibraConfig_set_with_capability_def($tv0, _cap, payload);
}



// ** spec vars of module RegisteredCurrencies



// ** spec funs of module RegisteredCurrencies

function {:inline} $RegisteredCurrencies_get_currency_codes($m: $Memory, $txn: $Transaction): $Value {
    $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes)
}



// ** structs of module RegisteredCurrencies

const unique $RegisteredCurrencies_RegisteredCurrencies: $TypeName;
const $RegisteredCurrencies_RegisteredCurrencies_currency_codes: $FieldName;
axiom $RegisteredCurrencies_RegisteredCurrencies_currency_codes == 0;
function $RegisteredCurrencies_RegisteredCurrencies_type_value(): $TypeValue {
    $StructType($RegisteredCurrencies_RegisteredCurrencies, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($Vector_type_value($IntegerType()))], 1))
}
function {:inline} $RegisteredCurrencies_RegisteredCurrencies_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_is_well_formed($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) && (forall $$0: int :: {$select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) ==> $Vector_is_well_formed($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)) && (forall $$1: int :: {$select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)) ==> $IsValidU8($select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0),$$1))))
}
function {:inline} $RegisteredCurrencies_RegisteredCurrencies_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_is_well_formed($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) && (forall $$0: int :: {$select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes)) ==> $Vector_is_well_formed($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)) && (forall $$1: int :: {$select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0)) ==> $IsValidU8($select_vector($select_vector($SelectField($this, $RegisteredCurrencies_RegisteredCurrencies_currency_codes),$$0),$$1))))
}

procedure {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_pack($file_id: int, $byte_index: int, $var_idx: int, currency_codes: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(currency_codes) && (forall $$0: int :: {$select_vector(currency_codes,$$0)} $$0 >= 0 && $$0 < $vlen(currency_codes) ==> $Vector_is_well_formed($select_vector(currency_codes,$$0)) && (forall $$1: int :: {$select_vector($select_vector(currency_codes,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(currency_codes,$$0)) ==> $IsValidU8($select_vector($select_vector(currency_codes,$$0),$$1))));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_codes], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $RegisteredCurrencies_RegisteredCurrencies_unpack($struct: $Value) returns (currency_codes: $Value)
{
    assume is#$Vector($struct);
    currency_codes := $SelectField($struct, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    assume $Vector_is_well_formed(currency_codes) && (forall $$0: int :: {$select_vector(currency_codes,$$0)} $$0 >= 0 && $$0 < $vlen(currency_codes) ==> $Vector_is_well_formed($select_vector(currency_codes,$$0)) && (forall $$1: int :: {$select_vector($select_vector(currency_codes,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector(currency_codes,$$0)) ==> $IsValidU8($select_vector($select_vector(currency_codes,$$0),$$1))));
}

const unique $RegisteredCurrencies_RegistrationCapability: $TypeName;
const $RegisteredCurrencies_RegistrationCapability_cap: $FieldName;
axiom $RegisteredCurrencies_RegistrationCapability_cap == 0;
function $RegisteredCurrencies_RegistrationCapability_type_value(): $TypeValue {
    $StructType($RegisteredCurrencies_RegistrationCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LibraConfig_ModifyConfigCapability_type_value($RegisteredCurrencies_RegisteredCurrencies_type_value())], 1))
}
function {:inline} $RegisteredCurrencies_RegistrationCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $LibraConfig_ModifyConfigCapability_is_well_formed_types($SelectField($this, $RegisteredCurrencies_RegistrationCapability_cap))
}
function {:inline} $RegisteredCurrencies_RegistrationCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $LibraConfig_ModifyConfigCapability_is_well_formed($SelectField($this, $RegisteredCurrencies_RegistrationCapability_cap))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $RegisteredCurrencies_RegistrationCapability_is_well_formed($ResourceValue(m, $RegisteredCurrencies_RegistrationCapability_type_value(), a))
);

procedure {:inline 1} $RegisteredCurrencies_RegistrationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, cap: $Value) returns ($struct: $Value)
{
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := cap], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $RegisteredCurrencies_RegistrationCapability_unpack($struct: $Value) returns (cap: $Value)
{
    assume is#$Vector($struct);
    cap := $SelectField($struct, $RegisteredCurrencies_RegistrationCapability_cap);
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(cap);
}



// ** functions of module RegisteredCurrencies

procedure {:inline 1} $RegisteredCurrencies_initialize_def(config_account: $Value) returns ($ret0: $Value){
    // declare local variables
    var cap: $Value; // $LibraConfig_ModifyConfigCapability_type_value($RegisteredCurrencies_RegisteredCurrencies_type_value())
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t19: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()
    var $t20: $Value; // $LibraConfig_ModifyConfigCapability_type_value($RegisteredCurrencies_RegisteredCurrencies_type_value())
    var $t21: $Value; // $LibraConfig_ModifyConfigCapability_type_value($RegisteredCurrencies_RegisteredCurrencies_type_value())
    var $t22: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t23: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 937, 0, config_account); }

    // bytecode translation starts here
    // $t23 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t23 := $tmp;

    // $t6 := LibraTimestamp::is_genesis()
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1056);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t2 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(20, 1033, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(20, 1033); }
    goto Abort;

    // L0:
L0:

    // $t10 := copy($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1122);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1167);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t4 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(20, 1094, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t15 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 1
    $tmp := $Integer(1);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(20, 1094); }
    goto Abort;

    // L2:
L2:

    // $t17 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t17 := $tmp;

    // $t18 := Vector::empty<vector<u8>>()
    call $t18 := $Vector_empty($Vector_type_value($IntegerType()));
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1393);
      goto Abort;
    }
    assume $Vector_is_well_formed($t18) && (forall $$0: int :: {$select_vector($t18,$$0)} $$0 >= 0 && $$0 < $vlen($t18) ==> $Vector_is_well_formed($select_vector($t18,$$0)) && (forall $$1: int :: {$select_vector($select_vector($t18,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($t18,$$0)) ==> $IsValidU8($select_vector($select_vector($t18,$$0),$$1))));


    // $t19 := pack RegisteredCurrencies::RegisteredCurrencies($t18)
    call $tmp := $RegisteredCurrencies_RegisteredCurrencies_pack(0, 0, 0, $t18);
    $t19 := $tmp;

    // $t20 := LibraConfig::publish_new_config_with_capability<RegisteredCurrencies::RegisteredCurrencies>($t17, $t19)
    call $t20 := $LibraConfig_publish_new_config_with_capability($RegisteredCurrencies_RegisteredCurrencies_type_value(), $t17, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 1270);
      goto Abort;
    }
    assume $LibraConfig_ModifyConfigCapability_is_well_formed($t20);


    // cap := $t20
    call $tmp := $CopyOrMoveValue($t20);
    cap := $tmp;
    if (true) { assume $DebugTrackLocal(20, 1251, 1, $tmp); }

    // $t22 := pack RegisteredCurrencies::RegistrationCapability(cap)
    call $tmp := $RegisteredCurrencies_RegistrationCapability_pack(0, 0, 0, cap);
    $t22 := $tmp;

    // return $t22
    $ret0 := $t22;
    if (true) { assume $DebugTrackLocal(20, 1423, 24, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $RegisteredCurrencies_initialize(config_account: $Value) returns ($ret0: $Value)
free requires is#$Address(config_account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))
    || b#$Boolean($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, config_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))
    || b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))
    || b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))));
free ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, config_account), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())))) ==> $abort_flag;
free ensures b#$Boolean(old($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn))))) ==> $abort_flag;
free ensures !$abort_flag ==> (b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value())));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($vlen_value($RegisteredCurrencies_get_currency_codes($m, $txn)), $Integer(0)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value())))));
{
    call $ret0 := $RegisteredCurrencies_initialize_def(config_account);
}

procedure {:inline 1} $RegisteredCurrencies_add_currency_code_def(currency_code: $Value, cap: $Value) returns (){
    // declare local variables
    var config: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()
    var $t6: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()
    var $t7: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t13: $Value; // $IntegerType()
    var $t14: $Reference; // ReferenceType($RegisteredCurrencies_RegisteredCurrencies_type_value())
    var $t15: $Reference; // ReferenceType($Vector_type_value($Vector_type_value($IntegerType())))
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t18: $Value; // $LibraConfig_ModifyConfigCapability_type_value($RegisteredCurrencies_RegisteredCurrencies_type_value())
    var $t19: $Value; // $RegisteredCurrencies_RegisteredCurrencies_type_value()
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $t21: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t22: $Value; // $Vector_type_value($Vector_type_value($IntegerType()))
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(20, 2225, 0, currency_code); }
    if (true) { assume $DebugTrackLocal(20, 2225, 1, cap); }

    // bytecode translation starts here
    // $t20 := move(currency_code)
    call $tmp := $CopyOrMoveValue(currency_code);
    $t20 := $tmp;

    // $t21 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t21 := $tmp;

    // $t5 := LibraConfig::get<RegisteredCurrencies::RegisteredCurrencies>()
    call $t5 := $LibraConfig_get($RegisteredCurrencies_RegisteredCurrencies_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2370);
      goto Abort;
    }
    assume $RegisteredCurrencies_RegisteredCurrencies_is_well_formed($t5);


    // config := $t5
    call $tmp := $CopyOrMoveValue($t5);
    config := $tmp;
    if (true) { assume $DebugTrackLocal(20, 2348, 2, $tmp); }

    // $t6 := copy(config)
    call $tmp := $CopyOrMoveValue(config);
    $t6 := $tmp;

    // $t7 := get_field<RegisteredCurrencies::RegisteredCurrencies>.currency_codes($t6)
    call $tmp := $GetFieldFromValue($t6, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $Vector_is_well_formed($select_vector($tmp,$$0)) && (forall $$1: int :: {$select_vector($select_vector($tmp,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($tmp,$$0)) ==> $IsValidU8($select_vector($select_vector($tmp,$$0),$$1))));
    $t7 := $tmp;

    // $t8 := copy($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t8 := $tmp;

    // $t9 := Vector::contains<vector<u8>>($t7, $t8)
    call $t9 := $Vector_contains($Vector_type_value($IntegerType()), $t7, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2436);
      goto Abort;
    }
    assume is#$Boolean($t9);


    // $t10 := !($t9)
    call $tmp := $Not($t9);
    $t10 := $tmp;

    // $t3 := $t10
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(20, 2407, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t12 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t12 := $tmp;

    // destroy($t12)

    // $t13 := 2
    $tmp := $Integer(2);
    $t13 := $tmp;

    // abort($t13)
    if (true) { assume $DebugTrackAbort(20, 2407); }
    goto Abort;

    // L0:
L0:

    // $t14 := borrow_local(config)
    call $t14 := $BorrowLoc(2, config);
    assume $RegisteredCurrencies_RegisteredCurrencies_is_well_formed($Dereference($t14));

    // UnpackRef($t14)

    // $t15 := borrow_field<RegisteredCurrencies::RegisteredCurrencies>.currency_codes($t14)
    call $t15 := $BorrowField($t14, $RegisteredCurrencies_RegisteredCurrencies_currency_codes);
    assume $Vector_is_well_formed($Dereference($t15)) && (forall $$1: int :: {$select_vector($Dereference($t15),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t15)) ==> $Vector_is_well_formed($select_vector($Dereference($t15),$$1)) && (forall $$2: int :: {$select_vector($select_vector($Dereference($t15),$$1),$$2)} $$2 >= 0 && $$2 < $vlen($select_vector($Dereference($t15),$$1)) ==> $IsValidU8($select_vector($select_vector($Dereference($t15),$$1),$$2))));

    // LocalRoot(config) <- $t14
    call config := $WritebackToValue($t14, 2, config);

    // UnpackRef($t15)

    // PackRef($t15)

    // $t22 := read_ref($t15)
    call $tmp := $ReadRef($t15);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $Vector_is_well_formed($select_vector($tmp,$$0)) && (forall $$1: int :: {$select_vector($select_vector($tmp,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($tmp,$$0)) ==> $IsValidU8($select_vector($select_vector($tmp,$$0),$$1))));
    $t22 := $tmp;

    // $t22 := Vector::push_back<vector<u8>>($t22, $t20)
    call $t22 := $Vector_push_back($Vector_type_value($IntegerType()), $t22, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2554);
      goto Abort;
    }
    assume $Vector_is_well_formed($t22) && (forall $$0: int :: {$select_vector($t22,$$0)} $$0 >= 0 && $$0 < $vlen($t22) ==> $Vector_is_well_formed($select_vector($t22,$$0)) && (forall $$1: int :: {$select_vector($select_vector($t22,$$0),$$1)} $$1 >= 0 && $$1 < $vlen($select_vector($t22,$$0)) ==> $IsValidU8($select_vector($select_vector($t22,$$0),$$1))));


    // write_ref($t15, $t22)
    call $t15 := $WriteRef($t15, $t22);

    // LocalRoot(config) <- $t15
    call config := $WritebackToValue($t15, 2, config);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // UnpackRef($t15)

    // PackRef($t14)

    // PackRef($t15)

    // $t17 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t17 := $tmp;

    // $t18 := get_field<RegisteredCurrencies::RegistrationCapability>.cap($t17)
    call $tmp := $GetFieldFromValue($t17, $RegisteredCurrencies_RegistrationCapability_cap);
    assume $LibraConfig_ModifyConfigCapability_is_well_formed($tmp);
    $t18 := $tmp;

    // LibraConfig::set_with_capability<RegisteredCurrencies::RegisteredCurrencies>($t18, config)
    call $LibraConfig_set_with_capability($RegisteredCurrencies_RegisteredCurrencies_type_value(), $t18, config);
    if ($abort_flag) {
      assume $DebugTrackAbort(20, 2629);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $RegisteredCurrencies_add_currency_code(currency_code: $Value, cap: $Value) returns ()
free requires $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
free requires $RegisteredCurrencies_RegistrationCapability_is_well_formed(cap);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))
    || b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))
    || b#$Boolean($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) ==> $abort_flag;
free ensures b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))))
    || b#$Boolean(old(($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code)))));
free ensures !$abort_flag ==> (b#$Boolean($Vector_eq_push_back($Vector_type_value($IntegerType()), $RegisteredCurrencies_get_currency_codes($m, $txn), old($RegisteredCurrencies_get_currency_codes($m, $txn)), currency_code)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value())))));
{
    call $RegisteredCurrencies_add_currency_code_def(currency_code, cap);
}



// ** spec vars of module FixedPoint32



// ** spec funs of module FixedPoint32

function {:inline} $FixedPoint32_spec_multiply_u64(val: $Value, multiplier: $Value): $Value;
axiom (forall val: $Value, multiplier: $Value :: $IsValidU64($FixedPoint32_spec_multiply_u64(val, multiplier)));
function {:inline} $FixedPoint32_spec_divide_u64(val: $Value, divisor: $Value): $Value;
axiom (forall val: $Value, divisor: $Value :: $IsValidU64($FixedPoint32_spec_divide_u64(val, divisor)));
function {:inline} $FixedPoint32_spec_create_from_rational(numerator: $Value, denominator: $Value): $Value;
axiom (forall numerator: $Value, denominator: $Value :: $FixedPoint32_FixedPoint32_is_well_formed($FixedPoint32_spec_create_from_rational(numerator, denominator)));


// ** structs of module FixedPoint32

const unique $FixedPoint32_FixedPoint32: $TypeName;
const $FixedPoint32_FixedPoint32_value: $FieldName;
axiom $FixedPoint32_FixedPoint32_value == 0;
function $FixedPoint32_FixedPoint32_type_value(): $TypeValue {
    $StructType($FixedPoint32_FixedPoint32, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $FixedPoint32_FixedPoint32_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $FixedPoint32_FixedPoint32_value))
}
function {:inline} $FixedPoint32_FixedPoint32_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $FixedPoint32_FixedPoint32_value))
}

procedure {:inline 1} $FixedPoint32_FixedPoint32_pack($file_id: int, $byte_index: int, $var_idx: int, value: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(value);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := value], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $FixedPoint32_FixedPoint32_unpack($struct: $Value) returns (value: $Value)
{
    assume is#$Vector($struct);
    value := $SelectField($struct, $FixedPoint32_FixedPoint32_value);
    assume $IsValidU64(value);
}



// ** functions of module FixedPoint32

procedure {:inline 1} $FixedPoint32_create_from_rational_def(numerator: $Value, denominator: $Value) returns ($ret0: $Value){
    // declare local variables
    var quotient: $Value; // $IntegerType()
    var scaled_denominator: $Value; // $IntegerType()
    var scaled_numerator: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(10, 3072, 0, numerator); }
    if (true) { assume $DebugTrackLocal(10, 3072, 1, denominator); }

    // bytecode translation starts here
    // $t32 := move(numerator)
    call $tmp := $CopyOrMoveValue(numerator);
    $t32 := $tmp;

    // $t33 := move(denominator)
    call $tmp := $CopyOrMoveValue(denominator);
    $t33 := $tmp;

    // $t9 := (u128)($t32)
    call $tmp := $CastU128($t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 3364);
      goto Abort;
    }
    $t9 := $tmp;

    // $t10 := 64
    $tmp := $Integer(64);
    $t10 := $tmp;

    // $t11 := <<($t9, $t10)
    call $tmp := $Shl($t9, $t10);
    $t11 := $tmp;

    // scaled_numerator := $t11
    call $tmp := $CopyOrMoveValue($t11);
    scaled_numerator := $tmp;
    if (true) { assume $DebugTrackLocal(10, 3345, 4, $tmp); }

    // $t13 := (u128)($t33)
    call $tmp := $CastU128($t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 3424);
      goto Abort;
    }
    $t13 := $tmp;

    // $t14 := 32
    $tmp := $Integer(32);
    $t14 := $tmp;

    // $t15 := <<($t13, $t14)
    call $tmp := $Shl($t13, $t14);
    $t15 := $tmp;

    // scaled_denominator := $t15
    call $tmp := $CopyOrMoveValue($t15);
    scaled_denominator := $tmp;
    if (true) { assume $DebugTrackLocal(10, 3403, 3, $tmp); }

    // $t18 := /(scaled_numerator, scaled_denominator)
    call $tmp := $Div(scaled_numerator, scaled_denominator);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 3587);
      goto Abort;
    }
    $t18 := $tmp;

    // quotient := $t18
    call $tmp := $CopyOrMoveValue($t18);
    quotient := $tmp;
    if (true) { assume $DebugTrackLocal(10, 3559, 2, $tmp); }

    // $t20 := 0
    $tmp := $Integer(0);
    $t20 := $tmp;

    // $t21 := !=(quotient, $t20)
    $tmp := $Boolean(!$IsEqual(quotient, $t20));
    $t21 := $tmp;

    // if ($t21) goto L0 else goto L1
    $tmp := $t21;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t22 := true
    $tmp := $Boolean(true);
    $t22 := $tmp;

    // $t7 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(10, 3730, 7, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t24 := 0
    $tmp := $Integer(0);
    $t24 := $tmp;

    // $t25 := ==($t32, $t24)
    $tmp := $Boolean($IsEqual($t32, $t24));
    $t25 := $tmp;

    // $t7 := $t25
    call $tmp := $CopyOrMoveValue($t25);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(10, 3730, 7, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // $t5 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(10, 3723, 5, $tmp); }

    // if ($t5) goto L4 else goto L5
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t28 := 0
    $tmp := $Integer(0);
    $t28 := $tmp;

    // abort($t28)
    if (true) { assume $DebugTrackAbort(10, 3723); }
    goto Abort;

    // L4:
L4:

    // $t30 := (u64)(quotient)
    call $tmp := $CastU64(quotient);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 3952);
      goto Abort;
    }
    $t30 := $tmp;

    // $t31 := pack FixedPoint32::FixedPoint32($t30)
    call $tmp := $FixedPoint32_FixedPoint32_pack(0, 0, 0, $t30);
    $t31 := $tmp;

    // return $t31
    $ret0 := $t31;
    if (true) { assume $DebugTrackLocal(10, 3930, 34, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $FixedPoint32_create_from_rational(numerator: $Value, denominator: $Value) returns ($ret0: $Value);
free requires $IsValidU64(numerator);
free requires $IsValidU64(denominator);
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_create_from_rational(numerator, denominator)))));
procedure {:inline 1} $FixedPoint32_create_from_raw_value_def(value: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t3: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(10, 4211, 0, value); }

    // bytecode translation starts here
    // $t3 := move(value)
    call $tmp := $CopyOrMoveValue(value);
    $t3 := $tmp;

    // $t2 := pack FixedPoint32::FixedPoint32($t3)
    call $tmp := $FixedPoint32_FixedPoint32_pack(0, 0, 0, $t3);
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(10, 4280, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $FixedPoint32_create_from_raw_value(value: $Value) returns ($ret0: $Value)
free requires $IsValidU64(value);
{
    call $ret0 := $FixedPoint32_create_from_raw_value_def(value);
}

procedure {:inline 1} $FixedPoint32_divide_u64_def(num: $Value, divisor: $Value) returns ($ret0: $Value){
    // declare local variables
    var quotient: $Value; // $IntegerType()
    var scaled_value: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(10, 2025, 0, num); }
    if (true) { assume $DebugTrackLocal(10, 2025, 1, divisor); }

    // bytecode translation starts here
    // $t16 := move(num)
    call $tmp := $CopyOrMoveValue(num);
    $t16 := $tmp;

    // $t17 := move(divisor)
    call $tmp := $CopyOrMoveValue(divisor);
    $t17 := $tmp;

    // $t5 := (u128)($t16)
    call $tmp := $CastU128($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 2230);
      goto Abort;
    }
    $t5 := $tmp;

    // $t6 := 32
    $tmp := $Integer(32);
    $t6 := $tmp;

    // $t7 := <<($t5, $t6)
    call $tmp := $Shl($t5, $t6);
    $t7 := $tmp;

    // scaled_value := $t7
    call $tmp := $CopyOrMoveValue($t7);
    scaled_value := $tmp;
    if (true) { assume $DebugTrackLocal(10, 2215, 3, $tmp); }

    // $t9 := copy($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t9 := $tmp;

    // $t10 := get_field<FixedPoint32::FixedPoint32>.value($t9)
    call $tmp := $GetFieldFromValue($t9, $FixedPoint32_FixedPoint32_value);
    assume $IsValidU64($tmp);
    $t10 := $tmp;

    // $t11 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;

    // $t12 := (u128)($t11)
    call $tmp := $CastU128($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 2344);
      goto Abort;
    }
    $t12 := $tmp;

    // $t13 := /(scaled_value, $t12)
    call $tmp := $Div(scaled_value, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 2342);
      goto Abort;
    }
    $t13 := $tmp;

    // quotient := $t13
    call $tmp := $CopyOrMoveValue($t13);
    quotient := $tmp;
    if (true) { assume $DebugTrackLocal(10, 2318, 2, $tmp); }

    // $t15 := (u64)(quotient)
    call $tmp := $CastU64(quotient);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 2487);
      goto Abort;
    }
    $t15 := $tmp;

    // return $t15
    $ret0 := $t15;
    if (true) { assume $DebugTrackLocal(10, 2487, 18, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $FixedPoint32_divide_u64(num: $Value, divisor: $Value) returns ($ret0: $Value);
free requires $IsValidU64(num);
free requires $FixedPoint32_FixedPoint32_is_well_formed(divisor);
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_divide_u64(num, divisor)))));
procedure {:inline 1} $FixedPoint32_get_raw_value_def(num: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(10, 4494, 0, num); }

    // bytecode translation starts here
    // $t4 := move(num)
    call $tmp := $CopyOrMoveValue(num);
    $t4 := $tmp;

    // $t1 := copy($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := get_field<FixedPoint32::FixedPoint32>.value($t1)
    call $tmp := $GetFieldFromValue($t1, $FixedPoint32_FixedPoint32_value);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(10, 4553, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $FixedPoint32_get_raw_value(num: $Value) returns ($ret0: $Value)
free requires $FixedPoint32_FixedPoint32_is_well_formed(num);
{
    call $ret0 := $FixedPoint32_get_raw_value_def(num);
}

procedure {:inline 1} $FixedPoint32_multiply_u64_def(num: $Value, multiplier: $Value) returns ($ret0: $Value){
    // declare local variables
    var product: $Value; // $IntegerType()
    var unscaled_product: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(10, 445, 0, num); }
    if (true) { assume $DebugTrackLocal(10, 445, 1, multiplier); }

    // bytecode translation starts here
    // $t16 := move(num)
    call $tmp := $CopyOrMoveValue(num);
    $t16 := $tmp;

    // $t17 := move(multiplier)
    call $tmp := $CopyOrMoveValue(multiplier);
    $t17 := $tmp;

    // $t5 := (u128)($t16)
    call $tmp := $CastU128($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 729);
      goto Abort;
    }
    $t5 := $tmp;

    // $t6 := copy($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t6 := $tmp;

    // $t7 := get_field<FixedPoint32::FixedPoint32>.value($t6)
    call $tmp := $GetFieldFromValue($t6, $FixedPoint32_FixedPoint32_value);
    assume $IsValidU64($tmp);
    $t7 := $tmp;

    // $t8 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t8 := $tmp;

    // $t9 := (u128)($t8)
    call $tmp := $CastU128($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 745);
      goto Abort;
    }
    $t9 := $tmp;

    // $t10 := *($t5, $t9)
    call $tmp := $MulU128($t5, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 743);
      goto Abort;
    }
    $t10 := $tmp;

    // unscaled_product := $t10
    call $tmp := $CopyOrMoveValue($t10);
    unscaled_product := $tmp;
    if (true) { assume $DebugTrackLocal(10, 710, 3, $tmp); }

    // $t12 := 32
    $tmp := $Integer(32);
    $t12 := $tmp;

    // $t13 := <<(unscaled_product, $t12)
    call $tmp := $Shr(unscaled_product, $t12);
    $t13 := $tmp;

    // product := $t13
    call $tmp := $CopyOrMoveValue($t13);
    product := $tmp;
    if (true) { assume $DebugTrackLocal(10, 918, 2, $tmp); }

    // $t15 := (u64)(product)
    call $tmp := $CastU64(product);
    if ($abort_flag) {
      assume $DebugTrackAbort(10, 1070);
      goto Abort;
    }
    $t15 := $tmp;

    // return $t15
    $ret0 := $t15;
    if (true) { assume $DebugTrackLocal(10, 1070, 18, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $FixedPoint32_multiply_u64(num: $Value, multiplier: $Value) returns ($ret0: $Value);
free requires $IsValidU64(num);
free requires $FixedPoint32_FixedPoint32_is_well_formed(multiplier);
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $FixedPoint32_spec_multiply_u64(num, multiplier)))));


// ** spec vars of module Libra

var $Libra_sum_of_coin_values : [$TypeValue]$Value where (forall $tv0: $TypeValue :: $IsValidNum($Libra_sum_of_coin_values[$tv0]));


// ** spec funs of module Libra

function {:inline} $Libra_spec_is_currency($m: $Memory, $txn: $Transaction, $tv0: $TypeValue): $Value {
    $ResourceExists($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_spec_currency_info($m: $Memory, $txn: $Transaction, $tv0: $TypeValue): $Value {
    $ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())
}

function {:inline} $Libra_spec_approx_lbr_for_value($m: $Memory, $txn: $Transaction, $tv0: $TypeValue, value: $Value): $Value {
    $FixedPoint32_spec_multiply_u64(value, $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_to_lbr_exchange_rate))
}



// ** structs of module Libra

const unique $Libra_Libra: $TypeName;
const $Libra_Libra_value: $FieldName;
axiom $Libra_Libra_value == 0;
function $Libra_Libra_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_Libra, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $Libra_Libra_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $Libra_Libra_value))
}
function {:inline} $Libra_Libra_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $Libra_Libra_value))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_Libra_is_well_formed($ResourceValue(m, $Libra_Libra_type_value($tv0), a))
);

procedure {:inline 1} $Libra_Libra_before_update_inv($tv0: $TypeValue, $before: $Value) {
    $Libra_sum_of_coin_values := $Libra_sum_of_coin_values[$tv0 := $Integer(i#$Integer($Libra_sum_of_coin_values[$tv0]) - i#$Integer($SelectField($before, $Libra_Libra_value)))];
}

procedure {:inline 1} $Libra_Libra_after_update_inv($tv0: $TypeValue, $after: $Value) {
    $Libra_sum_of_coin_values := $Libra_sum_of_coin_values[$tv0 := $Integer(i#$Integer($Libra_sum_of_coin_values[$tv0]) + i#$Integer($SelectField($after, $Libra_Libra_value)))];
}

procedure {:inline 1} $Libra_Libra_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, value: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(value);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := value], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
    $Libra_sum_of_coin_values := $Libra_sum_of_coin_values[$tv0 := $Integer(i#$Integer($Libra_sum_of_coin_values[$tv0]) + i#$Integer($SelectField($struct, $Libra_Libra_value)))];
}

procedure {:inline 1} $Libra_Libra_unpack($tv0: $TypeValue, $struct: $Value) returns (value: $Value)
{
    assume is#$Vector($struct);
    value := $SelectField($struct, $Libra_Libra_value);
    assume $IsValidU64(value);
    $Libra_sum_of_coin_values := $Libra_sum_of_coin_values[$tv0 := $Integer(i#$Integer($Libra_sum_of_coin_values[$tv0]) - i#$Integer($SelectField($struct, $Libra_Libra_value)))];
}

const unique $Libra_BurnCapability: $TypeName;
const $Libra_BurnCapability_dummy_field: $FieldName;
axiom $Libra_BurnCapability_dummy_field == 0;
function $Libra_BurnCapability_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_BurnCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $Libra_BurnCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_BurnCapability_dummy_field))
}
function {:inline} $Libra_BurnCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_BurnCapability_dummy_field))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_BurnCapability_is_well_formed($ResourceValue(m, $Libra_BurnCapability_type_value($tv0), a))
);

procedure {:inline 1} $Libra_BurnCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_BurnCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_BurnCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $Libra_BurnEvent: $TypeName;
const $Libra_BurnEvent_amount: $FieldName;
axiom $Libra_BurnEvent_amount == 0;
const $Libra_BurnEvent_currency_code: $FieldName;
axiom $Libra_BurnEvent_currency_code == 1;
const $Libra_BurnEvent_preburn_address: $FieldName;
axiom $Libra_BurnEvent_preburn_address == 2;
function $Libra_BurnEvent_type_value(): $TypeValue {
    $StructType($Libra_BurnEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())][2 := $AddressType()], 3))
}
function {:inline} $Libra_BurnEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_BurnEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_BurnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_BurnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_BurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_BurnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_BurnEvent_preburn_address))
}
function {:inline} $Libra_BurnEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_BurnEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_BurnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_BurnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_BurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_BurnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_BurnEvent_preburn_address))
}

procedure {:inline 1} $Libra_BurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_BurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_BurnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_BurnEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    preburn_address := $SelectField($struct, $Libra_BurnEvent_preburn_address);
    assume is#$Address(preburn_address);
}

const unique $Libra_CancelBurnEvent: $TypeName;
const $Libra_CancelBurnEvent_amount: $FieldName;
axiom $Libra_CancelBurnEvent_amount == 0;
const $Libra_CancelBurnEvent_currency_code: $FieldName;
axiom $Libra_CancelBurnEvent_currency_code == 1;
const $Libra_CancelBurnEvent_preburn_address: $FieldName;
axiom $Libra_CancelBurnEvent_preburn_address == 2;
function $Libra_CancelBurnEvent_type_value(): $TypeValue {
    $StructType($Libra_CancelBurnEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())][2 := $AddressType()], 3))
}
function {:inline} $Libra_CancelBurnEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_CancelBurnEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_CancelBurnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CancelBurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_CancelBurnEvent_preburn_address))
}
function {:inline} $Libra_CancelBurnEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_CancelBurnEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_CancelBurnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CancelBurnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CancelBurnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_CancelBurnEvent_preburn_address))
}

procedure {:inline 1} $Libra_CancelBurnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_CancelBurnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_CancelBurnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_CancelBurnEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    preburn_address := $SelectField($struct, $Libra_CancelBurnEvent_preburn_address);
    assume is#$Address(preburn_address);
}

const unique $Libra_CurrencyInfo: $TypeName;
const $Libra_CurrencyInfo_total_value: $FieldName;
axiom $Libra_CurrencyInfo_total_value == 0;
const $Libra_CurrencyInfo_preburn_value: $FieldName;
axiom $Libra_CurrencyInfo_preburn_value == 1;
const $Libra_CurrencyInfo_to_lbr_exchange_rate: $FieldName;
axiom $Libra_CurrencyInfo_to_lbr_exchange_rate == 2;
const $Libra_CurrencyInfo_is_synthetic: $FieldName;
axiom $Libra_CurrencyInfo_is_synthetic == 3;
const $Libra_CurrencyInfo_scaling_factor: $FieldName;
axiom $Libra_CurrencyInfo_scaling_factor == 4;
const $Libra_CurrencyInfo_fractional_part: $FieldName;
axiom $Libra_CurrencyInfo_fractional_part == 5;
const $Libra_CurrencyInfo_currency_code: $FieldName;
axiom $Libra_CurrencyInfo_currency_code == 6;
const $Libra_CurrencyInfo_can_mint: $FieldName;
axiom $Libra_CurrencyInfo_can_mint == 7;
const $Libra_CurrencyInfo_mint_events: $FieldName;
axiom $Libra_CurrencyInfo_mint_events == 8;
const $Libra_CurrencyInfo_burn_events: $FieldName;
axiom $Libra_CurrencyInfo_burn_events == 9;
const $Libra_CurrencyInfo_preburn_events: $FieldName;
axiom $Libra_CurrencyInfo_preburn_events == 10;
const $Libra_CurrencyInfo_cancel_burn_events: $FieldName;
axiom $Libra_CurrencyInfo_cancel_burn_events == 11;
const $Libra_CurrencyInfo_exchange_rate_update_events: $FieldName;
axiom $Libra_CurrencyInfo_exchange_rate_update_events == 12;
function $Libra_CurrencyInfo_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_CurrencyInfo, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $IntegerType()][2 := $FixedPoint32_FixedPoint32_type_value()][3 := $BooleanType()][4 := $IntegerType()][5 := $IntegerType()][6 := $Vector_type_value($IntegerType())][7 := $BooleanType()][8 := $Event_EventHandle_type_value($Libra_MintEvent_type_value())][9 := $Event_EventHandle_type_value($Libra_BurnEvent_type_value())][10 := $Event_EventHandle_type_value($Libra_PreburnEvent_type_value())][11 := $Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value())][12 := $Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value())], 13))
}
function {:inline} $Libra_CurrencyInfo_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 13
      && $IsValidU128($SelectField($this, $Libra_CurrencyInfo_total_value))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_preburn_value))
      && $FixedPoint32_FixedPoint32_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_to_lbr_exchange_rate))
      && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_is_synthetic))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_scaling_factor))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_fractional_part))
      && $Vector_is_well_formed($SelectField($this, $Libra_CurrencyInfo_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CurrencyInfo_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code),$$0)))
      && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_can_mint))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_mint_events))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_burn_events))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_preburn_events))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_cancel_burn_events))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $Libra_CurrencyInfo_exchange_rate_update_events))
}
function {:inline} $Libra_CurrencyInfo_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 13
      && $IsValidU128($SelectField($this, $Libra_CurrencyInfo_total_value))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_preburn_value))
      && $FixedPoint32_FixedPoint32_is_well_formed($SelectField($this, $Libra_CurrencyInfo_to_lbr_exchange_rate))
      && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_is_synthetic))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_scaling_factor))
      && $IsValidU64($SelectField($this, $Libra_CurrencyInfo_fractional_part))
      && $Vector_is_well_formed($SelectField($this, $Libra_CurrencyInfo_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_CurrencyInfo_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_CurrencyInfo_currency_code),$$0)))
      && is#$Boolean($SelectField($this, $Libra_CurrencyInfo_can_mint))
      && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_mint_events))
      && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_burn_events))
      && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_preburn_events))
      && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_cancel_burn_events))
      && $Event_EventHandle_is_well_formed($SelectField($this, $Libra_CurrencyInfo_exchange_rate_update_events))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_CurrencyInfo_is_well_formed($ResourceValue(m, $Libra_CurrencyInfo_type_value($tv0), a))
);

procedure {:inline 1} $Libra_CurrencyInfo_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value) returns ($struct: $Value)
{
    assume $IsValidU128(total_value);
    assume $IsValidU64(preburn_value);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    assume is#$Boolean(is_synthetic);
    assume $IsValidU64(scaling_factor);
    assume $IsValidU64(fractional_part);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Boolean(can_mint);
    assume $Event_EventHandle_is_well_formed(mint_events);
    assume $Event_EventHandle_is_well_formed(burn_events);
    assume $Event_EventHandle_is_well_formed(preburn_events);
    assume $Event_EventHandle_is_well_formed(cancel_burn_events);
    assume $Event_EventHandle_is_well_formed(exchange_rate_update_events);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := total_value][1 := preburn_value][2 := to_lbr_exchange_rate][3 := is_synthetic][4 := scaling_factor][5 := fractional_part][6 := currency_code][7 := can_mint][8 := mint_events][9 := burn_events][10 := preburn_events][11 := cancel_burn_events][12 := exchange_rate_update_events], 13));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_CurrencyInfo_unpack($tv0: $TypeValue, $struct: $Value) returns (total_value: $Value, preburn_value: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value, can_mint: $Value, mint_events: $Value, burn_events: $Value, preburn_events: $Value, cancel_burn_events: $Value, exchange_rate_update_events: $Value)
{
    assume is#$Vector($struct);
    total_value := $SelectField($struct, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128(total_value);
    preburn_value := $SelectField($struct, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64(preburn_value);
    to_lbr_exchange_rate := $SelectField($struct, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assume $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
    is_synthetic := $SelectField($struct, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean(is_synthetic);
    scaling_factor := $SelectField($struct, $Libra_CurrencyInfo_scaling_factor);
    assume $IsValidU64(scaling_factor);
    fractional_part := $SelectField($struct, $Libra_CurrencyInfo_fractional_part);
    assume $IsValidU64(fractional_part);
    currency_code := $SelectField($struct, $Libra_CurrencyInfo_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    can_mint := $SelectField($struct, $Libra_CurrencyInfo_can_mint);
    assume is#$Boolean(can_mint);
    mint_events := $SelectField($struct, $Libra_CurrencyInfo_mint_events);
    assume $Event_EventHandle_is_well_formed(mint_events);
    burn_events := $SelectField($struct, $Libra_CurrencyInfo_burn_events);
    assume $Event_EventHandle_is_well_formed(burn_events);
    preburn_events := $SelectField($struct, $Libra_CurrencyInfo_preburn_events);
    assume $Event_EventHandle_is_well_formed(preburn_events);
    cancel_burn_events := $SelectField($struct, $Libra_CurrencyInfo_cancel_burn_events);
    assume $Event_EventHandle_is_well_formed(cancel_burn_events);
    exchange_rate_update_events := $SelectField($struct, $Libra_CurrencyInfo_exchange_rate_update_events);
    assume $Event_EventHandle_is_well_formed(exchange_rate_update_events);
}

const unique $Libra_CurrencyRegistrationCapability: $TypeName;
const $Libra_CurrencyRegistrationCapability_cap: $FieldName;
axiom $Libra_CurrencyRegistrationCapability_cap == 0;
function $Libra_CurrencyRegistrationCapability_type_value(): $TypeValue {
    $StructType($Libra_CurrencyRegistrationCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $RegisteredCurrencies_RegistrationCapability_type_value()], 1))
}
function {:inline} $Libra_CurrencyRegistrationCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $RegisteredCurrencies_RegistrationCapability_is_well_formed_types($SelectField($this, $Libra_CurrencyRegistrationCapability_cap))
}
function {:inline} $Libra_CurrencyRegistrationCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $RegisteredCurrencies_RegistrationCapability_is_well_formed($SelectField($this, $Libra_CurrencyRegistrationCapability_cap))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_CurrencyRegistrationCapability_is_well_formed($ResourceValue(m, $Libra_CurrencyRegistrationCapability_type_value(), a))
);

procedure {:inline 1} $Libra_CurrencyRegistrationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, cap: $Value) returns ($struct: $Value)
{
    assume $RegisteredCurrencies_RegistrationCapability_is_well_formed(cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := cap], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_CurrencyRegistrationCapability_unpack($struct: $Value) returns (cap: $Value)
{
    assume is#$Vector($struct);
    cap := $SelectField($struct, $Libra_CurrencyRegistrationCapability_cap);
    assume $RegisteredCurrencies_RegistrationCapability_is_well_formed(cap);
}

const unique $Libra_MintCapability: $TypeName;
const $Libra_MintCapability_dummy_field: $FieldName;
axiom $Libra_MintCapability_dummy_field == 0;
function $Libra_MintCapability_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_MintCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $Libra_MintCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_MintCapability_dummy_field))
}
function {:inline} $Libra_MintCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_MintCapability_dummy_field))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_MintCapability_is_well_formed($ResourceValue(m, $Libra_MintCapability_type_value($tv0), a))
);

procedure {:inline 1} $Libra_MintCapability_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_MintCapability_unpack($tv0: $TypeValue, $struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_MintCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $Libra_MintEvent: $TypeName;
const $Libra_MintEvent_amount: $FieldName;
axiom $Libra_MintEvent_amount == 0;
const $Libra_MintEvent_currency_code: $FieldName;
axiom $Libra_MintEvent_currency_code == 1;
function $Libra_MintEvent_type_value(): $TypeValue {
    $StructType($Libra_MintEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())], 2))
}
function {:inline} $Libra_MintEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Libra_MintEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_MintEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_MintEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_MintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_MintEvent_currency_code),$$0)))
}
function {:inline} $Libra_MintEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $Libra_MintEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_MintEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_MintEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_MintEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_MintEvent_currency_code),$$0)))
}

procedure {:inline 1} $Libra_MintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_MintEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_MintEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_MintEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
}

const unique $Libra_Preburn: $TypeName;
const $Libra_Preburn_requests: $FieldName;
axiom $Libra_Preburn_requests == 0;
function $Libra_Preburn_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Libra_Preburn, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($Libra_Libra_type_value($tv0))], 1))
}
function {:inline} $Libra_Preburn_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_is_well_formed($SelectField($this, $Libra_Preburn_requests)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_Preburn_requests),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_Preburn_requests)) ==> $Libra_Libra_is_well_formed_types($select_vector($SelectField($this, $Libra_Preburn_requests),$$0)))
}
function {:inline} $Libra_Preburn_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_is_well_formed($SelectField($this, $Libra_Preburn_requests)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_Preburn_requests),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_Preburn_requests)) ==> $Libra_Libra_is_well_formed($select_vector($SelectField($this, $Libra_Preburn_requests),$$0)))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_Preburn_is_well_formed($ResourceValue(m, $Libra_Preburn_type_value($tv0), a))
);

procedure {:inline 1} $Libra_Preburn_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, requests: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(requests) && (forall $$0: int :: {$select_vector(requests,$$0)} $$0 >= 0 && $$0 < $vlen(requests) ==> $Libra_Libra_is_well_formed($select_vector(requests,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := requests], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_Preburn_unpack($tv0: $TypeValue, $struct: $Value) returns (requests: $Value)
{
    assume is#$Vector($struct);
    requests := $SelectField($struct, $Libra_Preburn_requests);
    assume $Vector_is_well_formed(requests) && (forall $$0: int :: {$select_vector(requests,$$0)} $$0 >= 0 && $$0 < $vlen(requests) ==> $Libra_Libra_is_well_formed($select_vector(requests,$$0)));
}

const unique $Libra_PreburnEvent: $TypeName;
const $Libra_PreburnEvent_amount: $FieldName;
axiom $Libra_PreburnEvent_amount == 0;
const $Libra_PreburnEvent_currency_code: $FieldName;
axiom $Libra_PreburnEvent_currency_code == 1;
const $Libra_PreburnEvent_preburn_address: $FieldName;
axiom $Libra_PreburnEvent_preburn_address == 2;
function $Libra_PreburnEvent_type_value(): $TypeValue {
    $StructType($Libra_PreburnEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())][2 := $AddressType()], 3))
}
function {:inline} $Libra_PreburnEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_PreburnEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_PreburnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_PreburnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_PreburnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_PreburnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_PreburnEvent_preburn_address))
}
function {:inline} $Libra_PreburnEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $IsValidU64($SelectField($this, $Libra_PreburnEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $Libra_PreburnEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_PreburnEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_PreburnEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_PreburnEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $Libra_PreburnEvent_preburn_address))
}

procedure {:inline 1} $Libra_PreburnEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, preburn_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(preburn_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := preburn_address], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_PreburnEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, preburn_address: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $Libra_PreburnEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $Libra_PreburnEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    preburn_address := $SelectField($struct, $Libra_PreburnEvent_preburn_address);
    assume is#$Address(preburn_address);
}

const unique $Libra_RegisterNewCurrency: $TypeName;
const $Libra_RegisterNewCurrency_dummy_field: $FieldName;
axiom $Libra_RegisterNewCurrency_dummy_field == 0;
function $Libra_RegisterNewCurrency_type_value(): $TypeValue {
    $StructType($Libra_RegisterNewCurrency, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $Libra_RegisterNewCurrency_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_RegisterNewCurrency_dummy_field))
}
function {:inline} $Libra_RegisterNewCurrency_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Libra_RegisterNewCurrency_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $Libra_RegisterNewCurrency_is_well_formed($ResourceValue(m, $Libra_RegisterNewCurrency_type_value(), a))
);

procedure {:inline 1} $Libra_RegisterNewCurrency_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_RegisterNewCurrency_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Libra_RegisterNewCurrency_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $Libra_ToLBRExchangeRateUpdateEvent: $TypeName;
const $Libra_ToLBRExchangeRateUpdateEvent_currency_code: $FieldName;
axiom $Libra_ToLBRExchangeRateUpdateEvent_currency_code == 0;
const $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate: $FieldName;
axiom $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate == 1;
function $Libra_ToLBRExchangeRateUpdateEvent_type_value(): $TypeValue {
    $StructType($Libra_ToLBRExchangeRateUpdateEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($IntegerType())][1 := $IntegerType()], 2))
}
function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $Vector_is_well_formed($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code),$$0)))
      && $IsValidU64($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate))
}
function {:inline} $Libra_ToLBRExchangeRateUpdateEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $Vector_is_well_formed($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_currency_code),$$0)))
      && $IsValidU64($SelectField($this, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate))
}

procedure {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_pack($file_id: int, $byte_index: int, $var_idx: int, currency_code: $Value, new_to_lbr_exchange_rate: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume $IsValidU64(new_to_lbr_exchange_rate);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := currency_code][1 := new_to_lbr_exchange_rate], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Libra_ToLBRExchangeRateUpdateEvent_unpack($struct: $Value) returns (currency_code: $Value, new_to_lbr_exchange_rate: $Value)
{
    assume is#$Vector($struct);
    currency_code := $SelectField($struct, $Libra_ToLBRExchangeRateUpdateEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    new_to_lbr_exchange_rate := $SelectField($struct, $Libra_ToLBRExchangeRateUpdateEvent_new_to_lbr_exchange_rate);
    assume $IsValidU64(new_to_lbr_exchange_rate);
}



// ** functions of module Libra

procedure {:inline 1} $Libra_initialize_def(config_account: $Value) returns (){
    // declare local variables
    var cap: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t21: $Value; // $Libra_CurrencyRegistrationCapability_type_value()
    var $t22: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 10463, 0, config_account); }

    // bytecode translation starts here
    // $t22 := move(config_account)
    call $tmp := $CopyOrMoveValue(config_account);
    $t22 := $tmp;

    // $t6 := LibraTimestamp::is_genesis()
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 10558);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t2 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 10535, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(14, 10535); }
    goto Abort;

    // L0:
L0:

    // $t10 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 10657);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 10702);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t4 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 10629, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t15 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 1
    $tmp := $Integer(1);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(14, 10629); }
    goto Abort;

    // L2:
L2:

    // $t17 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t17 := $tmp;

    // $t18 := RegisteredCurrencies::initialize($t17)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))));
    call $t18 := $RegisteredCurrencies_initialize($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 10814);
      goto Abort;
    }
    assume $RegisteredCurrencies_RegistrationCapability_is_well_formed($t18);


    // cap := $t18
    call $tmp := $CopyOrMoveValue($t18);
    cap := $tmp;
    if (true) { assume $DebugTrackLocal(14, 10786, 1, $tmp); }

    // $t19 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t19 := $tmp;

    // $t21 := pack Libra::CurrencyRegistrationCapability(cap)
    call $tmp := $Libra_CurrencyRegistrationCapability_pack(0, 0, 0, cap);
    $t21 := $tmp;

    // move_to<Libra::CurrencyRegistrationCapability>($t21, $t19)
    call $MoveTo($Libra_CurrencyRegistrationCapability_type_value(), $t21, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 10850);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_initialize(config_account: $Value) returns ()
free requires is#$Address(config_account);
{
    call $Libra_initialize_def(config_account);
}

procedure {:inline 1} $Libra_currency_code_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35975);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $GetGlobal($t0, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35922);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.currency_code($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_currency_code);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 35920, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_currency_code($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_currency_code_def($tv0);
}

procedure {:inline 1} $Libra_value_def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $Libra_Libra_type_value($tv0)
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 27049, 0, coin); }

    // bytecode translation starts here
    // $t4 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := get_field<Libra::Libra<#0>>.value($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_Libra_value);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 27115, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_value($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
free requires $Libra_Libra_is_well_formed(coin);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_value_def($tv0, coin);
}

procedure {:inline 1} $Libra_approx_lbr_for_coin_def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value){
    // declare local variables
    var from_value: $Value; // $IntegerType()
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 34265, 0, coin); }

    // bytecode translation starts here
    // $t6 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t6 := $tmp;

    // $t2 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;

    // $t3 := Libra::value<#0>($t2)
    call $t3 := $Libra_value($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 27060);
      goto Abort;
    }
    assume $IsValidU64($t3);


    // from_value := $t3
    call $tmp := $CopyOrMoveValue($t3);
    from_value := $tmp;
    if (true) { assume $DebugTrackLocal(14, 34383, 1, $tmp); }

    // $t5 := Libra::approx_lbr_for_value<#0>(from_value)
    call $t5 := $Libra_approx_lbr_for_value($tv0, from_value);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 33858);
      goto Abort;
    }
    assume $IsValidU64($t5);


    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(14, 34417, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_approx_lbr_for_coin($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value)
free requires $Libra_Libra_is_well_formed(coin);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_approx_lbr_for_coin_def($tv0, coin);
}

procedure {:inline 1} $Libra_approx_lbr_for_value_def($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value){
    // declare local variables
    var lbr_exchange_rate: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t2: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 33847, 0, from_value); }

    // bytecode translation starts here
    // $t6 := move(from_value)
    call $tmp := $CopyOrMoveValue(from_value);
    $t6 := $tmp;

    // $t2 := Libra::lbr_exchange_rate<#0>()
    call $t2 := $Libra_lbr_exchange_rate($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 37048);
      goto Abort;
    }
    assume $FixedPoint32_FixedPoint32_is_well_formed($t2);


    // lbr_exchange_rate := $t2
    call $tmp := $CopyOrMoveValue($t2);
    lbr_exchange_rate := $tmp;
    if (true) { assume $DebugTrackLocal(14, 33955, 1, $tmp); }

    // $t5 := FixedPoint32::multiply_u64($t6, lbr_exchange_rate)
    call $t5 := $FixedPoint32_multiply_u64($t6, lbr_exchange_rate);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 34032);
      goto Abort;
    }
    assume $IsValidU64($t5);


    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(14, 34018, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_approx_lbr_for_value($tv0: $TypeValue, from_value: $Value) returns ($ret0: $Value)
free requires $IsValidU64(from_value);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_approx_lbr_for_value_def($tv0, from_value);
}

procedure {:inline 1} $Libra_assert_is_currency_def($tv0: $TypeValue) returns (){
    // declare local variables
    var $t0: $Value; // $BooleanType()
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t2 := Libra::is_currency<#0>()
    call $t2 := $Libra_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 34593);
      goto Abort;
    }
    assume is#$Boolean($t2);


    // $t0 := $t2
    call $tmp := $CopyOrMoveValue($t2);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 38473, 0, $tmp); }

    // if ($t0) goto L0 else goto L1
    $tmp := $t0;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t4 := 8
    $tmp := $Integer(8);
    $t4 := $tmp;

    // abort($t4)
    if (true) { assume $DebugTrackAbort(14, 38473); }
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_assert_is_currency($tv0: $TypeValue) returns ()
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_assert_is_currency_def($tv0);
}

procedure {:inline 1} $Libra_burn_def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 12913, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 12913, 1, preburn_address); }

    // bytecode translation starts here
    // $t6 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t6 := $tmp;

    // $t7 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t7 := $tmp;

    // $t3 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 13173);
      goto Abort;
    }
    assume is#$Address($t4);


    // $t5 := get_global<Libra::BurnCapability<#0>>($t4)
    call $tmp := $GetGlobal($t4, $Libra_BurnCapability_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 13125);
      goto Abort;
    }
    assume $Libra_BurnCapability_is_well_formed($tmp);
    $t5 := $tmp;

    // Libra::burn_with_capability<#0>($t7, $t5)
    call $Libra_burn_with_capability($tv0, $t7, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 20518);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(preburn_address);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_burn_def($tv0, account, preburn_address);
}

procedure {:inline 1} $Libra_burn_with_capability_def($tv0: $TypeValue, preburn_address: $Value, capability: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t8: $Value; // $Libra_Preburn_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 20507, 0, preburn_address); }
    if (true) { assume $DebugTrackLocal(14, 20507, 1, capability); }

    // bytecode translation starts here
    // $t6 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t6 := $tmp;

    // $t7 := move(capability)
    call $tmp := $CopyOrMoveValue(capability);
    $t7 := $tmp;

    // $t3 := borrow_global<Libra::Preburn<#0>>($t6)
    call $t3 := $BorrowGlobal($t6, $Libra_Preburn_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 20774);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($Dereference($t3));

    // UnpackRef($t3)

    // $t5 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;

    // PackRef($t3)

    // $t8 := read_ref($t3)
    call $tmp := $ReadRef($t3);
    assume $Libra_Preburn_is_well_formed($tmp);
    $t8 := $tmp;

    // $t8 := Libra::burn_with_resource_cap<#0>($t8, $t6, $t5)
    call $t8 := $Libra_burn_with_resource_cap($tv0, $t8, $t6, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 21767);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t8);


    // write_ref($t3, $t8)
    call $t3 := $WriteRef($t3, $t8);

    // Libra::Preburn <- $t3
    call $WritebackToGlobal($t3);

    // UnpackRef($t3)

    // PackRef($t3)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, capability: $Value) returns ()
free requires is#$Address(preburn_address);
free requires $Libra_BurnCapability_is_well_formed(capability);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), preburn_address))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests)), $Integer(0))))
    || b#$Boolean((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), preburn_address))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests)), $Integer(0))))
    || b#$Boolean((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), preburn_address))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests)), $Integer(0))))) ==> $abort_flag;
free ensures b#$Boolean(old((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), preburn_address))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean($IsEqual($vlen_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests)), $Integer(0))))))
    || b#$Boolean(old(((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Vector_eq_pop_front($Libra_Libra_type_value($tv0), $SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), old($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value))) - i#$Integer(old($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value))) - i#$Integer(old($SelectField($select_vector_by_value($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), preburn_address), $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_burn_with_capability_def($tv0, preburn_address, capability);
}

procedure {:inline 1} $Libra_burn_with_resource_cap_def($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value){
    // declare local variables
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var value: $Value; // $IntegerType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t8: $Reference; // ReferenceType($Vector_type_value($Libra_Libra_type_value($tv0)))
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t14: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t21: $Reference; // ReferenceType($IntegerType())
    var $t22: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t28: $Reference; // ReferenceType($IntegerType())
    var $t29: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $BooleanType()
    var $t32: $Value; // $BooleanType()
    var $t33: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t34: $Reference; // ReferenceType($Event_EventHandle_type_value($Libra_BurnEvent_type_value()))
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $Vector_type_value($IntegerType())
    var $t37: $Value; // $AddressType()
    var $t38: $Value; // $Libra_BurnEvent_type_value()
    var $t39: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t40: $Value; // $Libra_Preburn_type_value($tv0)
    var $t41: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t42: $Value; // $AddressType()
    var $t43: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t44: $Value; // $Vector_type_value($Libra_Libra_type_value($tv0))
    var $t45: $Value; // $Event_EventHandle_type_value($Libra_BurnEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 21756, 0, preburn); }
    if (true) { assume $DebugTrackLocal(14, 21756, 1, preburn_address); }
    if (true) { assume $DebugTrackLocal(14, 21756, 2, _capability); }

    // bytecode translation starts here
    // $t40 := move(preburn)
    call $tmp := $CopyOrMoveValue(preburn);
    $t40 := $tmp;

    // $t42 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t42 := $tmp;

    // $t43 := move(_capability)
    call $tmp := $CopyOrMoveValue(_capability);
    $t43 := $tmp;

    // $t41 := borrow_local($t40)
    call $t41 := $BorrowLoc(40, $t40);
    assume $Libra_Preburn_is_well_formed($Dereference($t41));

    // UnpackRef($t41)

    // $t6 := Libra::currency_code<#0>()
    call $t6 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35846);
      goto Abort;
    }
    assume $Vector_is_well_formed($t6) && (forall $$0: int :: {$select_vector($t6,$$0)} $$0 >= 0 && $$0 < $vlen($t6) ==> $IsValidU8($select_vector($t6,$$0)));


    // currency_code := $t6
    call $tmp := $CopyOrMoveValue($t6);
    currency_code := $tmp;
    if (true) { assume $DebugTrackLocal(14, 21965, 3, $tmp); }

    // $t7 := move($t41)
    call $t7 := $CopyOrMoveRef($t41);

    // $t8 := borrow_field<Libra::Preburn<#0>>.requests($t7)
    call $t8 := $BorrowField($t7, $Libra_Preburn_requests);
    assume $Vector_is_well_formed($Dereference($t8)) && (forall $$1: int :: {$select_vector($Dereference($t8),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t8)) ==> $Libra_Libra_is_well_formed_types($select_vector($Dereference($t8),$$1)));

    // LocalRoot($t40) <- $t7
    call $t40 := $WritebackToValue($t7, 40, $t40);

    // UnpackRef($t8)

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // PackRef($t8)

    // $t44 := read_ref($t8)
    call $tmp := $ReadRef($t8);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $Libra_Libra_is_well_formed($select_vector($tmp,$$0)));
    $t44 := $tmp;

    // ($t10, $t44) := Vector::remove<Libra::Libra<#0>>($t44, $t9)
    call $t10, $t44 := $Vector_remove($Libra_Libra_type_value($tv0), $t44, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22107);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t10);

    assume $Vector_is_well_formed($t44) && (forall $$0: int :: {$select_vector($t44,$$0)} $$0 >= 0 && $$0 < $vlen($t44) ==> $Libra_Libra_is_well_formed($select_vector($t44,$$0)));


    // write_ref($t8, $t44)
    call $t8 := $WriteRef($t8, $t44);
    if (true) { assume $DebugTrackLocal(14, 21756, 4, $Dereference(info)); }

    // LocalRoot($t40) <- $t8
    call $t40 := $WritebackToValue($t8, 40, $t40);

    // Reference($t7) <- $t8
    call $t7 := $WritebackToReference($t8, $t7);

    // UnpackRef($t8)

    // PackRef($t7)

    // PackRef($t8)

    // $t11 := unpack Libra::Libra<#0>($t10)
    call $t11 := $Libra_Libra_unpack($tv0, $t10);
    $t11 := $t11;

    // value := $t11
    call $tmp := $CopyOrMoveValue($t11);
    value := $tmp;
    if (true) { assume $DebugTrackLocal(14, 22089, 5, $tmp); }

    // $t12 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t12 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22250);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := borrow_global<Libra::CurrencyInfo<#0>>($t12)
    call $t13 := $BorrowGlobal($t12, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22193);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($Dereference($t13));

    // UnpackRef($t13)

    // info := $t13
    call info := $CopyOrMoveRef($t13);
    if (true) { assume $DebugTrackLocal(14, 22186, 4, $Dereference(info)); }

    // $t14 := copy(info)
    call $t14 := $CopyOrMoveRef(info);

    // $t15 := get_field<Libra::CurrencyInfo<#0>>.total_value($t14)
    call $tmp := $GetFieldFromReference($t14, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128($tmp);
    $t15 := $tmp;

    // Reference(info) <- $t14
    call info := $WritebackToReference($t14, info);

    // $t16 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t16 := $tmp;

    // $t18 := (u128)(value)
    call $tmp := $CastU128(value);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22322);
      goto Abort;
    }
    $t18 := $tmp;

    // $t19 := -($t16, $t18)
    call $tmp := $Sub($t16, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22320);
      goto Abort;
    }
    $t19 := $tmp;

    // $t20 := copy(info)
    call $t20 := $CopyOrMoveRef(info);

    // $t21 := borrow_field<Libra::CurrencyInfo<#0>>.total_value($t20)
    call $t21 := $BorrowField($t20, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128($Dereference($t21));

    // Reference(info) <- $t20
    call info := $WritebackToReference($t20, info);

    // UnpackRef($t21)

    // write_ref($t21, $t19)
    call $t21 := $WriteRef($t21, $t19);
    if (true) { assume $DebugTrackLocal(14, 22284, 4, $Dereference(info)); }

    // Reference(info) <- $t21
    call info := $WritebackToReference($t21, info);

    // Reference($t20) <- $t21
    call $t20 := $WritebackToReference($t21, $t20);

    // PackRef($t21)

    // $t22 := copy(info)
    call $t22 := $CopyOrMoveRef(info);

    // $t23 := get_field<Libra::CurrencyInfo<#0>>.preburn_value($t22)
    call $tmp := $GetFieldFromReference($t22, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($tmp);
    $t23 := $tmp;

    // Reference(info) <- $t22
    call info := $WritebackToReference($t22, info);

    // $t24 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;

    // $t26 := -($t24, value)
    call $tmp := $Sub($t24, value);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22387);
      goto Abort;
    }
    $t26 := $tmp;

    // $t27 := copy(info)
    call $t27 := $CopyOrMoveRef(info);

    // $t28 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_value($t27)
    call $t28 := $BorrowField($t27, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($Dereference($t28));

    // Reference(info) <- $t27
    call info := $WritebackToReference($t27, info);

    // UnpackRef($t28)

    // write_ref($t28, $t26)
    call $t28 := $WriteRef($t28, $t26);
    if (true) { assume $DebugTrackLocal(14, 22347, 4, $Dereference(info)); }

    // Reference(info) <- $t28
    call info := $WritebackToReference($t28, info);

    // Reference($t27) <- $t28
    call $t27 := $WritebackToReference($t28, $t27);

    // PackRef($t28)

    // $t29 := copy(info)
    call $t29 := $CopyOrMoveRef(info);

    // $t30 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic($t29)
    call $tmp := $GetFieldFromReference($t29, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean($tmp);
    $t30 := $tmp;

    // Reference(info) <- $t29
    call info := $WritebackToReference($t29, info);

    // $t31 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t31 := $tmp;

    // $t32 := !($t31)
    call $tmp := $Not($t31);
    $t32 := $tmp;

    // if ($t32) goto L0 else goto L1
    $tmp := $t32;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t33 := move(info)
    call $t33 := $CopyOrMoveRef(info);

    // $t34 := borrow_field<Libra::CurrencyInfo<#0>>.burn_events($t33)
    call $t34 := $BorrowField($t33, $Libra_CurrencyInfo_burn_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t34));

    // Libra::CurrencyInfo <- $t33
    call $WritebackToGlobal($t33);

    // UnpackRef($t34)

    // $t38 := pack Libra::BurnEvent(value, currency_code, $t42)
    call $tmp := $Libra_BurnEvent_pack(0, 0, 0, value, currency_code, $t42);
    $t38 := $tmp;

    // PackRef($t34)

    // $t45 := read_ref($t34)
    call $tmp := $ReadRef($t34);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t45 := $tmp;

    // $t45 := Event::emit_event<Libra::BurnEvent>($t45, $t38)
    call $t45 := $Event_emit_event($Libra_BurnEvent_type_value(), $t45, $t38);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 22508);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t45);


    // write_ref($t34, $t45)
    call $t34 := $WriteRef($t34, $t45);
    if (true) { assume $DebugTrackLocal(14, 21756, 4, $Dereference(info)); }

    // Libra::CurrencyInfo <- $t34
    call $WritebackToGlobal($t34);

    // Reference($t33) <- $t34
    call $t33 := $WritebackToReference($t34, $t33);

    // UnpackRef($t34)

    // PackRef($t33)

    // PackRef($t34)

    // goto L3
    goto L3;

    // L2:
L2:

    // $t39 := move(info)
    call $t39 := $CopyOrMoveRef(info);

    // destroy($t39)

    // Libra::CurrencyInfo <- $t39
    call $WritebackToGlobal($t39);

    // PackRef($t39)

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t40
    $ret0 := $t40;
    if (true) { assume $DebugTrackLocal(14, 22736, 46, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_burn_with_resource_cap($tv0: $TypeValue, preburn: $Value, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
free requires $Libra_Preburn_is_well_formed(preburn);
free requires is#$Address(preburn_address);
free requires $Libra_BurnCapability_is_well_formed(_capability);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean($IsEqual($vlen_value($SelectField(preburn, $Libra_Preburn_requests)), $Integer(0))))
    || b#$Boolean((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean($IsEqual($vlen_value($SelectField(preburn, $Libra_Preburn_requests)), $Integer(0))))
    || b#$Boolean((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean($IsEqual($vlen_value($SelectField(preburn, $Libra_Preburn_requests)), $Integer(0))))) ==> $abort_flag;
free ensures b#$Boolean(old((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean($IsEqual($vlen_value($SelectField(preburn, $Libra_Preburn_requests)), $Integer(0))))))
    || b#$Boolean(old(((var i := $Libra_spec_currency_info($m, $txn, $tv0); $Boolean(b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_total_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value)))) || b#$Boolean($Boolean(i#$Integer($SelectField(i, $Libra_CurrencyInfo_preburn_value)) < i#$Integer($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value))))))))));
free ensures !$abort_flag ==> (b#$Boolean($Vector_eq_pop_front($Libra_Libra_type_value($tv0), $SelectField($ret0, $Libra_Preburn_requests), old($SelectField(preburn, $Libra_Preburn_requests)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value))) - i#$Integer(old($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value))) - i#$Integer(old($SelectField($select_vector_by_value($SelectField(preburn, $Libra_Preburn_requests), $Integer(0)), $Libra_Libra_value))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_burn_with_resource_cap_def($tv0, preburn, preburn_address, _capability);
}

procedure {:inline 1} $Libra_cancel_burn_def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 13561, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 13561, 1, preburn_address); }

    // bytecode translation starts here
    // $t7 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t7 := $tmp;

    // $t8 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t8 := $tmp;

    // $t3 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 13852);
      goto Abort;
    }
    assume is#$Address($t4);


    // $t5 := get_global<Libra::BurnCapability<#0>>($t4)
    call $tmp := $GetGlobal($t4, $Libra_BurnCapability_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 13804);
      goto Abort;
    }
    assume $Libra_BurnCapability_is_well_formed($tmp);
    $t5 := $tmp;

    // $t6 := Libra::cancel_burn_with_capability<#0>($t8, $t5)
    call $t6 := $Libra_cancel_burn_with_capability($tv0, $t8, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 24224);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t6);


    // return $t6
    $ret0 := $t6;
    if (true) { assume $DebugTrackLocal(14, 13734, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free requires is#$Address(preburn_address);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_cancel_burn_def($tv0, account, preburn_address);
}

procedure {:inline 1} $Libra_cancel_burn_with_capability_def($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value){
    // declare local variables
    var amount: $Value; // $IntegerType()
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var preburn: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t7: $Value; // $AddressType()
    var $t8: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t9: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t10: $Reference; // ReferenceType($Vector_type_value($Libra_Libra_type_value($tv0)))
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Libra_Libra_type_value($tv0)
    var $t13: $Value; // $Vector_type_value($IntegerType())
    var $t14: $Value; // $AddressType()
    var $t15: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t16: $Value; // $Libra_Libra_type_value($tv0)
    var $t17: $Value; // $IntegerType()
    var $t18: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t24: $Reference; // ReferenceType($IntegerType())
    var $t25: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t30: $Reference; // ReferenceType($Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value()))
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $Vector_type_value($IntegerType())
    var $t33: $Value; // $AddressType()
    var $t34: $Value; // $Libra_CancelBurnEvent_type_value()
    var $t35: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t36: $Value; // $Libra_Libra_type_value($tv0)
    var $t37: $Value; // $AddressType()
    var $t38: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t39: $Value; // $Vector_type_value($Libra_Libra_type_value($tv0))
    var $t40: $Value; // $Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 24213, 0, preburn_address); }
    if (true) { assume $DebugTrackLocal(14, 24213, 1, _capability); }

    // bytecode translation starts here
    // $t37 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t37 := $tmp;

    // $t38 := move(_capability)
    call $tmp := $CopyOrMoveValue(_capability);
    $t38 := $tmp;

    // $t8 := borrow_global<Libra::Preburn<#0>>($t37)
    call $t8 := $BorrowGlobal($t37, $Libra_Preburn_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 24483);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($Dereference($t8));

    // UnpackRef($t8)

    // preburn := $t8
    call preburn := $CopyOrMoveRef($t8);
    if (true) { assume $DebugTrackLocal(14, 24473, 6, $Dereference(preburn)); }

    // $t9 := move(preburn)
    call $t9 := $CopyOrMoveRef(preburn);

    // $t10 := borrow_field<Libra::Preburn<#0>>.requests($t9)
    call $t10 := $BorrowField($t9, $Libra_Preburn_requests);
    assume $Vector_is_well_formed($Dereference($t10)) && (forall $$1: int :: {$select_vector($Dereference($t10),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t10)) ==> $Libra_Libra_is_well_formed_types($select_vector($Dereference($t10),$$1)));

    // Libra::Preburn <- $t9
    call $WritebackToGlobal($t9);

    // UnpackRef($t10)

    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // PackRef($t10)

    // $t39 := read_ref($t10)
    call $tmp := $ReadRef($t10);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $Libra_Libra_is_well_formed($select_vector($tmp,$$0)));
    $t39 := $tmp;

    // ($t12, $t39) := Vector::remove<Libra::Libra<#0>>($t39, $t11)
    call $t12, $t39 := $Vector_remove($Libra_Libra_type_value($tv0), $t39, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 24565);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t12);

    assume $Vector_is_well_formed($t39) && (forall $$0: int :: {$select_vector($t39,$$0)} $$0 >= 0 && $$0 < $vlen($t39) ==> $Libra_Libra_is_well_formed($select_vector($t39,$$0)));


    // write_ref($t10, $t39)
    call $t10 := $WriteRef($t10, $t39);
    if (true) { assume $DebugTrackLocal(14, 25325, 5, $Dereference(info)); }
    if (true) { assume $DebugTrackLocal(14, 25325, 6, $Dereference(preburn)); }

    // Libra::Preburn <- $t10
    call $WritebackToGlobal($t10);

    // Reference($t9) <- $t10
    call $t9 := $WritebackToReference($t10, $t9);

    // UnpackRef($t10)

    // PackRef($t9)

    // PackRef($t10)

    // coin := $t12
    call $tmp := $CopyOrMoveValue($t12);
    coin := $tmp;
    if (true) { assume $DebugTrackLocal(14, 24550, 3, $tmp); }

    // $t13 := Libra::currency_code<#0>()
    call $t13 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35846);
      goto Abort;
    }
    assume $Vector_is_well_formed($t13) && (forall $$0: int :: {$select_vector($t13,$$0)} $$0 >= 0 && $$0 < $vlen($t13) ==> $IsValidU8($select_vector($t13,$$0)));


    // currency_code := $t13
    call $tmp := $CopyOrMoveValue($t13);
    currency_code := $tmp;
    if (true) { assume $DebugTrackLocal(14, 24644, 4, $tmp); }

    // $t14 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t14 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 24763);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := borrow_global<Libra::CurrencyInfo<#0>>($t14)
    call $t15 := $BorrowGlobal($t14, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 24706);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($Dereference($t15));

    // UnpackRef($t15)

    // info := $t15
    call info := $CopyOrMoveRef($t15);
    if (true) { assume $DebugTrackLocal(14, 24699, 5, $Dereference(info)); }

    // $t16 := copy(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t16 := $tmp;

    // $t17 := Libra::value<#0>($t16)
    call $t17 := $Libra_value($tv0, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 27060);
      goto Abort;
    }
    assume $IsValidU64($t17);


    // amount := $t17
    call $tmp := $CopyOrMoveValue($t17);
    amount := $tmp;
    if (true) { assume $DebugTrackLocal(14, 24801, 2, $tmp); }

    // $t18 := copy(info)
    call $t18 := $CopyOrMoveRef(info);

    // $t19 := get_field<Libra::CurrencyInfo<#0>>.preburn_value($t18)
    call $tmp := $GetFieldFromReference($t18, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($tmp);
    $t19 := $tmp;

    // Reference(info) <- $t18
    call info := $WritebackToReference($t18, info);

    // $t20 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t20 := $tmp;

    // $t22 := -($t20, amount)
    call $tmp := $Sub($t20, amount);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 24872);
      goto Abort;
    }
    $t22 := $tmp;

    // $t23 := copy(info)
    call $t23 := $CopyOrMoveRef(info);

    // $t24 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_value($t23)
    call $t24 := $BorrowField($t23, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($Dereference($t24));

    // Reference(info) <- $t23
    call info := $WritebackToReference($t23, info);

    // UnpackRef($t24)

    // write_ref($t24, $t22)
    call $t24 := $WriteRef($t24, $t22);
    if (true) { assume $DebugTrackLocal(14, 24832, 5, $Dereference(info)); }
    if (true) { assume $DebugTrackLocal(14, 24832, 6, $Dereference(preburn)); }

    // Reference(info) <- $t24
    call info := $WritebackToReference($t24, info);

    // Reference($t23) <- $t24
    call $t23 := $WritebackToReference($t24, $t23);

    // PackRef($t24)

    // $t25 := copy(info)
    call $t25 := $CopyOrMoveRef(info);

    // $t26 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic($t25)
    call $tmp := $GetFieldFromReference($t25, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean($tmp);
    $t26 := $tmp;

    // Reference(info) <- $t25
    call info := $WritebackToReference($t25, info);

    // $t27 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t27 := $tmp;

    // $t28 := !($t27)
    call $tmp := $Not($t27);
    $t28 := $tmp;

    // if ($t28) goto L0 else goto L1
    $tmp := $t28;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t29 := move(info)
    call $t29 := $CopyOrMoveRef(info);

    // $t30 := borrow_field<Libra::CurrencyInfo<#0>>.cancel_burn_events($t29)
    call $t30 := $BorrowField($t29, $Libra_CurrencyInfo_cancel_burn_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t30));

    // Libra::CurrencyInfo <- $t29
    call $WritebackToGlobal($t29);

    // UnpackRef($t30)

    // $t34 := pack Libra::CancelBurnEvent(amount, currency_code, $t37)
    call $tmp := $Libra_CancelBurnEvent_pack(0, 0, 0, amount, currency_code, $t37);
    $t34 := $tmp;

    // PackRef($t30)

    // $t40 := read_ref($t30)
    call $tmp := $ReadRef($t30);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t40 := $tmp;

    // $t40 := Event::emit_event<Libra::CancelBurnEvent>($t40, $t34)
    call $t40 := $Event_emit_event($Libra_CancelBurnEvent_type_value(), $t40, $t34);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 25080);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t40);


    // write_ref($t30, $t40)
    call $t30 := $WriteRef($t30, $t40);
    if (true) { assume $DebugTrackLocal(14, 24213, 5, $Dereference(info)); }
    if (true) { assume $DebugTrackLocal(14, 24213, 6, $Dereference(preburn)); }

    // Libra::CurrencyInfo <- $t30
    call $WritebackToGlobal($t30);

    // Reference($t29) <- $t30
    call $t29 := $WritebackToReference($t30, $t29);

    // UnpackRef($t30)

    // PackRef($t29)

    // PackRef($t30)

    // goto L3
    goto L3;

    // L2:
L2:

    // $t35 := move(info)
    call $t35 := $CopyOrMoveRef(info);

    // destroy($t35)

    // Libra::CurrencyInfo <- $t35
    call $WritebackToGlobal($t35);

    // PackRef($t35)

    // goto L3
    goto L3;

    // L3:
L3:

    // return coin
    $ret0 := coin;
    if (true) { assume $DebugTrackLocal(14, 25325, 41, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_cancel_burn_with_capability($tv0: $TypeValue, preburn_address: $Value, _capability: $Value) returns ($ret0: $Value)
free requires is#$Address(preburn_address);
free requires $Libra_BurnCapability_is_well_formed(_capability);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_cancel_burn_with_capability_def($tv0, preburn_address, _capability);
}

procedure {:inline 1} $Libra_create_preburn_def($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $Vector_type_value($Libra_Libra_type_value($tv0))
    var $t8: $Value; // $Libra_Preburn_type_value($tv0)
    var $t9: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 18179, 0, tc_account); }

    // bytecode translation starts here
    // $t9 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t9 := $tmp;

    // $t3 := move($t9)
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;

    // $t4 := Roles::has_treasury_compliance_role($t3)
    call $t4 := $Roles_has_treasury_compliance_role($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 18293);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // $t1 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 18279, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t6 := 2
    $tmp := $Integer(2);
    $t6 := $tmp;

    // abort($t6)
    if (true) { assume $DebugTrackAbort(14, 18279); }
    goto Abort;

    // L0:
L0:

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t7 := Vector::empty<Libra::Libra<#0>>()
    call $t7 := $Vector_empty($Libra_Libra_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 18448);
      goto Abort;
    }
    assume $Vector_is_well_formed($t7) && (forall $$0: int :: {$select_vector($t7,$$0)} $$0 >= 0 && $$0 < $vlen($t7) ==> $Libra_Libra_is_well_formed($select_vector($t7,$$0)));


    // $t8 := pack Libra::Preburn<#0>($t7)
    call $tmp := $Libra_Preburn_pack(0, 0, 0, $tv0, $t7);
    $t8 := $tmp;

    // return $t8
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(14, 18410, 10, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_create_preburn($tv0: $TypeValue, tc_account: $Value) returns ($ret0: $Value)
free requires is#$Address(tc_account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_create_preburn_def($tv0, tc_account);
}

procedure {:inline 1} $Libra_deposit_def($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value){
    // declare local variables
    var value: $Value; // $IntegerType()
    var $t3: $Value; // $Libra_Libra_type_value($tv0)
    var $t4: $Value; // $IntegerType()
    var $t5: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t11: $Reference; // ReferenceType($IntegerType())
    var $t12: $Value; // $Libra_Libra_type_value($tv0)
    var $t13: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t14: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 29536, 0, coin); }
    if (true) { assume $DebugTrackLocal(14, 29536, 1, check); }

    // bytecode translation starts here
    // $t12 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t12 := $tmp;

    // $t14 := move(check)
    call $tmp := $CopyOrMoveValue(check);
    $t14 := $tmp;

    // $t13 := borrow_local($t12)
    call $t13 := $BorrowLoc(12, $t12);
    assume $Libra_Libra_is_well_formed($Dereference($t13));

    // UnpackRef($t13)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t13));

    // $t4 := unpack Libra::Libra<#0>($t14)
    call $t4 := $Libra_Libra_unpack($tv0, $t14);
    $t4 := $t4;

    // value := $t4
    call $tmp := $CopyOrMoveValue($t4);
    value := $tmp;
    if (true) { assume $DebugTrackLocal(14, 29639, 2, $tmp); }

    // $t5 := copy($t13)
    call $t5 := $CopyOrMoveRef($t13);

    // $t6 := get_field<Libra::Libra<#0>>.value($t5)
    call $tmp := $GetFieldFromReference($t5, $Libra_Libra_value);
    assume $IsValidU64($tmp);
    $t6 := $tmp;

    // Reference($t13) <- $t5
    call $t13 := $WritebackToReference($t5, $t13);

    // $t7 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;

    // $t9 := +($t7, value)
    call $tmp := $AddU64($t7, value);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 29688);
      goto Abort;
    }
    $t9 := $tmp;

    // $t10 := move($t13)
    call $t10 := $CopyOrMoveRef($t13);

    // $t11 := borrow_field<Libra::Libra<#0>>.value($t10)
    call $t11 := $BorrowField($t10, $Libra_Libra_value);
    assume $IsValidU64($Dereference($t11));

    // LocalRoot($t12) <- $t10
    call $t12 := $WritebackToValue($t10, 12, $t12);

    // UnpackRef($t11)

    // write_ref($t11, $t9)
    call $t11 := $WriteRef($t11, $t9);

    // LocalRoot($t12) <- $t11
    call $t12 := $WritebackToValue($t11, 12, $t12);

    // Reference($t10) <- $t11
    call $t10 := $WritebackToReference($t11, $t10);

    // PackRef($t10)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t10));

    // PackRef($t11)

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(14, 29695, 15, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_deposit($tv0: $TypeValue, coin: $Value, check: $Value) returns ($ret0: $Value)
free requires $Libra_Libra_is_well_formed(coin);
free requires $Libra_Libra_is_well_formed(check);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_deposit_def($tv0, coin, check);
}

procedure {:inline 1} $Libra_destroy_zero_def($tv0: $TypeValue, coin: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var value: $Value; // $IntegerType()
    var $t4: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 29941, 0, coin); }

    // bytecode translation starts here
    // $t11 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t11 := $tmp;

    // $t5 := unpack Libra::Libra<#0>($t11)
    call $t5 := $Libra_Libra_unpack($tv0, $t11);
    $t5 := $t5;

    // value := $t5
    call $tmp := $CopyOrMoveValue($t5);
    value := $tmp;
    if (true) { assume $DebugTrackLocal(14, 30020, 3, $tmp); }

    // $t7 := 0
    $tmp := $Integer(0);
    $t7 := $tmp;

    // $t8 := ==(value, $t7)
    $tmp := $Boolean($IsEqual(value, $t7));
    $t8 := $tmp;

    // $t1 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 30044, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := 6
    $tmp := $Integer(6);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(14, 30044); }
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_destroy_zero($tv0: $TypeValue, coin: $Value) returns ()
free requires $Libra_Libra_is_well_formed(coin);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))));
free ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) > i#$Integer($Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_destroy_zero_def($tv0, coin);
}

procedure {:inline 1} $Libra_fractional_part_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35670);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $GetGlobal($t0, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35617);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.fractional_part($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_fractional_part);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 35617, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_fractional_part($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_fractional_part_def($tv0);
}

procedure {:inline 1} $Libra_is_currency_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 34679);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := exists<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $Exists($t0, $Libra_CurrencyInfo_type_value($tv0));
    $t1 := $tmp;

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(14, 34633, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_is_currency($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_is_currency_def($tv0);
}

procedure {:inline 1} $Libra_is_synthetic_currency_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var addr: $Value; // $AddressType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t2 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t2 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 34958);
      goto Abort;
    }
    assume is#$Address($t2);


    // addr := $t2
    call $tmp := $CopyOrMoveValue($t2);
    addr := $tmp;
    if (true) { assume $DebugTrackLocal(14, 34936, 0, $tmp); }

    // $t4 := exists<Libra::CurrencyInfo<#0>>(addr)
    call $tmp := $Exists(addr, $Libra_CurrencyInfo_type_value($tv0));
    $t4 := $tmp;

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t6 := get_global<Libra::CurrencyInfo<#0>>(addr)
    call $tmp := $GetGlobal(addr, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35043);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t6 := $tmp;

    // $t7 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic($t6)
    call $tmp := $GetFieldFromValue($t6, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean($tmp);
    $t7 := $tmp;

    // $t8 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t8 := $tmp;

    // $t1 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 34991, 1, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t9 := false
    $tmp := $Boolean(false);
    $t9 := $tmp;

    // $t1 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 34991, 1, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(14, 34991, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_is_synthetic_currency($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_is_synthetic_currency_def($tv0);
}

procedure {:inline 1} $Libra_join_def($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t3: $Value; // $Libra_Libra_type_value($tv0)
    var $t4: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $Libra_Libra_type_value($tv0)
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 29062, 0, coin1); }
    if (true) { assume $DebugTrackLocal(14, 29062, 1, coin2); }

    // bytecode translation starts here
    // $t5 := move(coin1)
    call $tmp := $CopyOrMoveValue(coin1);
    $t5 := $tmp;

    // $t6 := move(coin2)
    call $tmp := $CopyOrMoveValue(coin2);
    $t6 := $tmp;

    // $t2 := borrow_local($t5)
    call $t2 := $BorrowLoc(5, $t5);
    assume $Libra_Libra_is_well_formed($Dereference($t2));

    // UnpackRef($t2)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t2));

    // PackRef($t2)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t2));

    // $t7 := read_ref($t2)
    call $tmp := $ReadRef($t2);
    assume $Libra_Libra_is_well_formed($tmp);
    $t7 := $tmp;

    // $t7 := Libra::deposit<#0>($t7, $t6)
    call $t7 := $Libra_deposit($tv0, $t7, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 29547);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t7);


    // write_ref($t2, $t7)
    call $t2 := $WriteRef($t2, $t7);

    // LocalRoot($t5) <- $t2
    call $t5 := $WritebackToValue($t2, 5, $t5);

    // UnpackRef($t2)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t2));

    // PackRef($t2)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t2));

    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(14, 29200, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_join($tv0: $TypeValue, coin1: $Value, coin2: $Value) returns ($ret0: $Value)
free requires $Libra_Libra_is_well_formed(coin1);
free requires $Libra_Libra_is_well_formed(coin2);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))));
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin1, $Libra_Libra_value)) + i#$Integer($SelectField(coin2, $Libra_Libra_value)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_join_def($tv0, coin1, coin2);
}

procedure {:inline 1} $Libra_lbr_exchange_rate_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t3: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 37183);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $GetGlobal($t0, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 37130);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.to_lbr_exchange_rate($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 37128, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_lbr_exchange_rate($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_lbr_exchange_rate_def($tv0);
}

procedure {:inline 1} $Libra_market_cap_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 33619);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $GetGlobal($t0, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 33566);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.total_value($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 33566, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_market_cap($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_market_cap_def($tv0);
}

procedure {:inline 1} $Libra_mint_def($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 12209, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 12209, 1, value); }

    // bytecode translation starts here
    // $t7 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t7 := $tmp;

    // $t8 := move(value)
    call $tmp := $CopyOrMoveValue(value);
    $t8 := $tmp;

    // $t3 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 12435);
      goto Abort;
    }
    assume is#$Address($t4);


    // $t5 := get_global<Libra::MintCapability<#0>>($t4)
    call $tmp := $GetGlobal($t4, $Libra_MintCapability_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 12387);
      goto Abort;
    }
    assume $Libra_MintCapability_is_well_formed($tmp);
    $t5 := $tmp;

    // $t6 := Libra::mint_with_capability<#0>($t8, $t5)
    call $t6 := $Libra_mint_with_capability($tv0, $t8, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 14450);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t6);


    // return $t6
    $ret0 := $t6;
    if (true) { assume $DebugTrackLocal(14, 12334, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_mint($tv0: $TypeValue, account: $Value, value: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free requires $IsValidU64(value);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_MintCapability_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_MintCapability_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $Libra_MintCapability_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $Libra_MintCapability_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_mint_def($tv0, account, value);
}

procedure {:inline 1} $Libra_mint_with_capability_def($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value){
    // declare local variables
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $Vector_type_value($IntegerType())
    var $t7: $Value; // $AddressType()
    var $t8: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t9: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t14: $Value; // $IntegerType()
    var $t15: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t22: $Reference; // ReferenceType($IntegerType())
    var $t23: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t28: $Reference; // ReferenceType($Event_EventHandle_type_value($Libra_MintEvent_type_value()))
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $Vector_type_value($IntegerType())
    var $t31: $Value; // $Libra_MintEvent_type_value()
    var $t32: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $Libra_Libra_type_value($tv0)
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t37: $Value; // $Event_EventHandle_type_value($Libra_MintEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 14439, 0, value); }
    if (true) { assume $DebugTrackLocal(14, 14439, 1, _capability); }

    // bytecode translation starts here
    // $t35 := move(value)
    call $tmp := $CopyOrMoveValue(value);
    $t35 := $tmp;

    // $t36 := move(_capability)
    call $tmp := $CopyOrMoveValue(_capability);
    $t36 := $tmp;

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t6 := Libra::currency_code<#0>()
    call $t6 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35846);
      goto Abort;
    }
    assume $Vector_is_well_formed($t6) && (forall $$0: int :: {$select_vector($t6,$$0)} $$0 >= 0 && $$0 < $vlen($t6) ==> $IsValidU8($select_vector($t6,$$0)));


    // currency_code := $t6
    call $tmp := $CopyOrMoveValue($t6);
    currency_code := $tmp;
    if (true) { assume $DebugTrackLocal(14, 14648, 2, $tmp); }

    // $t7 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t7 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 14824);
      goto Abort;
    }
    assume is#$Address($t7);


    // $t8 := borrow_global<Libra::CurrencyInfo<#0>>($t7)
    call $t8 := $BorrowGlobal($t7, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 14767);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($Dereference($t8));

    // UnpackRef($t8)

    // info := $t8
    call info := $CopyOrMoveRef($t8);
    if (true) { assume $DebugTrackLocal(14, 14760, 3, $Dereference(info)); }

    // $t9 := copy(info)
    call $t9 := $CopyOrMoveRef(info);

    // $t10 := get_field<Libra::CurrencyInfo<#0>>.can_mint($t9)
    call $tmp := $GetFieldFromReference($t9, $Libra_CurrencyInfo_can_mint);
    assume is#$Boolean($tmp);
    $t10 := $tmp;

    // Reference(info) <- $t9
    call info := $WritebackToReference($t9, info);

    // $t11 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;

    // $t4 := $t11
    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 14858, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t13 := move(info)
    call $t13 := $CopyOrMoveRef(info);

    // destroy($t13)

    // Libra::CurrencyInfo <- $t13
    call $WritebackToGlobal($t13);

    // PackRef($t13)

    // $t14 := 3
    $tmp := $Integer(3);
    $t14 := $tmp;

    // abort($t14)
    if (true) { assume $DebugTrackAbort(14, 14858); }
    goto Abort;

    // L0:
L0:

    // $t15 := copy(info)
    call $t15 := $CopyOrMoveRef(info);

    // $t16 := get_field<Libra::CurrencyInfo<#0>>.total_value($t15)
    call $tmp := $GetFieldFromReference($t15, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128($tmp);
    $t16 := $tmp;

    // Reference(info) <- $t15
    call info := $WritebackToReference($t15, info);

    // $t17 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t17 := $tmp;

    // $t19 := (u128)($t35)
    call $tmp := $CastU128($t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 14949);
      goto Abort;
    }
    $t19 := $tmp;

    // $t20 := +($t17, $t19)
    call $tmp := $AddU128($t17, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 14947);
      goto Abort;
    }
    $t20 := $tmp;

    // $t21 := copy(info)
    call $t21 := $CopyOrMoveRef(info);

    // $t22 := borrow_field<Libra::CurrencyInfo<#0>>.total_value($t21)
    call $t22 := $BorrowField($t21, $Libra_CurrencyInfo_total_value);
    assume $IsValidU128($Dereference($t22));

    // Reference(info) <- $t21
    call info := $WritebackToReference($t21, info);

    // UnpackRef($t22)

    // write_ref($t22, $t20)
    call $t22 := $WriteRef($t22, $t20);
    if (true) { assume $DebugTrackLocal(14, 14911, 3, $Dereference(info)); }

    // Reference(info) <- $t22
    call info := $WritebackToReference($t22, info);

    // Reference($t21) <- $t22
    call $t21 := $WritebackToReference($t22, $t21);

    // PackRef($t22)

    // $t23 := copy(info)
    call $t23 := $CopyOrMoveRef(info);

    // $t24 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic($t23)
    call $tmp := $GetFieldFromReference($t23, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean($tmp);
    $t24 := $tmp;

    // Reference(info) <- $t23
    call info := $WritebackToReference($t23, info);

    // $t25 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t25 := $tmp;

    // $t26 := !($t25)
    call $tmp := $Not($t25);
    $t26 := $tmp;

    // if ($t26) goto L2 else goto L3
    $tmp := $t26;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t27 := move(info)
    call $t27 := $CopyOrMoveRef(info);

    // $t28 := borrow_field<Libra::CurrencyInfo<#0>>.mint_events($t27)
    call $t28 := $BorrowField($t27, $Libra_CurrencyInfo_mint_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t28));

    // Libra::CurrencyInfo <- $t27
    call $WritebackToGlobal($t27);

    // UnpackRef($t28)

    // $t31 := pack Libra::MintEvent($t35, currency_code)
    call $tmp := $Libra_MintEvent_pack(0, 0, 0, $t35, currency_code);
    $t31 := $tmp;

    // PackRef($t28)

    // $t37 := read_ref($t28)
    call $tmp := $ReadRef($t28);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t37 := $tmp;

    // $t37 := Event::emit_event<Libra::MintEvent>($t37, $t31)
    call $t37 := $Event_emit_event($Libra_MintEvent_type_value(), $t37, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 15078);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t37);


    // write_ref($t28, $t37)
    call $t28 := $WriteRef($t28, $t37);
    if (true) { assume $DebugTrackLocal(14, 15279, 3, $Dereference(info)); }

    // Libra::CurrencyInfo <- $t28
    call $WritebackToGlobal($t28);

    // Reference($t27) <- $t28
    call $t27 := $WritebackToReference($t28, $t27);

    // UnpackRef($t28)

    // PackRef($t27)

    // PackRef($t28)

    // goto L5
    goto L5;

    // L4:
L4:

    // $t32 := move(info)
    call $t32 := $CopyOrMoveRef(info);

    // destroy($t32)

    // Libra::CurrencyInfo <- $t32
    call $WritebackToGlobal($t32);

    // PackRef($t32)

    // goto L5
    goto L5;

    // L5:
L5:

    // $t34 := pack Libra::Libra<#0>($t35)
    call $tmp := $Libra_Libra_pack(0, 0, 0, $tv0, $t35);
    $t34 := $tmp;

    // return $t34
    $ret0 := $t34;
    if (true) { assume $DebugTrackLocal(14, 15279, 38, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_mint_with_capability($tv0: $TypeValue, value: $Value, _capability: $Value) returns ($ret0: $Value)
free requires $IsValidU64(value);
free requires $Libra_MintCapability_is_well_formed(_capability);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_can_mint))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value)) + i#$Integer(value))) > i#$Integer($Integer($MAX_U128)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_total_value))) + i#$Integer(value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), value))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_mint_with_capability_def($tv0, value, _capability);
}

procedure {:inline 1} $Libra_new_preburn_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $Vector_type_value($Libra_Libra_type_value($tv0))
    var $t1: $Value; // $Libra_Preburn_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t0 := Vector::empty<Libra::Libra<#0>>()
    call $t0 := $Vector_empty($Libra_Libra_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 14174);
      goto Abort;
    }
    assume $Vector_is_well_formed($t0) && (forall $$0: int :: {$select_vector($t0,$$0)} $$0 >= 0 && $$0 < $vlen($t0) ==> $Libra_Libra_is_well_formed($select_vector($t0,$$0)));


    // $t1 := pack Libra::Preburn<#0>($t0)
    call $tmp := $Libra_Preburn_pack(0, 0, 0, $tv0, $t0);
    $t1 := $tmp;

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(14, 14136, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_new_preburn($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_new_preburn_def($tv0);
}

procedure {:inline 1} $Libra_preburn_to_def($tv0: $TypeValue, account: $Value, coin: $Value) returns (){
    // declare local variables
    var sender: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_Libra_type_value($tv0)
    var $t6: $Value; // $AddressType()
    var $t7: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $t11: $Value; // $Libra_Preburn_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 19419, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 19419, 1, coin); }

    // bytecode translation starts here
    // $t9 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t9 := $tmp;

    // $t10 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t10 := $tmp;

    // $t3 := move($t9)
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 19563);
      goto Abort;
    }
    assume is#$Address($t4);


    // sender := $t4
    call $tmp := $CopyOrMoveValue($t4);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(14, 19546, 2, $tmp); }

    // $t7 := borrow_global<Libra::Preburn<#0>>(sender)
    call $t7 := $BorrowGlobal(sender, $Libra_Preburn_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 19620);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($Dereference($t7));

    // UnpackRef($t7)

    // PackRef($t7)

    // $t11 := read_ref($t7)
    call $tmp := $ReadRef($t7);
    assume $Libra_Preburn_is_well_formed($tmp);
    $t11 := $tmp;

    // $t11 := Libra::preburn_with_resource<#0>($t10, $t11, sender)
    call $t11 := $Libra_preburn_with_resource($tv0, $t10, $t11, sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 16341);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t11);


    // write_ref($t7, $t11)
    call $t7 := $WriteRef($t7, $t11);

    // Libra::Preburn <- $t7
    call $WritebackToGlobal($t7);

    // UnpackRef($t7)

    // PackRef($t7)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_preburn_to($tv0: $TypeValue, account: $Value, coin: $Value) returns ()
free requires is#$Address(account);
free requires $Libra_Libra_is_well_formed(coin);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $Libra_Preburn_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))));
free ensures !$abort_flag ==> (b#$Boolean($Vector_eq_push_back($Libra_Libra_type_value($tv0), $SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), $Signer_spec_address_of($m, $txn, account)), $Libra_Preburn_requests), old($SelectField($ResourceValue($m, $Libra_Preburn_type_value($tv0), $Signer_spec_address_of($m, $txn, account)), $Libra_Preburn_requests)), coin)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer($SelectField(coin, $Libra_Libra_value)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_preburn_to_def($tv0, account, coin);
}

procedure {:inline 1} $Libra_preburn_value_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 26545);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $GetGlobal($t0, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 26492);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.preburn_value($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 26492, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_preburn_value($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_preburn_value_def($tv0);
}

procedure {:inline 1} $Libra_preburn_with_resource_def($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value){
    // declare local variables
    var coin_value: $Value; // $IntegerType()
    var currency_code: $Value; // $Vector_type_value($IntegerType())
    var info: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $IntegerType()
    var $t8: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t9: $Reference; // ReferenceType($Vector_type_value($Libra_Libra_type_value($tv0)))
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $t12: $Value; // $AddressType()
    var $t13: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t14: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t20: $Reference; // ReferenceType($IntegerType())
    var $t21: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t26: $Reference; // ReferenceType($Event_EventHandle_type_value($Libra_PreburnEvent_type_value()))
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $Vector_type_value($IntegerType())
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $Libra_PreburnEvent_type_value()
    var $t31: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t32: $Value; // $Libra_Libra_type_value($tv0)
    var $t33: $Value; // $Libra_Preburn_type_value($tv0)
    var $t34: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t35: $Value; // $AddressType()
    var $t36: $Value; // $Vector_type_value($Libra_Libra_type_value($tv0))
    var $t37: $Value; // $Event_EventHandle_type_value($Libra_PreburnEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 16330, 0, coin); }
    if (true) { assume $DebugTrackLocal(14, 16330, 1, preburn); }
    if (true) { assume $DebugTrackLocal(14, 16330, 2, preburn_address); }

    // bytecode translation starts here
    // $t32 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t32 := $tmp;

    // $t33 := move(preburn)
    call $tmp := $CopyOrMoveValue(preburn);
    $t33 := $tmp;

    // $t35 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t35 := $tmp;

    // $t34 := borrow_local($t33)
    call $t34 := $BorrowLoc(33, $t33);
    assume $Libra_Preburn_is_well_formed($Dereference($t34));

    // UnpackRef($t34)

    // $t6 := copy($t32)
    call $tmp := $CopyOrMoveValue($t32);
    $t6 := $tmp;

    // $t7 := Libra::value<#0>($t6)
    call $t7 := $Libra_value($tv0, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 27060);
      goto Abort;
    }
    assume $IsValidU64($t7);


    // coin_value := $t7
    call $tmp := $CopyOrMoveValue($t7);
    coin_value := $tmp;
    if (true) { assume $DebugTrackLocal(14, 16522, 3, $tmp); }

    // $t8 := move($t34)
    call $t8 := $CopyOrMoveRef($t34);

    // $t9 := borrow_field<Libra::Preburn<#0>>.requests($t8)
    call $t9 := $BorrowField($t8, $Libra_Preburn_requests);
    assume $Vector_is_well_formed($Dereference($t9)) && (forall $$1: int :: {$select_vector($Dereference($t9),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t9)) ==> $Libra_Libra_is_well_formed_types($select_vector($Dereference($t9),$$1)));

    // LocalRoot($t33) <- $t8
    call $t33 := $WritebackToValue($t8, 33, $t33);

    // UnpackRef($t9)

    // PackRef($t9)

    // $t36 := read_ref($t9)
    call $tmp := $ReadRef($t9);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $Libra_Libra_is_well_formed($select_vector($tmp,$$0)));
    $t36 := $tmp;

    // $t36 := Vector::push_back<Libra::Libra<#0>>($t36, $t32)
    call $t36 := $Vector_push_back($Libra_Libra_type_value($tv0), $t36, $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 16565);
      goto Abort;
    }
    assume $Vector_is_well_formed($t36) && (forall $$0: int :: {$select_vector($t36,$$0)} $$0 >= 0 && $$0 < $vlen($t36) ==> $Libra_Libra_is_well_formed($select_vector($t36,$$0)));


    // write_ref($t9, $t36)
    call $t9 := $WriteRef($t9, $t36);
    if (true) { assume $DebugTrackLocal(14, 16330, 5, $Dereference(info)); }

    // LocalRoot($t33) <- $t9
    call $t33 := $WritebackToValue($t9, 33, $t33);

    // Reference($t8) <- $t9
    call $t8 := $WritebackToReference($t9, $t8);

    // UnpackRef($t9)

    // PackRef($t8)

    // PackRef($t9)

    // $t11 := Libra::currency_code<#0>()
    call $t11 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35846);
      goto Abort;
    }
    assume $Vector_is_well_formed($t11) && (forall $$0: int :: {$select_vector($t11,$$0)} $$0 >= 0 && $$0 < $vlen($t11) ==> $IsValidU8($select_vector($t11,$$0)));


    // currency_code := $t11
    call $tmp := $CopyOrMoveValue($t11);
    currency_code := $tmp;
    if (true) { assume $DebugTrackLocal(14, 16651, 4, $tmp); }

    // $t12 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t12 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 16770);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := borrow_global<Libra::CurrencyInfo<#0>>($t12)
    call $t13 := $BorrowGlobal($t12, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 16713);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($Dereference($t13));

    // UnpackRef($t13)

    // info := $t13
    call info := $CopyOrMoveRef($t13);
    if (true) { assume $DebugTrackLocal(14, 16706, 5, $Dereference(info)); }

    // $t14 := copy(info)
    call $t14 := $CopyOrMoveRef(info);

    // $t15 := get_field<Libra::CurrencyInfo<#0>>.preburn_value($t14)
    call $tmp := $GetFieldFromReference($t14, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($tmp);
    $t15 := $tmp;

    // Reference(info) <- $t14
    call info := $WritebackToReference($t14, info);

    // $t16 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t16 := $tmp;

    // $t18 := +($t16, coin_value)
    call $tmp := $AddU64($t16, coin_value);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 16844);
      goto Abort;
    }
    $t18 := $tmp;

    // $t19 := copy(info)
    call $t19 := $CopyOrMoveRef(info);

    // $t20 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_value($t19)
    call $t20 := $BorrowField($t19, $Libra_CurrencyInfo_preburn_value);
    assume $IsValidU64($Dereference($t20));

    // Reference(info) <- $t19
    call info := $WritebackToReference($t19, info);

    // UnpackRef($t20)

    // write_ref($t20, $t18)
    call $t20 := $WriteRef($t20, $t18);
    if (true) { assume $DebugTrackLocal(14, 16804, 5, $Dereference(info)); }

    // Reference(info) <- $t20
    call info := $WritebackToReference($t20, info);

    // Reference($t19) <- $t20
    call $t19 := $WritebackToReference($t20, $t19);

    // PackRef($t20)

    // $t21 := copy(info)
    call $t21 := $CopyOrMoveRef(info);

    // $t22 := get_field<Libra::CurrencyInfo<#0>>.is_synthetic($t21)
    call $tmp := $GetFieldFromReference($t21, $Libra_CurrencyInfo_is_synthetic);
    assume is#$Boolean($tmp);
    $t22 := $tmp;

    // Reference(info) <- $t21
    call info := $WritebackToReference($t21, info);

    // $t23 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t23 := $tmp;

    // $t24 := !($t23)
    call $tmp := $Not($t23);
    $t24 := $tmp;

    // if ($t24) goto L0 else goto L1
    $tmp := $t24;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t25 := move(info)
    call $t25 := $CopyOrMoveRef(info);

    // $t26 := borrow_field<Libra::CurrencyInfo<#0>>.preburn_events($t25)
    call $t26 := $BorrowField($t25, $Libra_CurrencyInfo_preburn_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t26));

    // Libra::CurrencyInfo <- $t25
    call $WritebackToGlobal($t25);

    // UnpackRef($t26)

    // $t30 := pack Libra::PreburnEvent(coin_value, currency_code, $t35)
    call $tmp := $Libra_PreburnEvent_pack(0, 0, 0, coin_value, currency_code, $t35);
    $t30 := $tmp;

    // PackRef($t26)

    // $t37 := read_ref($t26)
    call $tmp := $ReadRef($t26);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t37 := $tmp;

    // $t37 := Event::emit_event<Libra::PreburnEvent>($t37, $t30)
    call $t37 := $Event_emit_event($Libra_PreburnEvent_type_value(), $t37, $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 16973);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t37);


    // write_ref($t26, $t37)
    call $t26 := $WriteRef($t26, $t37);
    if (true) { assume $DebugTrackLocal(14, 16330, 5, $Dereference(info)); }

    // Libra::CurrencyInfo <- $t26
    call $WritebackToGlobal($t26);

    // Reference($t25) <- $t26
    call $t25 := $WritebackToReference($t26, $t25);

    // UnpackRef($t26)

    // PackRef($t25)

    // PackRef($t26)

    // goto L3
    goto L3;

    // L2:
L2:

    // $t31 := move(info)
    call $t31 := $CopyOrMoveRef(info);

    // destroy($t31)

    // Libra::CurrencyInfo <- $t31
    call $WritebackToGlobal($t31);

    // PackRef($t31)

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t33
    $ret0 := $t33;
    if (true) { assume $DebugTrackLocal(14, 17211, 38, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_preburn_with_resource($tv0: $TypeValue, coin: $Value, preburn: $Value, preburn_address: $Value) returns ($ret0: $Value)
free requires $Libra_Libra_is_well_formed(coin);
free requires $Libra_Preburn_is_well_formed(preburn);
free requires is#$Address(preburn_address);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value)) + i#$Integer($SelectField(coin, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64)))))));
free ensures !$abort_flag ==> (b#$Boolean($Vector_eq_push_back($Libra_Libra_type_value($tv0), $SelectField($ret0, $Libra_Preburn_requests), old($SelectField(preburn, $Libra_Preburn_requests)), coin)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value), $Integer(i#$Integer(old($SelectField($Libra_spec_currency_info($m, $txn, $tv0), $Libra_CurrencyInfo_preburn_value))) + i#$Integer($SelectField(coin, $Libra_Libra_value)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_preburn_with_resource_def($tv0, coin, preburn, preburn_address);
}

procedure {:inline 1} $Libra_publish_burn_capability_def($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t14: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 11687, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 11687, 1, cap); }
    if (true) { assume $DebugTrackLocal(14, 11687, 2, tc_account); }

    // bytecode translation starts here
    // $t12 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t12 := $tmp;

    // $t13 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t13 := $tmp;

    // $t14 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t14 := $tmp;

    // $t5 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;

    // $t6 := Roles::has_treasury_compliance_role($t5)
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 11857);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 11843, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 2
    $tmp := $Integer(2);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(14, 11843); }
    goto Abort;

    // L0:
L0:

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t10 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t10 := $tmp;

    // move_to<Libra::BurnCapability<#0>>($t13, $t10)
    call $MoveTo($Libra_BurnCapability_type_value($tv0), $t13, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 11974);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_publish_burn_capability($tv0: $TypeValue, account: $Value, cap: $Value, tc_account: $Value) returns ()
free requires is#$Address(account);
free requires $Libra_BurnCapability_is_well_formed(cap);
free requires is#$Address(tc_account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_publish_burn_capability_def($tv0, account, cap, tc_account);
}

procedure {:inline 1} $Libra_publish_mint_capability_def($tv0: $TypeValue, publish_account: $Value, cap: $Value, tc_account: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t14: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 11138, 0, publish_account); }
    if (true) { assume $DebugTrackLocal(14, 11138, 1, cap); }
    if (true) { assume $DebugTrackLocal(14, 11138, 2, tc_account); }

    // bytecode translation starts here
    // $t12 := move(publish_account)
    call $tmp := $CopyOrMoveValue(publish_account);
    $t12 := $tmp;

    // $t13 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t13 := $tmp;

    // $t14 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t14 := $tmp;

    // $t5 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;

    // $t6 := Roles::has_treasury_compliance_role($t5)
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 11316);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 11302, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 2
    $tmp := $Integer(2);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(14, 11302); }
    goto Abort;

    // L0:
L0:

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t10 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t10 := $tmp;

    // move_to<Libra::MintCapability<#0>>($t13, $t10)
    call $MoveTo($Libra_MintCapability_type_value($tv0), $t13, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 11433);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_publish_mint_capability($tv0: $TypeValue, publish_account: $Value, cap: $Value, tc_account: $Value) returns ()
free requires is#$Address(publish_account);
free requires $Libra_MintCapability_is_well_formed(cap);
free requires is#$Address(tc_account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_publish_mint_capability_def($tv0, publish_account, cap, tc_account);
}

procedure {:inline 1} $Libra_publish_preburn_to_account_def($tv0: $TypeValue, account: $Value, tc_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $Libra_Preburn_type_value($tv0)
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 18783, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 18783, 1, tc_account); }

    // bytecode translation starts here
    // $t13 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t13 := $tmp;

    // $t14 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t14 := $tmp;

    // $t4 := Libra::is_synthetic_currency<#0>()
    call $t4 := $Libra_is_synthetic_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 34856);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // $t5 := !($t4)
    call $tmp := $Not($t4);
    $t5 := $tmp;

    // $t2 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 18924, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t7 := $tmp;

    // destroy($t7)

    // $t8 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 4
    $tmp := $Integer(4);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(14, 18924); }
    goto Abort;

    // L0:
L0:

    // $t10 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t10 := $tmp;

    // $t11 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t11 := $tmp;

    // $t12 := Libra::create_preburn<#0>($t11)
    call $t12 := $Libra_create_preburn($tv0, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 18190);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t12);


    // move_to<Libra::Preburn<#0>>($t12, $t10)
    call $MoveTo($Libra_Preburn_type_value($tv0), $t12, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 19000);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_publish_preburn_to_account($tv0: $TypeValue, account: $Value, tc_account: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(tc_account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_publish_preburn_to_account_def($tv0, account, tc_account);
}

procedure {:inline 1} $Libra_register_currency_def($tv0: $TypeValue, account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $Vector_type_value($IntegerType())
    var $t31: $Value; // $BooleanType()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $Event_EventHandle_type_value($Libra_MintEvent_type_value())
    var $t34: $Value; // $AddressType()
    var $t35: $Value; // $Event_EventHandle_type_value($Libra_BurnEvent_type_value())
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $Event_EventHandle_type_value($Libra_PreburnEvent_type_value())
    var $t38: $Value; // $AddressType()
    var $t39: $Value; // $Event_EventHandle_type_value($Libra_CancelBurnEvent_type_value())
    var $t40: $Value; // $AddressType()
    var $t41: $Value; // $Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value())
    var $t42: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t43: $Value; // $Vector_type_value($IntegerType())
    var $t44: $Value; // $AddressType()
    var $t45: $Value; // $Libra_CurrencyRegistrationCapability_type_value()
    var $t46: $Value; // $RegisteredCurrencies_RegistrationCapability_type_value()
    var $t47: $Value; // $BooleanType()
    var $t48: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t49: $Value; // $BooleanType()
    var $t50: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t51: $Value; // $AddressType()
    var $t52: $Value; // $AddressType()
    var $t53: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t54: $Value; // $BooleanType()
    var $t55: $Value; // $IntegerType()
    var $t56: $Value; // $IntegerType()
    var $t57: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 31168, 0, account); }
    if (true) { assume $DebugTrackLocal(14, 31168, 1, tc_account); }
    if (true) { assume $DebugTrackLocal(14, 31168, 2, to_lbr_exchange_rate); }
    if (true) { assume $DebugTrackLocal(14, 31168, 3, is_synthetic); }
    if (true) { assume $DebugTrackLocal(14, 31168, 4, scaling_factor); }
    if (true) { assume $DebugTrackLocal(14, 31168, 5, fractional_part); }
    if (true) { assume $DebugTrackLocal(14, 31168, 6, currency_code); }

    // bytecode translation starts here
    // $t51 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t51 := $tmp;

    // $t52 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t52 := $tmp;

    // $t53 := move(to_lbr_exchange_rate)
    call $tmp := $CopyOrMoveValue(to_lbr_exchange_rate);
    $t53 := $tmp;

    // $t54 := move(is_synthetic)
    call $tmp := $CopyOrMoveValue(is_synthetic);
    $t54 := $tmp;

    // $t55 := move(scaling_factor)
    call $tmp := $CopyOrMoveValue(scaling_factor);
    $t55 := $tmp;

    // $t56 := move(fractional_part)
    call $tmp := $CopyOrMoveValue(fractional_part);
    $t56 := $tmp;

    // $t57 := move(currency_code)
    call $tmp := $CopyOrMoveValue(currency_code);
    $t57 := $tmp;

    // $t11 := move($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t11 := $tmp;

    // $t12 := Roles::has_register_new_currency_privilege($t11)
    call $t12 := $Roles_has_register_new_currency_privilege($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 31557);
      goto Abort;
    }
    assume is#$Boolean($t12);


    // $t7 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 31543, 7, $tmp); }

    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t14 := move($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t14 := $tmp;

    // destroy($t14)

    // $t15 := 7
    $tmp := $Integer(7);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(14, 31543); }
    goto Abort;

    // L0:
L0:

    // $t16 := copy($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t16 := $tmp;

    // $t17 := Signer::address_of($t16)
    call $t17 := $Signer_address_of($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 31765);
      goto Abort;
    }
    assume is#$Address($t17);


    // $t18 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t18 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 31803);
      goto Abort;
    }
    assume is#$Address($t18);


    // $t19 := ==($t17, $t18)
    $tmp := $Boolean($IsEqual($t17, $t18));
    $t19 := $tmp;

    // $t9 := $t19
    call $tmp := $CopyOrMoveValue($t19);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 31737, 9, $tmp); }

    // if ($t9) goto L2 else goto L3
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t21 := move($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t21 := $tmp;

    // destroy($t21)

    // $t22 := 1
    $tmp := $Integer(1);
    $t22 := $tmp;

    // abort($t22)
    if (true) { assume $DebugTrackAbort(14, 31737); }
    goto Abort;

    // L2:
L2:

    // $t23 := copy($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t23 := $tmp;

    // $t24 := 0
    $tmp := $Integer(0);
    $t24 := $tmp;

    // $t25 := 0
    $tmp := $Integer(0);
    $t25 := $tmp;

    // $t31 := true
    $tmp := $Boolean(true);
    $t31 := $tmp;

    // $t32 := copy($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t32 := $tmp;

    // $t33 := Event::new_event_handle<Libra::MintEvent>($t32)
    call $t33 := $Event_new_event_handle($Libra_MintEvent_type_value(), $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32211);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t33);


    // $t34 := copy($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t34 := $tmp;

    // $t35 := Event::new_event_handle<Libra::BurnEvent>($t34)
    call $t35 := $Event_new_event_handle($Libra_BurnEvent_type_value(), $t34);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32281);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t35);


    // $t36 := copy($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t36 := $tmp;

    // $t37 := Event::new_event_handle<Libra::PreburnEvent>($t36)
    call $t37 := $Event_new_event_handle($Libra_PreburnEvent_type_value(), $t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32354);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t37);


    // $t38 := copy($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t38 := $tmp;

    // $t39 := Event::new_event_handle<Libra::CancelBurnEvent>($t38)
    call $t39 := $Event_new_event_handle($Libra_CancelBurnEvent_type_value(), $t38);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32434);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t39);


    // $t40 := move($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t40 := $tmp;

    // $t41 := Event::new_event_handle<Libra::ToLBRExchangeRateUpdateEvent>($t40)
    call $t41 := $Event_new_event_handle($Libra_ToLBRExchangeRateUpdateEvent_type_value(), $t40);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32526);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t41);


    // $t42 := pack Libra::CurrencyInfo<#0>($t24, $t25, $t53, $t54, $t55, $t56, $t57, $t31, $t33, $t35, $t37, $t39, $t41)
    call $tmp := $Libra_CurrencyInfo_pack(0, 0, 0, $tv0, $t24, $t25, $t53, $t54, $t55, $t56, $t57, $t31, $t33, $t35, $t37, $t39, $t41);
    $t42 := $tmp;

    // move_to<Libra::CurrencyInfo<#0>>($t42, $t23)
    call $MoveTo($Libra_CurrencyInfo_type_value($tv0), $t42, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 31887);
      goto Abort;
    }

    // $t44 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t44 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32744);
      goto Abort;
    }
    assume is#$Address($t44);


    // $t45 := get_global<Libra::CurrencyRegistrationCapability>($t44)
    call $tmp := $GetGlobal($t44, $Libra_CurrencyRegistrationCapability_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32683);
      goto Abort;
    }
    assume $Libra_CurrencyRegistrationCapability_is_well_formed($tmp);
    $t45 := $tmp;

    // $t46 := get_field<Libra::CurrencyRegistrationCapability>.cap($t45)
    call $tmp := $GetFieldFromValue($t45, $Libra_CurrencyRegistrationCapability_cap);
    assume $RegisteredCurrencies_RegistrationCapability_is_well_formed($tmp);
    $t46 := $tmp;

    // RegisteredCurrencies::add_currency_code($t57, $t46)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))));
    call $RegisteredCurrencies_add_currency_code($t57, $t46);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 32624);
      goto Abort;
    }

    // $t47 := false
    $tmp := $Boolean(false);
    $t47 := $tmp;

    // $t48 := pack Libra::MintCapability<#0>($t47)
    call $tmp := $Libra_MintCapability_pack(0, 0, 0, $tv0, $t47);
    $t48 := $tmp;

    // $t49 := false
    $tmp := $Boolean(false);
    $t49 := $tmp;

    // $t50 := pack Libra::BurnCapability<#0>($t49)
    call $tmp := $Libra_BurnCapability_pack(0, 0, 0, $tv0, $t49);
    $t50 := $tmp;

    // return ($t48, $t50)
    $ret0 := $t48;
    if (true) { assume $DebugTrackLocal(14, 32789, 58, $ret0); }
    $ret1 := $t50;
    if (true) { assume $DebugTrackLocal(14, 32789, 59, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Libra_register_currency($tv0: $TypeValue, account: $Value, tc_account: $Value, to_lbr_exchange_rate: $Value, is_synthetic: $Value, scaling_factor: $Value, fractional_part: $Value, currency_code: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires is#$Address(account);
free requires is#$Address(tc_account);
free requires $FixedPoint32_FixedPoint32_is_well_formed(to_lbr_exchange_rate);
free requires is#$Boolean(is_synthetic);
free requires $IsValidU64(scaling_factor);
free requires $IsValidU64(fractional_part);
free requires $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege($m, $txn, tc_account))))
    || b#$Boolean($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, account), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_CurrencyRegistrationCapability_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean($ResourceExists($m, $Libra_CurrencyInfo_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))
    || b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))
    || b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))
    || b#$Boolean($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege($m, $txn, tc_account))))
    || b#$Boolean($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, account), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())))
    || b#$Boolean($Boolean(!b#$Boolean($ResourceExists($m, $Libra_CurrencyRegistrationCapability_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))
    || b#$Boolean($ResourceExists($m, $Libra_CurrencyInfo_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))
    || b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))
    || b#$Boolean($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))
    || b#$Boolean($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege($m, $txn, tc_account))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, account), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $Libra_CurrencyRegistrationCapability_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))) ==> $abort_flag;
free ensures b#$Boolean(old($ResourceExists($m, $Libra_CurrencyInfo_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))) ==> $abort_flag;
free ensures b#$Boolean(old($Libra_spec_is_currency($m, $txn, $tv0))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))) ==> $abort_flag;
free ensures b#$Boolean(old($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Roles_spec_has_register_new_currency_privilege($m, $txn, tc_account))))))
    || b#$Boolean(old(($Boolean(!$IsEqual($Signer_spec_address_of($m, $txn, account), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS())))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $Libra_CurrencyRegistrationCapability_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS()))))))
    || b#$Boolean(old(($ResourceExists($m, $Libra_CurrencyInfo_type_value($tv0), $Signer_spec_address_of($m, $txn, account)))))
    || b#$Boolean(old(($Libra_spec_is_currency($m, $txn, $tv0))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($LibraConfig_spec_is_published($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()))))))
    || b#$Boolean(old(($Vector_spec_contains($Vector_type_value($IntegerType()), $SelectField($LibraConfig_spec_get($m, $txn, $RegisteredCurrencies_RegisteredCurrencies_type_value()), $RegisteredCurrencies_RegisteredCurrencies_currency_codes), currency_code)))));
free ensures !$abort_flag ==> (b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0, $ret1 := $Libra_register_currency_def($tv0, account, tc_account, to_lbr_exchange_rate, is_synthetic, scaling_factor, fractional_part, currency_code);
}

procedure {:inline 1} $Libra_scaling_factor_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $t1: $Value; // $Libra_CurrencyInfo_type_value($tv0)
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35348);
      goto Abort;
    }
    assume is#$Address($t0);


    // $t1 := get_global<Libra::CurrencyInfo<#0>>($t0)
    call $tmp := $GetGlobal($t0, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 35295);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($tmp);
    $t1 := $tmp;

    // $t2 := get_field<Libra::CurrencyInfo<#0>>.scaling_factor($t1)
    call $tmp := $GetFieldFromValue($t1, $Libra_CurrencyInfo_scaling_factor);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 35295, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_scaling_factor($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_scaling_factor_def($tv0);
}

procedure {:inline 1} $Libra_remove_burn_capability_def($tv0: $TypeValue, account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 25979, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := Signer::address_of($t1)
    call $t2 := $Signer_address_of($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 26149);
      goto Abort;
    }
    assume is#$Address($t2);


    // $t3 := move_from<Libra::BurnCapability<#0>>($t2)
    call $tmp := $MoveFrom($t2, $Libra_BurnCapability_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 26105);
      goto Abort;
    }
    assume $Libra_BurnCapability_is_well_formed($tmp);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 26105, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_remove_burn_capability($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_remove_burn_capability_def($tv0, account);
}

procedure {:inline 1} $Libra_remove_mint_capability_def($tv0: $TypeValue, account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $Libra_MintCapability_type_value($tv0)
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 25559, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := Signer::address_of($t1)
    call $t2 := $Signer_address_of($t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 25729);
      goto Abort;
    }
    assume is#$Address($t2);


    // $t3 := move_from<Libra::MintCapability<#0>>($t2)
    call $tmp := $MoveFrom($t2, $Libra_MintCapability_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 25685);
      goto Abort;
    }
    assume $Libra_MintCapability_is_well_formed($tmp);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(14, 25685, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_remove_mint_capability($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_remove_mint_capability_def($tv0, account);
}

procedure {:inline 1} $Libra_split_def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var other: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $Libra_Libra_type_value($tv0)
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $Libra_Libra_type_value($tv0)
    var $t8: $Value; // $Libra_Libra_type_value($tv0)
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 27374, 0, coin); }
    if (true) { assume $DebugTrackLocal(14, 27374, 1, amount); }

    // bytecode translation starts here
    // $t8 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t8 := $tmp;

    // $t9 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t9 := $tmp;

    // $t3 := borrow_local($t8)
    call $t3 := $BorrowLoc(8, $t8);
    assume $Libra_Libra_is_well_formed($Dereference($t3));

    // UnpackRef($t3)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t3));

    // PackRef($t3)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t3));

    // $t10 := read_ref($t3)
    call $tmp := $ReadRef($t3);
    assume $Libra_Libra_is_well_formed($tmp);
    $t10 := $tmp;

    // ($t5, $t10) := Libra::withdraw<#0>($t10, $t9)
    call $t5, $t10 := $Libra_withdraw($tv0, $t10, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 28102);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t5);

    assume $Libra_Libra_is_well_formed($t10);


    // write_ref($t3, $t10)
    call $t3 := $WriteRef($t3, $t10);

    // LocalRoot($t8) <- $t3
    call $t8 := $WritebackToValue($t3, 8, $t8);

    // UnpackRef($t3)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t3));

    // PackRef($t3)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t3));

    // other := $t5
    call $tmp := $CopyOrMoveValue($t5);
    other := $tmp;
    if (true) { assume $DebugTrackLocal(14, 27487, 2, $tmp); }

    // return ($t8, other)
    $ret0 := $t8;
    if (true) { assume $DebugTrackLocal(14, 27532, 11, $ret0); }
    $ret1 := other;
    if (true) { assume $DebugTrackLocal(14, 27532, 12, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Libra_split($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $Libra_Libra_is_well_formed(coin);
free requires $IsValidU64(amount);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)));
free ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), $Integer(i#$Integer($SelectField(coin, $Libra_Libra_value)) - i#$Integer(amount))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), amount))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0, $ret1 := $Libra_split_def($tv0, coin, amount);
}

procedure {:inline 1} $Libra_update_lbr_exchange_rate_def($tv0: $TypeValue, tr_account: $Value, lbr_exchange_rate: $Value) returns (){
    // declare local variables
    var currency_info: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t11: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t12: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t13: $Reference; // ReferenceType($FixedPoint32_FixedPoint32_type_value())
    var $t14: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t15: $Reference; // ReferenceType($Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value()))
    var $t16: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t20: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t21: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $Libra_ToLBRExchangeRateUpdateEvent_type_value()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t26: $Value; // $Event_EventHandle_type_value($Libra_ToLBRExchangeRateUpdateEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 36164, 0, tr_account); }
    if (true) { assume $DebugTrackLocal(14, 36164, 1, lbr_exchange_rate); }

    // bytecode translation starts here
    // $t24 := move(tr_account)
    call $tmp := $CopyOrMoveValue(tr_account);
    $t24 := $tmp;

    // $t25 := move(lbr_exchange_rate)
    call $tmp := $CopyOrMoveValue(lbr_exchange_rate);
    $t25 := $tmp;

    // $t5 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t5 := $tmp;

    // $t6 := Roles::has_treasury_compliance_role($t5)
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 36336);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 36322, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := 2
    $tmp := $Integer(2);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(14, 36322); }
    goto Abort;

    // L0:
L0:

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t9 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t9 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 36538);
      goto Abort;
    }
    assume is#$Address($t9);


    // $t10 := borrow_global<Libra::CurrencyInfo<#0>>($t9)
    call $t10 := $BorrowGlobal($t9, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 36477);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($Dereference($t10));

    // UnpackRef($t10)

    // currency_info := $t10
    call currency_info := $CopyOrMoveRef($t10);
    if (true) { assume $DebugTrackLocal(14, 36461, 2, $Dereference(currency_info)); }

    // $t12 := copy(currency_info)
    call $t12 := $CopyOrMoveRef(currency_info);

    // $t13 := borrow_field<Libra::CurrencyInfo<#0>>.to_lbr_exchange_rate($t12)
    call $t13 := $BorrowField($t12, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assume $FixedPoint32_FixedPoint32_is_well_formed_types($Dereference($t13));

    // Reference(currency_info) <- $t12
    call currency_info := $WritebackToReference($t12, currency_info);

    // UnpackRef($t13)

    // write_ref($t13, $t25)
    call $t13 := $WriteRef($t13, $t25);
    if (true) { assume $DebugTrackLocal(14, 36572, 2, $Dereference(currency_info)); }

    // Reference(currency_info) <- $t13
    call currency_info := $WritebackToReference($t13, currency_info);

    // Reference($t12) <- $t13
    call $t12 := $WritebackToReference($t13, $t12);

    // PackRef($t13)

    // $t14 := copy(currency_info)
    call $t14 := $CopyOrMoveRef(currency_info);

    // $t15 := borrow_field<Libra::CurrencyInfo<#0>>.exchange_rate_update_events($t14)
    call $t15 := $BorrowField($t14, $Libra_CurrencyInfo_exchange_rate_update_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t15));

    // Reference(currency_info) <- $t14
    call currency_info := $WritebackToReference($t14, currency_info);

    // UnpackRef($t15)

    // $t16 := copy(currency_info)
    call $t16 := $CopyOrMoveRef(currency_info);

    // $t17 := get_field<Libra::CurrencyInfo<#0>>.currency_code($t16)
    call $tmp := $GetFieldFromReference($t16, $Libra_CurrencyInfo_currency_code);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t17 := $tmp;

    // Reference(currency_info) <- $t16
    call currency_info := $WritebackToReference($t16, currency_info);

    // $t18 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;

    // $t19 := move(currency_info)
    call $t19 := $CopyOrMoveRef(currency_info);

    // $t20 := get_field<Libra::CurrencyInfo<#0>>.to_lbr_exchange_rate($t19)
    call $tmp := $GetFieldFromReference($t19, $Libra_CurrencyInfo_to_lbr_exchange_rate);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t20 := $tmp;

    // Libra::CurrencyInfo <- $t19
    call $WritebackToGlobal($t19);

    // $t21 := move($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t21 := $tmp;

    // $t22 := FixedPoint32::get_raw_value($t21)
    call $t22 := $FixedPoint32_get_raw_value($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 36876);
      goto Abort;
    }
    assume $IsValidU64($t22);


    // $t23 := pack Libra::ToLBRExchangeRateUpdateEvent($t18, $t22)
    call $tmp := $Libra_ToLBRExchangeRateUpdateEvent_pack(0, 0, 0, $t18, $t22);
    $t23 := $tmp;

    // PackRef($t15)

    // $t26 := read_ref($t15)
    call $tmp := $ReadRef($t15);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t26 := $tmp;

    // $t26 := Event::emit_event<Libra::ToLBRExchangeRateUpdateEvent>($t26, $t23)
    call $t26 := $Event_emit_event($Libra_ToLBRExchangeRateUpdateEvent_type_value(), $t26, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 36643);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t26);


    // write_ref($t15, $t26)
    call $t15 := $WriteRef($t15, $t26);
    if (true) { assume $DebugTrackLocal(14, 36164, 2, $Dereference(currency_info)); }

    // Libra::CurrencyInfo <- $t15
    call $WritebackToGlobal($t15);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // Reference($t16) <- $t15
    call $t16 := $WritebackToReference($t15, $t16);

    // Reference($t19) <- $t15
    call $t19 := $WritebackToReference($t15, $t19);

    // UnpackRef($t15)

    // PackRef($t15)

    // PackRef($t19)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_update_lbr_exchange_rate($tv0: $TypeValue, tr_account: $Value, lbr_exchange_rate: $Value) returns ()
free requires is#$Address(tr_account);
free requires $FixedPoint32_FixedPoint32_is_well_formed(lbr_exchange_rate);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_update_lbr_exchange_rate_def($tv0, tr_account, lbr_exchange_rate);
}

procedure {:inline 1} $Libra_update_minting_ability_def($tv0: $TypeValue, tr_account: $Value, can_mint: $Value) returns (){
    // declare local variables
    var currency_info: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t11: $Value; // $BooleanType()
    var $t12: $Reference; // ReferenceType($Libra_CurrencyInfo_type_value($tv0))
    var $t13: $Reference; // ReferenceType($BooleanType())
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 37753, 0, tr_account); }
    if (true) { assume $DebugTrackLocal(14, 37753, 1, can_mint); }

    // bytecode translation starts here
    // $t14 := move(tr_account)
    call $tmp := $CopyOrMoveValue(tr_account);
    $t14 := $tmp;

    // $t15 := move(can_mint)
    call $tmp := $CopyOrMoveValue(can_mint);
    $t15 := $tmp;

    // $t5 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;

    // $t6 := Roles::has_treasury_compliance_role($t5)
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 37911);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 37897, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := 2
    $tmp := $Integer(2);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(14, 37897); }
    goto Abort;

    // L0:
L0:

    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t9 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t9 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38105);
      goto Abort;
    }
    assume is#$Address($t9);


    // $t10 := borrow_global<Libra::CurrencyInfo<#0>>($t9)
    call $t10 := $BorrowGlobal($t9, $Libra_CurrencyInfo_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38048);
      goto Abort;
    }
    assume $Libra_CurrencyInfo_is_well_formed($Dereference($t10));

    // UnpackRef($t10)

    // currency_info := $t10
    call currency_info := $CopyOrMoveRef($t10);
    if (true) { assume $DebugTrackLocal(14, 38032, 2, $Dereference(currency_info)); }

    // $t12 := move(currency_info)
    call $t12 := $CopyOrMoveRef(currency_info);

    // $t13 := borrow_field<Libra::CurrencyInfo<#0>>.can_mint($t12)
    call $t13 := $BorrowField($t12, $Libra_CurrencyInfo_can_mint);
    assume is#$Boolean($Dereference($t13));

    // Libra::CurrencyInfo <- $t12
    call $WritebackToGlobal($t12);

    // UnpackRef($t13)

    // write_ref($t13, $t15)
    call $t13 := $WriteRef($t13, $t15);
    if (true) { assume $DebugTrackLocal(14, 38139, 2, $Dereference(currency_info)); }

    // Libra::CurrencyInfo <- $t13
    call $WritebackToGlobal($t13);

    // Reference($t12) <- $t13
    call $t12 := $WritebackToReference($t13, $t12);

    // PackRef($t12)

    // PackRef($t13)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Libra_update_minting_ability($tv0: $TypeValue, tr_account: $Value, can_mint: $Value) returns ()
free requires is#$Address(tr_account);
free requires is#$Boolean(can_mint);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $Libra_update_minting_ability_def($tv0, tr_account, can_mint);
}

procedure {:inline 1} $Libra_withdraw_def($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t11: $Value; // $IntegerType()
    var $t12: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t18: $Reference; // ReferenceType($IntegerType())
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $Libra_Libra_type_value($tv0)
    var $t21: $Value; // $Libra_Libra_type_value($tv0)
    var $t22: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t23: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 28091, 0, coin); }
    if (true) { assume $DebugTrackLocal(14, 28091, 1, amount); }

    // bytecode translation starts here
    // $t21 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t21 := $tmp;

    // $t23 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t23 := $tmp;

    // $t22 := borrow_local($t21)
    call $t22 := $BorrowLoc(21, $t21);
    assume $Libra_Libra_is_well_formed($Dereference($t22));

    // UnpackRef($t22)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t22));

    // $t4 := copy($t22)
    call $t4 := $CopyOrMoveRef($t22);

    // $t5 := get_field<Libra::Libra<#0>>.value($t4)
    call $tmp := $GetFieldFromReference($t4, $Libra_Libra_value);
    assume $IsValidU64($tmp);
    $t5 := $tmp;

    // Reference($t22) <- $t4
    call $t22 := $WritebackToReference($t4, $t22);

    // $t6 := move($t5)
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;

    // $t8 := >=($t6, $t23)
    call $tmp := $Ge($t6, $t23);
    $t8 := $tmp;

    // $t2 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(14, 28250, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t22)
    call $t10 := $CopyOrMoveRef($t22);

    // destroy($t10)

    // LocalRoot($t21) <- $t10
    call $t21 := $WritebackToValue($t10, 21, $t21);

    // PackRef($t10)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t10));

    // $t11 := 5
    $tmp := $Integer(5);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(14, 28250); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t22)
    call $t12 := $CopyOrMoveRef($t22);

    // $t13 := get_field<Libra::Libra<#0>>.value($t12)
    call $tmp := $GetFieldFromReference($t12, $Libra_Libra_value);
    assume $IsValidU64($tmp);
    $t13 := $tmp;

    // Reference($t22) <- $t12
    call $t22 := $WritebackToReference($t12, $t22);

    // $t14 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t14 := $tmp;

    // $t16 := -($t14, $t23)
    call $tmp := $Sub($t14, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 28340);
      goto Abort;
    }
    $t16 := $tmp;

    // $t17 := move($t22)
    call $t17 := $CopyOrMoveRef($t22);

    // $t18 := borrow_field<Libra::Libra<#0>>.value($t17)
    call $t18 := $BorrowField($t17, $Libra_Libra_value);
    assume $IsValidU64($Dereference($t18));

    // LocalRoot($t21) <- $t17
    call $t21 := $WritebackToValue($t17, 21, $t21);

    // UnpackRef($t18)

    // write_ref($t18, $t16)
    call $t18 := $WriteRef($t18, $t16);

    // LocalRoot($t21) <- $t18
    call $t21 := $WritebackToValue($t18, 21, $t21);

    // Reference($t17) <- $t18
    call $t17 := $WritebackToReference($t18, $t17);

    // PackRef($t17)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t17));

    // PackRef($t18)

    // $t20 := pack Libra::Libra<#0>($t23)
    call $tmp := $Libra_Libra_pack(0, 0, 0, $tv0, $t23);
    $t20 := $tmp;

    // return ($t20, $t21)
    $ret0 := $t20;
    if (true) { assume $DebugTrackLocal(14, 28358, 24, $ret0); }
    $ret1 := $t21;
    if (true) { assume $DebugTrackLocal(14, 28358, 25, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Libra_withdraw($tv0: $TypeValue, coin: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $Libra_Libra_is_well_formed(coin);
free requires $IsValidU64(amount);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)));
free ensures b#$Boolean(old($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount)))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(i#$Integer($SelectField(coin, $Libra_Libra_value)) < i#$Integer(amount))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(i#$Integer(old($SelectField(coin, $Libra_Libra_value))) - i#$Integer(amount))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), amount))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0, $ret1 := $Libra_withdraw_def($tv0, coin, amount);
}

procedure {:inline 1} $Libra_withdraw_all_def($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var val: $Value; // $IntegerType()
    var $t2: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $Libra_Libra_type_value($tv0)
    var $t8: $Value; // $Libra_Libra_type_value($tv0)
    var $t9: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(14, 28689, 0, coin); }

    // bytecode translation starts here
    // $t8 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t8 := $tmp;

    // $t9 := borrow_local($t8)
    call $t9 := $BorrowLoc(8, $t8);
    assume $Libra_Libra_is_well_formed($Dereference($t9));

    // UnpackRef($t9)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t9));

    // $t2 := copy($t9)
    call $t2 := $CopyOrMoveRef($t9);

    // $t3 := get_field<Libra::Libra<#0>>.value($t2)
    call $tmp := $GetFieldFromReference($t2, $Libra_Libra_value);
    assume $IsValidU64($tmp);
    $t3 := $tmp;

    // Reference($t9) <- $t2
    call $t9 := $WritebackToReference($t2, $t9);

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // val := $t4
    call $tmp := $CopyOrMoveValue($t4);
    val := $tmp;
    if (true) { assume $DebugTrackLocal(14, 28782, 1, $tmp); }

    // $t5 := move($t9)
    call $t5 := $CopyOrMoveRef($t9);

    // PackRef($t5)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t5));

    // $t10 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $Libra_Libra_is_well_formed($tmp);
    $t10 := $tmp;

    // ($t7, $t10) := Libra::withdraw<#0>($t10, val)
    call $t7, $t10 := $Libra_withdraw($tv0, $t10, val);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 28102);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t7);

    assume $Libra_Libra_is_well_formed($t10);


    // write_ref($t5, $t10)
    call $t5 := $WriteRef($t5, $t10);

    // LocalRoot($t8) <- $t5
    call $t8 := $WritebackToValue($t5, 8, $t8);

    // UnpackRef($t5)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t5));

    // PackRef($t5)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t5));

    // return ($t7, $t8)
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(14, 28808, 11, $ret0); }
    $ret1 := $t8;
    if (true) { assume $DebugTrackLocal(14, 28808, 12, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Libra_withdraw_all($tv0: $TypeValue, coin: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $Libra_Libra_is_well_formed(coin);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))))
    || b#$Boolean($Boolean(false));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))))
    || b#$Boolean($Boolean(false));
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $Libra_Libra_value), old($SelectField(coin, $Libra_Libra_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret1, $Libra_Libra_value), $Integer(0)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0, $ret1 := $Libra_withdraw_all_def($tv0, coin);
}

procedure {:inline 1} $Libra_zero_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $IntegerType()
    var $t1: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // Libra::assert_is_currency<#0>()
    call $Libra_assert_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(14, 38432);
      goto Abort;
    }

    // $t0 := 0
    $tmp := $Integer(0);
    $t0 := $tmp;

    // $t1 := pack Libra::Libra<#0>($t0)
    call $tmp := $Libra_Libra_pack(0, 0, 0, $tv0, $t0);
    $t1 := $tmp;

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(14, 26853, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Libra_zero($tv0: $TypeValue) returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
requires b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], old($Libra_sum_of_coin_values[$tv0])))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value)))))));
{
    call $ret0 := $Libra_zero_def($tv0);
}



// ** spec vars of module Coin2



// ** spec funs of module Coin2



// ** structs of module Coin2

const unique $Coin2_Coin2: $TypeName;
const $Coin2_Coin2_dummy_field: $FieldName;
axiom $Coin2_Coin2_dummy_field == 0;
function $Coin2_Coin2_type_value(): $TypeValue {
    $StructType($Coin2_Coin2, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $Coin2_Coin2_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Coin2_Coin2_dummy_field))
}
function {:inline} $Coin2_Coin2_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Coin2_Coin2_dummy_field))
}

procedure {:inline 1} $Coin2_Coin2_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Coin2_Coin2_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Coin2_Coin2_dummy_field);
    assume is#$Boolean(dummy_field);
}



// ** functions of module Coin2

procedure {:inline 1} $Coin2_initialize_def(lr_account: $Value, tc_account: $Value) returns (){
    // declare local variables
    var coin2_burn_cap: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var coin2_mint_cap: $Value; // $Libra_MintCapability_type_value($Coin2_Coin2_type_value())
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $Libra_MintCapability_type_value($Coin2_Coin2_type_value())
    var $t14: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Libra_MintCapability_type_value($Coin2_Coin2_type_value())
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(4, 104, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(4, 104, 1, tc_account); }

    // bytecode translation starts here
    // $t21 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t21 := $tmp;

    // $t22 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t22 := $tmp;

    // $t4 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t4 := $tmp;

    // $t5 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;

    // $t6 := 1
    $tmp := $Integer(1);
    $t6 := $tmp;

    // $t7 := 2
    $tmp := $Integer(2);
    $t7 := $tmp;

    // $t8 := FixedPoint32::create_from_rational($t6, $t7)
    call $t8 := $FixedPoint32_create_from_rational($t6, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 411);
      goto Abort;
    }
    assume $FixedPoint32_FixedPoint32_is_well_formed($t8);


    // $t9 := false
    $tmp := $Boolean(false);
    $t9 := $tmp;

    // $t10 := 1000000
    $tmp := $Integer(1000000);
    $t10 := $tmp;

    // $t11 := 100
    $tmp := $Integer(100);
    $t11 := $tmp;

    // $t12 := [67, 111, 105, 110, 50]
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(67)][1 := $Integer(111)][2 := $Integer(105)][3 := $Integer(110)][4 := $Integer(50)], 5));
    $t12 := $tmp;

    // ($t13, $t14) := Libra::register_currency<Coin2::Coin2>($t4, $t5, $t8, $t9, $t10, $t11, $t12)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t13, $t14 := $Libra_register_currency($Coin2_Coin2_type_value(), $t4, $t5, $t8, $t9, $t10, $t11, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 299);
      goto Abort;
    }
    assume $Libra_MintCapability_is_well_formed($t13);

    assume $Libra_BurnCapability_is_well_formed($t14);


    // coin2_burn_cap := $t14
    call $tmp := $CopyOrMoveValue($t14);
    coin2_burn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(4, 262, 2, $tmp); }

    // coin2_mint_cap := $t13
    call $tmp := $CopyOrMoveValue($t13);
    coin2_mint_cap := $tmp;
    if (true) { assume $DebugTrackLocal(4, 246, 3, $tmp); }

    // $t15 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t15 := $tmp;

    // $t17 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t17 := $tmp;

    // Libra::publish_mint_capability<Coin2::Coin2>($t15, coin2_mint_cap, $t17)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_mint_capability($Coin2_Coin2_type_value(), $t15, coin2_mint_cap, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 661);
      goto Abort;
    }

    // $t18 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;

    // $t20 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t20 := $tmp;

    // Libra::publish_burn_capability<Coin2::Coin2>($t18, coin2_burn_cap, $t20)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_burn_capability($Coin2_Coin2_type_value(), $t18, coin2_burn_cap, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(4, 748);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Coin2_initialize(lr_account: $Value, tc_account: $Value) returns ()
free requires is#$Address(lr_account);
free requires is#$Address(tc_account);
{
    call $Coin2_initialize_def(lr_account, tc_account);
}



// ** spec vars of module Coin1



// ** spec funs of module Coin1



// ** structs of module Coin1

const unique $Coin1_Coin1: $TypeName;
const $Coin1_Coin1_dummy_field: $FieldName;
axiom $Coin1_Coin1_dummy_field == 0;
function $Coin1_Coin1_type_value(): $TypeValue {
    $StructType($Coin1_Coin1, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $Coin1_Coin1_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Coin1_Coin1_dummy_field))
}
function {:inline} $Coin1_Coin1_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $Coin1_Coin1_dummy_field))
}

procedure {:inline 1} $Coin1_Coin1_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $Coin1_Coin1_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $Coin1_Coin1_dummy_field);
    assume is#$Boolean(dummy_field);
}



// ** functions of module Coin1

procedure {:inline 1} $Coin1_initialize_def(lr_account: $Value, tc_account: $Value) returns (){
    // declare local variables
    var coin1_burn_cap: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var coin1_mint_cap: $Value; // $Libra_MintCapability_type_value($Coin1_Coin1_type_value())
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $Libra_MintCapability_type_value($Coin1_Coin1_type_value())
    var $t14: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Libra_MintCapability_type_value($Coin1_Coin1_type_value())
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(3, 104, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(3, 104, 1, tc_account); }

    // bytecode translation starts here
    // $t21 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t21 := $tmp;

    // $t22 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t22 := $tmp;

    // $t4 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t4 := $tmp;

    // $t5 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;

    // $t6 := 1
    $tmp := $Integer(1);
    $t6 := $tmp;

    // $t7 := 2
    $tmp := $Integer(2);
    $t7 := $tmp;

    // $t8 := FixedPoint32::create_from_rational($t6, $t7)
    call $t8 := $FixedPoint32_create_from_rational($t6, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 411);
      goto Abort;
    }
    assume $FixedPoint32_FixedPoint32_is_well_formed($t8);


    // $t9 := false
    $tmp := $Boolean(false);
    $t9 := $tmp;

    // $t10 := 1000000
    $tmp := $Integer(1000000);
    $t10 := $tmp;

    // $t11 := 100
    $tmp := $Integer(100);
    $t11 := $tmp;

    // $t12 := [67, 111, 105, 110, 49]
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(67)][1 := $Integer(111)][2 := $Integer(105)][3 := $Integer(110)][4 := $Integer(49)], 5));
    $t12 := $tmp;

    // ($t13, $t14) := Libra::register_currency<Coin1::Coin1>($t4, $t5, $t8, $t9, $t10, $t11, $t12)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t13, $t14 := $Libra_register_currency($Coin1_Coin1_type_value(), $t4, $t5, $t8, $t9, $t10, $t11, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 299);
      goto Abort;
    }
    assume $Libra_MintCapability_is_well_formed($t13);

    assume $Libra_BurnCapability_is_well_formed($t14);


    // coin1_burn_cap := $t14
    call $tmp := $CopyOrMoveValue($t14);
    coin1_burn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(3, 262, 2, $tmp); }

    // coin1_mint_cap := $t13
    call $tmp := $CopyOrMoveValue($t13);
    coin1_mint_cap := $tmp;
    if (true) { assume $DebugTrackLocal(3, 246, 3, $tmp); }

    // $t15 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t15 := $tmp;

    // $t17 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t17 := $tmp;

    // Libra::publish_mint_capability<Coin1::Coin1>($t15, coin1_mint_cap, $t17)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_mint_capability($Coin1_Coin1_type_value(), $t15, coin1_mint_cap, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 660);
      goto Abort;
    }

    // $t18 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t18 := $tmp;

    // $t20 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t20 := $tmp;

    // Libra::publish_burn_capability<Coin1::Coin1>($t18, coin1_burn_cap, $t20)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_burn_capability($Coin1_Coin1_type_value(), $t18, coin1_burn_cap, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(3, 747);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Coin1_initialize(lr_account: $Value, tc_account: $Value) returns ()
free requires is#$Address(lr_account);
free requires is#$Address(tc_account);
{
    call $Coin1_initialize_def(lr_account, tc_account);
}



// ** spec vars of module LBR



// ** spec funs of module LBR



// ** structs of module LBR

const unique $LBR_LBR: $TypeName;
const $LBR_LBR_dummy_field: $FieldName;
axiom $LBR_LBR_dummy_field == 0;
function $LBR_LBR_type_value(): $TypeValue {
    $StructType($LBR_LBR, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $LBR_LBR_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LBR_LBR_dummy_field))
}
function {:inline} $LBR_LBR_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LBR_LBR_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LBR_LBR_is_well_formed($ResourceValue(m, $LBR_LBR_type_value(), a))
);

procedure {:inline 1} $LBR_LBR_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LBR_LBR_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LBR_LBR_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $LBR_Reserve: $TypeName;
const $LBR_Reserve_mint_cap: $FieldName;
axiom $LBR_Reserve_mint_cap == 0;
const $LBR_Reserve_burn_cap: $FieldName;
axiom $LBR_Reserve_burn_cap == 1;
const $LBR_Reserve_preburn_cap: $FieldName;
axiom $LBR_Reserve_preburn_cap == 2;
const $LBR_Reserve_coin1: $FieldName;
axiom $LBR_Reserve_coin1 == 3;
const $LBR_Reserve_coin2: $FieldName;
axiom $LBR_Reserve_coin2 == 4;
function $LBR_Reserve_type_value(): $TypeValue {
    $StructType($LBR_Reserve, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Libra_MintCapability_type_value($LBR_LBR_type_value())][1 := $Libra_BurnCapability_type_value($LBR_LBR_type_value())][2 := $Libra_Preburn_type_value($LBR_LBR_type_value())][3 := $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())][4 := $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())], 5))
}
function {:inline} $LBR_Reserve_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 5
      && $Libra_MintCapability_is_well_formed_types($SelectField($this, $LBR_Reserve_mint_cap))
      && $Libra_BurnCapability_is_well_formed_types($SelectField($this, $LBR_Reserve_burn_cap))
      && $Libra_Preburn_is_well_formed_types($SelectField($this, $LBR_Reserve_preburn_cap))
      && $LBR_ReserveComponent_is_well_formed_types($SelectField($this, $LBR_Reserve_coin1))
      && $LBR_ReserveComponent_is_well_formed_types($SelectField($this, $LBR_Reserve_coin2))
}
function {:inline} $LBR_Reserve_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 5
      && $Libra_MintCapability_is_well_formed($SelectField($this, $LBR_Reserve_mint_cap))
      && $Libra_BurnCapability_is_well_formed($SelectField($this, $LBR_Reserve_burn_cap))
      && $Libra_Preburn_is_well_formed($SelectField($this, $LBR_Reserve_preburn_cap))
      && $LBR_ReserveComponent_is_well_formed($SelectField($this, $LBR_Reserve_coin1))
      && $LBR_ReserveComponent_is_well_formed($SelectField($this, $LBR_Reserve_coin2))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LBR_Reserve_is_well_formed($ResourceValue(m, $LBR_Reserve_type_value(), a))
);

procedure {:inline 1} $LBR_Reserve_before_update_inv($before: $Value) {
    call $LBR_ReserveComponent_before_update_inv($Coin1_Coin1_type_value(), $SelectField($before, $LBR_Reserve_coin1));
    call $LBR_ReserveComponent_before_update_inv($Coin2_Coin2_type_value(), $SelectField($before, $LBR_Reserve_coin2));
}

procedure {:inline 1} $LBR_Reserve_after_update_inv($after: $Value) {
    call $LBR_ReserveComponent_after_update_inv($Coin1_Coin1_type_value(), $SelectField($after, $LBR_Reserve_coin1));
    call $LBR_ReserveComponent_after_update_inv($Coin2_Coin2_type_value(), $SelectField($after, $LBR_Reserve_coin2));
}

procedure {:inline 1} $LBR_Reserve_pack($file_id: int, $byte_index: int, $var_idx: int, mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value, coin1: $Value, coin2: $Value) returns ($struct: $Value)
{
    assume $Libra_MintCapability_is_well_formed(mint_cap);
    assume $Libra_BurnCapability_is_well_formed(burn_cap);
    assume $Libra_Preburn_is_well_formed(preburn_cap);
    assume $LBR_ReserveComponent_is_well_formed(coin1);
    assume $LBR_ReserveComponent_is_well_formed(coin2);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := mint_cap][1 := burn_cap][2 := preburn_cap][3 := coin1][4 := coin2], 5));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LBR_Reserve_unpack($struct: $Value) returns (mint_cap: $Value, burn_cap: $Value, preburn_cap: $Value, coin1: $Value, coin2: $Value)
{
    assume is#$Vector($struct);
    mint_cap := $SelectField($struct, $LBR_Reserve_mint_cap);
    assume $Libra_MintCapability_is_well_formed(mint_cap);
    burn_cap := $SelectField($struct, $LBR_Reserve_burn_cap);
    assume $Libra_BurnCapability_is_well_formed(burn_cap);
    preburn_cap := $SelectField($struct, $LBR_Reserve_preburn_cap);
    assume $Libra_Preburn_is_well_formed(preburn_cap);
    coin1 := $SelectField($struct, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed(coin1);
    coin2 := $SelectField($struct, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed(coin2);
}

const unique $LBR_ReserveComponent: $TypeName;
const $LBR_ReserveComponent_ratio: $FieldName;
axiom $LBR_ReserveComponent_ratio == 0;
const $LBR_ReserveComponent_backing: $FieldName;
axiom $LBR_ReserveComponent_backing == 1;
function $LBR_ReserveComponent_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($LBR_ReserveComponent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $FixedPoint32_FixedPoint32_type_value()][1 := $Libra_Libra_type_value($tv0)], 2))
}
function {:inline} $LBR_ReserveComponent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $FixedPoint32_FixedPoint32_is_well_formed_types($SelectField($this, $LBR_ReserveComponent_ratio))
      && $Libra_Libra_is_well_formed_types($SelectField($this, $LBR_ReserveComponent_backing))
}
function {:inline} $LBR_ReserveComponent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $FixedPoint32_FixedPoint32_is_well_formed($SelectField($this, $LBR_ReserveComponent_ratio))
      && $Libra_Libra_is_well_formed($SelectField($this, $LBR_ReserveComponent_backing))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LBR_ReserveComponent_is_well_formed($ResourceValue(m, $LBR_ReserveComponent_type_value($tv0), a))
);

procedure {:inline 1} $LBR_ReserveComponent_before_update_inv($tv0: $TypeValue, $before: $Value) {
    call $Libra_Libra_before_update_inv($tv0, $SelectField($before, $LBR_ReserveComponent_backing));
}

procedure {:inline 1} $LBR_ReserveComponent_after_update_inv($tv0: $TypeValue, $after: $Value) {
    call $Libra_Libra_after_update_inv($tv0, $SelectField($after, $LBR_ReserveComponent_backing));
}

procedure {:inline 1} $LBR_ReserveComponent_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, ratio: $Value, backing: $Value) returns ($struct: $Value)
{
    assume $FixedPoint32_FixedPoint32_is_well_formed(ratio);
    assume $Libra_Libra_is_well_formed(backing);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := ratio][1 := backing], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LBR_ReserveComponent_unpack($tv0: $TypeValue, $struct: $Value) returns (ratio: $Value, backing: $Value)
{
    assume is#$Vector($struct);
    ratio := $SelectField($struct, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed(ratio);
    backing := $SelectField($struct, $LBR_ReserveComponent_backing);
    assume $Libra_Libra_is_well_formed(backing);
}



// ** functions of module LBR

procedure {:inline 1} $LBR_initialize_def(association: $Value, tc_account: $Value) returns (){
    // declare local variables
    var burn_cap: $Value; // $Libra_BurnCapability_type_value($LBR_LBR_type_value())
    var coin1: $Value; // $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())
    var coin2: $Value; // $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())
    var mint_cap: $Value; // $Libra_MintCapability_type_value($LBR_LBR_type_value())
    var preburn_cap: $Value; // $Libra_Preburn_type_value($LBR_LBR_type_value())
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $Vector_type_value($IntegerType())
    var $t26: $Value; // $Libra_MintCapability_type_value($LBR_LBR_type_value())
    var $t27: $Value; // $Libra_BurnCapability_type_value($LBR_LBR_type_value())
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $Libra_Preburn_type_value($LBR_LBR_type_value())
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t33: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t34: $Value; // $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t38: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t39: $Value; // $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())
    var $t40: $Value; // $AddressType()
    var $t41: $Value; // $Libra_MintCapability_type_value($LBR_LBR_type_value())
    var $t42: $Value; // $Libra_BurnCapability_type_value($LBR_LBR_type_value())
    var $t43: $Value; // $Libra_Preburn_type_value($LBR_LBR_type_value())
    var $t44: $Value; // $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())
    var $t45: $Value; // $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())
    var $t46: $Value; // $LBR_Reserve_type_value()
    var $t47: $Value; // $AddressType()
    var $t48: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(12, 3740, 0, association); }
    if (true) { assume $DebugTrackLocal(12, 3740, 1, tc_account); }

    // bytecode translation starts here
    // $t47 := move(association)
    call $tmp := $CopyOrMoveValue(association);
    $t47 := $tmp;

    // $t48 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t48 := $tmp;

    // $t9 := copy($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t9 := $tmp;

    // $t10 := Signer::address_of($t9)
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 3887);
      goto Abort;
    }
    assume is#$Address($t10);


    // $t11 := LBR::reserve_address()
    call $t11 := $LBR_reserve_address();
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 10437);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := ==($t10, $t11)
    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;

    // $t7 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 3872, 7, $tmp); }

    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t14 := move($t48)
    call $tmp := $CopyOrMoveValue($t48);
    $t14 := $tmp;

    // destroy($t14)

    // $t15 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 0
    $tmp := $Integer(0);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(12, 3872); }
    goto Abort;

    // L0:
L0:

    // $t17 := copy($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t17 := $tmp;

    // $t18 := copy($t48)
    call $tmp := $CopyOrMoveValue($t48);
    $t18 := $tmp;

    // $t19 := 1
    $tmp := $Integer(1);
    $t19 := $tmp;

    // $t20 := 1
    $tmp := $Integer(1);
    $t20 := $tmp;

    // $t21 := FixedPoint32::create_from_rational($t19, $t20)
    call $t21 := $FixedPoint32_create_from_rational($t19, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4143);
      goto Abort;
    }
    assume $FixedPoint32_FixedPoint32_is_well_formed($t21);


    // $t22 := true
    $tmp := $Boolean(true);
    $t22 := $tmp;

    // $t23 := 1000000
    $tmp := $Integer(1000000);
    $t23 := $tmp;

    // $t24 := 1000
    $tmp := $Integer(1000);
    $t24 := $tmp;

    // $t25 := [76, 66, 82]
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(76)][1 := $Integer(66)][2 := $Integer(82)], 3));
    $t25 := $tmp;

    // ($t26, $t27) := Libra::register_currency<LBR::LBR>($t17, $t18, $t21, $t22, $t23, $t24, $t25)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t26, $t27 := $Libra_register_currency($LBR_LBR_type_value(), $t17, $t18, $t21, $t22, $t23, $t24, $t25);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4044);
      goto Abort;
    }
    assume $Libra_MintCapability_is_well_formed($t26);

    assume $Libra_BurnCapability_is_well_formed($t27);


    // burn_cap := $t27
    call $tmp := $CopyOrMoveValue($t27);
    burn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4025, 2, $tmp); }

    // mint_cap := $t26
    call $tmp := $CopyOrMoveValue($t26);
    mint_cap := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4015, 5, $tmp); }

    // $t28 := move($t48)
    call $tmp := $CopyOrMoveValue($t48);
    $t28 := $tmp;

    // $t29 := Libra::create_preburn<LBR::LBR>($t28)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t29 := $Libra_create_preburn($LBR_LBR_type_value(), $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4388);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t29);


    // preburn_cap := $t29
    call $tmp := $CopyOrMoveValue($t29);
    preburn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4367, 6, $tmp); }

    // $t30 := 1
    $tmp := $Integer(1);
    $t30 := $tmp;

    // $t31 := 2
    $tmp := $Integer(2);
    $t31 := $tmp;

    // $t32 := FixedPoint32::create_from_rational($t30, $t31)
    call $t32 := $FixedPoint32_create_from_rational($t30, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4500);
      goto Abort;
    }
    assume $FixedPoint32_FixedPoint32_is_well_formed($t32);


    // $t33 := Libra::zero<Coin1::Coin1>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t33 := $Libra_zero($Coin1_Coin1_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4556);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t33);


    // $t34 := pack LBR::ReserveComponent<Coin1::Coin1>($t32, $t33)
    call $tmp := $LBR_ReserveComponent_pack(0, 0, 0, $Coin1_Coin1_type_value(), $t32, $t33);
    $t34 := $tmp;

    // coin1 := $t34
    call $tmp := $CopyOrMoveValue($t34);
    coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4433, 3, $tmp); }

    // $t35 := 1
    $tmp := $Integer(1);
    $t35 := $tmp;

    // $t36 := 2
    $tmp := $Integer(2);
    $t36 := $tmp;

    // $t37 := FixedPoint32::create_from_rational($t35, $t36)
    call $t37 := $FixedPoint32_create_from_rational($t35, $t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4661);
      goto Abort;
    }
    assume $FixedPoint32_FixedPoint32_is_well_formed($t37);


    // $t38 := Libra::zero<Coin2::Coin2>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t38 := $Libra_zero($Coin2_Coin2_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4717);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t38);


    // $t39 := pack LBR::ReserveComponent<Coin2::Coin2>($t37, $t38)
    call $tmp := $LBR_ReserveComponent_pack(0, 0, 0, $Coin2_Coin2_type_value(), $t37, $t38);
    $t39 := $tmp;

    // coin2 := $t39
    call $tmp := $CopyOrMoveValue($t39);
    coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4594, 4, $tmp); }

    // $t40 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t40 := $tmp;

    // $t46 := pack LBR::Reserve(mint_cap, burn_cap, preburn_cap, coin1, coin2)
    call $tmp := $LBR_Reserve_pack(0, 0, 0, mint_cap, burn_cap, preburn_cap, coin1, coin2);
    $t46 := $tmp;

    // move_to<LBR::Reserve>($t46, $t40)
    call $MoveTo($LBR_Reserve_type_value(), $t46, $t40);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4751);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LBR_initialize(association: $Value, tc_account: $Value) returns ()
free requires is#$Address(association);
free requires is#$Address(tc_account);
{
    call $LBR_initialize_def(association, tc_account);
}

procedure {:inline 1} $LBR_create_def(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value, $ret1: $Value, $ret2: $Value){
    // declare local variables
    var coin1_exact: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var coin2_exact: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var num_coin1: $Value; // $IntegerType()
    var num_coin2: $Value; // $IntegerType()
    var reserve: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t12: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t13: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t14: $Value; // $AddressType()
    var $t15: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t19: $Value; // $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())
    var $t20: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t21: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t27: $Value; // $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())
    var $t28: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t29: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Reference; // ReferenceType($Libra_Libra_type_value($Coin1_Coin1_type_value()))
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t35: $Reference; // ReferenceType($Libra_Libra_type_value($Coin2_Coin2_type_value()))
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t38: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t39: $Reference; // ReferenceType($LBR_ReserveComponent_type_value($Coin1_Coin1_type_value()))
    var $t40: $Reference; // ReferenceType($Libra_Libra_type_value($Coin1_Coin1_type_value()))
    var $t41: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t42: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t43: $Reference; // ReferenceType($LBR_ReserveComponent_type_value($Coin2_Coin2_type_value()))
    var $t44: $Reference; // ReferenceType($Libra_Libra_type_value($Coin2_Coin2_type_value()))
    var $t45: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t46: $Value; // $IntegerType()
    var $t47: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t48: $Value; // $Libra_MintCapability_type_value($LBR_LBR_type_value())
    var $t49: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t50: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t51: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t52: $Value; // $IntegerType()
    var $t53: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t54: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t55: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t56: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(12, 7580, 0, amount_lbr); }
    if (true) { assume $DebugTrackLocal(12, 7580, 1, coin1); }
    if (true) { assume $DebugTrackLocal(12, 7580, 2, coin2); }

    // bytecode translation starts here
    // $t52 := move(amount_lbr)
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t52 := $tmp;

    // $t53 := move(coin1)
    call $tmp := $CopyOrMoveValue(coin1);
    $t53 := $tmp;

    // $t54 := move(coin2)
    call $tmp := $CopyOrMoveValue(coin2);
    $t54 := $tmp;

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // $t10 := ==($t52, $t9)
    $tmp := $Boolean($IsEqual($t52, $t9));
    $t10 := $tmp;

    // if ($t10) goto L0 else goto L1
    $tmp := $t10;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t11 := Libra::zero<LBR::LBR>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t11 := $Libra_zero($LBR_LBR_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 7796);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t11);


    // return ($t11, $t53, $t54)
    $ret0 := $t11;
    if (true) { assume $DebugTrackLocal(12, 7781, 57, $ret0); }
    $ret1 := $t53;
    if (true) { assume $DebugTrackLocal(12, 7781, 58, $ret1); }
    $ret2 := $t54;
    if (true) { assume $DebugTrackLocal(12, 7781, 59, $ret2); }
    return;

    // L2:
L2:

    // $t14 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t14 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 7888);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := borrow_global<LBR::Reserve>($t14)
    call $t15 := $BorrowGlobal($t14, $LBR_Reserve_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 7846);
      goto Abort;
    }
    assume $LBR_Reserve_is_well_formed($Dereference($t15));

    // UnpackRef($t15)
    call $LBR_Reserve_before_update_inv($Dereference($t15));

    // reserve := $t15
    call reserve := $CopyOrMoveRef($t15);
    if (true) { assume $DebugTrackLocal(12, 7836, 7, $Dereference(reserve)); }

    // $t16 := 1
    $tmp := $Integer(1);
    $t16 := $tmp;

    // $t18 := copy(reserve)
    call $t18 := $CopyOrMoveRef(reserve);

    // $t19 := get_field<LBR::Reserve>.coin1($t18)
    call $tmp := $GetFieldFromReference($t18, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed($tmp);
    $t19 := $tmp;

    // Reference(reserve) <- $t18
    call reserve := $WritebackToReference($t18, reserve);

    // $t20 := get_field<LBR::ReserveComponent<Coin1::Coin1>>.ratio($t19)
    call $tmp := $GetFieldFromValue($t19, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t20 := $tmp;

    // $t21 := move($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t21 := $tmp;

    // $t22 := FixedPoint32::multiply_u64($t52, $t21)
    call $t22 := $FixedPoint32_multiply_u64($t52, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8280);
      goto Abort;
    }
    assume $IsValidU64($t22);


    // $t23 := +($t16, $t22)
    call $tmp := $AddU64($t16, $t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8264);
      goto Abort;
    }
    $t23 := $tmp;

    // num_coin1 := $t23
    call $tmp := $CopyOrMoveValue($t23);
    num_coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 8250, 5, $tmp); }

    // $t24 := 1
    $tmp := $Integer(1);
    $t24 := $tmp;

    // $t26 := copy(reserve)
    call $t26 := $CopyOrMoveRef(reserve);

    // $t27 := get_field<LBR::Reserve>.coin2($t26)
    call $tmp := $GetFieldFromReference($t26, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed($tmp);
    $t27 := $tmp;

    // Reference(reserve) <- $t26
    call reserve := $WritebackToReference($t26, reserve);

    // $t28 := get_field<LBR::ReserveComponent<Coin2::Coin2>>.ratio($t27)
    call $tmp := $GetFieldFromValue($t27, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t28 := $tmp;

    // $t29 := move($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t29 := $tmp;

    // $t30 := FixedPoint32::multiply_u64($t52, $t29)
    call $t30 := $FixedPoint32_multiply_u64($t52, $t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8371);
      goto Abort;
    }
    assume $IsValidU64($t30);


    // $t31 := +($t24, $t30)
    call $tmp := $AddU64($t24, $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8355);
      goto Abort;
    }
    $t31 := $tmp;

    // num_coin2 := $t31
    call $tmp := $CopyOrMoveValue($t31);
    num_coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 8341, 6, $tmp); }

    // $t32 := borrow_local($t53)
    call $t32 := $BorrowLoc(53, $t53);
    assume $Libra_Libra_is_well_formed($Dereference($t32));

    // UnpackRef($t32)
    call $Libra_Libra_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t32));

    // PackRef($t32)
    call $Libra_Libra_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t32));

    // $t56 := read_ref($t32)
    call $tmp := $ReadRef($t32);
    assume $Libra_Libra_is_well_formed($tmp);
    $t56 := $tmp;

    // ($t34, $t56) := Libra::withdraw<Coin1::Coin1>($t56, num_coin1)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t34, $t56 := $Libra_withdraw($Coin1_Coin1_type_value(), $t56, num_coin1);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8453);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t34);

    assume $Libra_Libra_is_well_formed($t56);


    // write_ref($t32, $t56)
    call $t32 := $WriteRef($t32, $t56);
    if (true) { assume $DebugTrackLocal(12, 8679, 7, $Dereference(reserve)); }

    // LocalRoot($t53) <- $t32
    call $t53 := $WritebackToValue($t32, 53, $t53);

    // UnpackRef($t32)
    call $Libra_Libra_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t32));

    // PackRef($t32)
    call $Libra_Libra_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t32));

    // coin1_exact := $t34
    call $tmp := $CopyOrMoveValue($t34);
    coin1_exact := $tmp;
    if (true) { assume $DebugTrackLocal(12, 8432, 3, $tmp); }

    // $t35 := borrow_local($t54)
    call $t35 := $BorrowLoc(54, $t54);
    assume $Libra_Libra_is_well_formed($Dereference($t35));

    // UnpackRef($t35)
    call $Libra_Libra_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t35));

    // PackRef($t35)
    call $Libra_Libra_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t35));

    // $t55 := read_ref($t35)
    call $tmp := $ReadRef($t35);
    assume $Libra_Libra_is_well_formed($tmp);
    $t55 := $tmp;

    // ($t37, $t55) := Libra::withdraw<Coin2::Coin2>($t55, num_coin2)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t37, $t55 := $Libra_withdraw($Coin2_Coin2_type_value(), $t55, num_coin2);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8519);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t37);

    assume $Libra_Libra_is_well_formed($t55);


    // write_ref($t35, $t55)
    call $t35 := $WriteRef($t35, $t55);
    if (true) { assume $DebugTrackLocal(12, 8866, 7, $Dereference(reserve)); }

    // LocalRoot($t54) <- $t35
    call $t54 := $WritebackToValue($t35, 54, $t54);

    // UnpackRef($t35)
    call $Libra_Libra_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t35));

    // PackRef($t35)
    call $Libra_Libra_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t35));

    // coin2_exact := $t37
    call $tmp := $CopyOrMoveValue($t37);
    coin2_exact := $tmp;
    if (true) { assume $DebugTrackLocal(12, 8498, 4, $tmp); }

    // $t38 := copy(reserve)
    call $t38 := $CopyOrMoveRef(reserve);

    // $t39 := borrow_field<LBR::Reserve>.coin1($t38)
    call $t39 := $BorrowField($t38, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed_types($Dereference($t39));

    // Reference(reserve) <- $t38
    call reserve := $WritebackToReference($t38, reserve);

    // UnpackRef($t39)
    call $LBR_ReserveComponent_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t39));

    // $t40 := borrow_field<LBR::ReserveComponent<Coin1::Coin1>>.backing($t39)
    call $t40 := $BorrowField($t39, $LBR_ReserveComponent_backing);
    assume $Libra_Libra_is_well_formed_types($Dereference($t40));

    // Reference(reserve) <- $t39
    call reserve := $WritebackToReference($t39, reserve);

    // Reference($t38) <- $t39
    call $t38 := $WritebackToReference($t39, $t38);

    // UnpackRef($t40)
    call $Libra_Libra_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t40));

    // PackRef($t40)
    call $Libra_Libra_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t40));

    // $t56 := read_ref($t40)
    call $tmp := $ReadRef($t40);
    assume $Libra_Libra_is_well_formed($tmp);
    $t56 := $tmp;

    // $t56 := Libra::deposit<Coin1::Coin1>($t56, coin1_exact)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t56 := $Libra_deposit($Coin1_Coin1_type_value(), $t56, coin1_exact);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8614);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t56);


    // write_ref($t40, $t56)
    call $t40 := $WriteRef($t40, $t56);
    if (true) { assume $DebugTrackLocal(12, 8827, 7, $Dereference(reserve)); }

    // Reference(reserve) <- $t40
    call reserve := $WritebackToReference($t40, reserve);

    // Reference($t39) <- $t40
    call $t39 := $WritebackToReference($t40, $t39);

    // Reference($t38) <- $t39
    call $t38 := $WritebackToReference($t39, $t38);

    // UnpackRef($t40)
    call $Libra_Libra_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t40));

    // PackRef($t39)
    call $LBR_ReserveComponent_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t39));

    // PackRef($t40)
    call $Libra_Libra_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t40));

    // $t42 := copy(reserve)
    call $t42 := $CopyOrMoveRef(reserve);

    // $t43 := borrow_field<LBR::Reserve>.coin2($t42)
    call $t43 := $BorrowField($t42, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed_types($Dereference($t43));

    // Reference(reserve) <- $t42
    call reserve := $WritebackToReference($t42, reserve);

    // UnpackRef($t43)
    call $LBR_ReserveComponent_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t43));

    // $t44 := borrow_field<LBR::ReserveComponent<Coin2::Coin2>>.backing($t43)
    call $t44 := $BorrowField($t43, $LBR_ReserveComponent_backing);
    assume $Libra_Libra_is_well_formed_types($Dereference($t44));

    // Reference(reserve) <- $t43
    call reserve := $WritebackToReference($t43, reserve);

    // Reference($t42) <- $t43
    call $t42 := $WritebackToReference($t43, $t42);

    // UnpackRef($t44)
    call $Libra_Libra_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t44));

    // PackRef($t44)
    call $Libra_Libra_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t44));

    // $t55 := read_ref($t44)
    call $tmp := $ReadRef($t44);
    assume $Libra_Libra_is_well_formed($tmp);
    $t55 := $tmp;

    // $t55 := Libra::deposit<Coin2::Coin2>($t55, coin2_exact)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t55 := $Libra_deposit($Coin2_Coin2_type_value(), $t55, coin2_exact);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8679);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t55);


    // write_ref($t44, $t55)
    call $t44 := $WriteRef($t44, $t55);
    if (true) { assume $DebugTrackLocal(12, 8892, 7, $Dereference(reserve)); }

    // Reference(reserve) <- $t44
    call reserve := $WritebackToReference($t44, reserve);

    // Reference($t43) <- $t44
    call $t43 := $WritebackToReference($t44, $t43);

    // Reference($t42) <- $t43
    call $t42 := $WritebackToReference($t43, $t42);

    // UnpackRef($t44)
    call $Libra_Libra_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t44));

    // PackRef($t43)
    call $LBR_ReserveComponent_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t43));

    // PackRef($t44)
    call $Libra_Libra_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t44));

    // $t47 := move(reserve)
    call $t47 := $CopyOrMoveRef(reserve);

    // $t48 := get_field<LBR::Reserve>.mint_cap($t47)
    call $tmp := $GetFieldFromReference($t47, $LBR_Reserve_mint_cap);
    assume $Libra_MintCapability_is_well_formed($tmp);
    $t48 := $tmp;

    // LBR::Reserve <- $t47
    call $WritebackToGlobal($t47);

    // PackRef($t47)
    call $LBR_Reserve_after_update_inv($Dereference($t47));

    // $t49 := Libra::mint_with_capability<LBR::LBR>($t52, $t48)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t49 := $Libra_mint_with_capability($LBR_LBR_type_value(), $t52, $t48);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 8827);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t49);


    // return ($t49, $t53, $t54)
    $ret0 := $t49;
    if (true) { assume $DebugTrackLocal(12, 8819, 57, $ret0); }
    $ret1 := $t53;
    if (true) { assume $DebugTrackLocal(12, 8819, 58, $ret1); }
    $ret2 := $t54;
    if (true) { assume $DebugTrackLocal(12, 8819, 59, $ret2); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
    $ret2 := $DefaultValue();
}
procedure {:inline 1} $LBR_create(amount_lbr: $Value, coin1: $Value, coin2: $Value) returns ($ret0: $Value, $ret1: $Value, $ret2: $Value)
free requires $IsValidU64(amount_lbr);
free requires $Libra_Libra_is_well_formed(coin1);
free requires $Libra_Libra_is_well_formed(coin2);
{
    call $ret0, $ret1, $ret2 := $LBR_create_def(amount_lbr, coin1, coin2);
}

procedure {:inline 1} $LBR_is_lbr_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $BooleanType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := Libra::is_currency<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t1 := $Libra_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4945);
      goto Abort;
    }
    assume is#$Boolean($t1);


    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t2 := Libra::currency_code<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t2 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 4991);
      goto Abort;
    }
    assume $Vector_is_well_formed($t2) && (forall $$0: int :: {$select_vector($t2,$$0)} $$0 >= 0 && $$0 < $vlen($t2) ==> $IsValidU8($select_vector($t2,$$0)));


    // $t3 := Libra::currency_code<LBR::LBR>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t3 := $Libra_currency_code($LBR_LBR_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 5027);
      goto Abort;
    }
    assume $Vector_is_well_formed($t3) && (forall $$0: int :: {$select_vector($t3,$$0)} $$0 >= 0 && $$0 < $vlen($t3) ==> $IsValidU8($select_vector($t3,$$0)));


    // $t4 := ==($t2, $t3)
    $tmp := $Boolean($IsEqual($t2, $t3));
    $t4 := $tmp;

    // $t0 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4938, 0, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t5 := false
    $tmp := $Boolean(false);
    $t5 := $tmp;

    // $t0 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 4938, 0, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(12, 4938, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LBR_is_lbr($tv0: $TypeValue) returns ($ret0: $Value)
{
    call $ret0 := $LBR_is_lbr_def($tv0);
}

procedure {:inline 1} $LBR_reserve_address_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := CoreAddresses::CURRENCY_INFO_ADDRESS()
    call $t0 := $CoreAddresses_CURRENCY_INFO_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 10489);
      goto Abort;
    }
    assume is#$Address($t0);


    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(12, 10474, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LBR_reserve_address() returns ($ret0: $Value)
{
    call $ret0 := $LBR_reserve_address_def();
}

procedure {:inline 1} $LBR_swap_into_def(coin1: $Value, coin2: $Value) returns ($ret0: $Value, $ret1: $Value, $ret2: $Value){
    // declare local variables
    var coin1_value: $Value; // $IntegerType()
    var coin2_value: $Value; // $IntegerType()
    var lbr_num_coin1: $Value; // $IntegerType()
    var lbr_num_coin2: $Value; // $IntegerType()
    var num_lbr: $Value; // $IntegerType()
    var reserve: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t12: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t25: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t26: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t27: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t32: $Value; // $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())
    var $t33: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t34: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t40: $Value; // $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())
    var $t41: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t42: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $BooleanType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Value; // $IntegerType()
    var $t50: $Value; // $IntegerType()
    var $t51: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t52: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t53: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t54: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t55: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t56: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t57: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(12, 6022, 0, coin1); }
    if (true) { assume $DebugTrackLocal(12, 6022, 1, coin2); }

    // bytecode translation starts here
    // $t56 := move(coin1)
    call $tmp := $CopyOrMoveValue(coin1);
    $t56 := $tmp;

    // $t57 := move(coin2)
    call $tmp := $CopyOrMoveValue(coin2);
    $t57 := $tmp;

    // $t10 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t10 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6264);
      goto Abort;
    }
    assume is#$Address($t10);


    // $t11 := borrow_global<LBR::Reserve>($t10)
    call $t11 := $BorrowGlobal($t10, $LBR_Reserve_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6222);
      goto Abort;
    }
    assume $LBR_Reserve_is_well_formed($Dereference($t11));

    // UnpackRef($t11)
    call $LBR_Reserve_before_update_inv($Dereference($t11));

    // reserve := $t11
    call reserve := $CopyOrMoveRef($t11);
    if (true) { assume $DebugTrackLocal(12, 6212, 7, $Dereference(reserve)); }

    // $t12 := copy($t56)
    call $tmp := $CopyOrMoveValue($t56);
    $t12 := $tmp;

    // $t13 := Libra::value<Coin1::Coin1>($t12)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t13 := $Libra_value($Coin1_Coin1_type_value(), $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6320);
      goto Abort;
    }
    assume $IsValidU64($t13);


    // coin1_value := $t13
    call $tmp := $CopyOrMoveValue($t13);
    coin1_value := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6299, 2, $tmp); }

    // $t14 := copy($t57)
    call $tmp := $CopyOrMoveValue($t57);
    $t14 := $tmp;

    // $t15 := Libra::value<Coin2::Coin2>($t14)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t15 := $Libra_value($Coin2_Coin2_type_value(), $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6368);
      goto Abort;
    }
    assume $IsValidU64($t15);


    // coin2_value := $t15
    call $tmp := $CopyOrMoveValue($t15);
    coin2_value := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6347, 3, $tmp); }

    // $t17 := 1
    $tmp := $Integer(1);
    $t17 := $tmp;

    // $t18 := <=(coin1_value, $t17)
    call $tmp := $Le(coin1_value, $t17);
    $t18 := $tmp;

    // if ($t18) goto L0 else goto L1
    $tmp := $t18;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t19 := true
    $tmp := $Boolean(true);
    $t19 := $tmp;

    // $t8 := $t19
    call $tmp := $CopyOrMoveValue($t19);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6475, 8, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t21 := 1
    $tmp := $Integer(1);
    $t21 := $tmp;

    // $t22 := <=(coin2_value, $t21)
    call $tmp := $Le(coin2_value, $t21);
    $t22 := $tmp;

    // $t8 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6475, 8, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if ($t8) goto L4 else goto L5
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t24 := move(reserve)
    call $t24 := $CopyOrMoveRef(reserve);

    // destroy($t24)

    // LBR::Reserve <- $t24
    call $WritebackToGlobal($t24);

    // PackRef($t24)
    call $LBR_Reserve_after_update_inv($Dereference($t24));

    // $t25 := Libra::zero<LBR::LBR>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t25 := $Libra_zero($LBR_LBR_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6528);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t25);


    // return ($t25, $t56, $t57)
    $ret0 := $t25;
    if (true) { assume $DebugTrackLocal(12, 6513, 58, $ret0); }
    $ret1 := $t56;
    if (true) { assume $DebugTrackLocal(12, 6513, 59, $ret1); }
    $ret2 := $t57;
    if (true) { assume $DebugTrackLocal(12, 6513, 60, $ret2); }
    return;

    // L6:
L6:

    // $t29 := 1
    $tmp := $Integer(1);
    $t29 := $tmp;

    // $t30 := -(coin1_value, $t29)
    call $tmp := $Sub(coin1_value, $t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6621);
      goto Abort;
    }
    $t30 := $tmp;

    // $t31 := copy(reserve)
    call $t31 := $CopyOrMoveRef(reserve);

    // $t32 := get_field<LBR::Reserve>.coin1($t31)
    call $tmp := $GetFieldFromReference($t31, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed($tmp);
    $t32 := $tmp;

    // Reference(reserve) <- $t31
    call reserve := $WritebackToReference($t31, reserve);

    // $t33 := get_field<LBR::ReserveComponent<Coin1::Coin1>>.ratio($t32)
    call $tmp := $GetFieldFromValue($t32, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t33 := $tmp;

    // $t34 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t34 := $tmp;

    // $t35 := FixedPoint32::divide_u64($t30, $t34)
    call $t35 := $FixedPoint32_divide_u64($t30, $t34);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6598);
      goto Abort;
    }
    assume $IsValidU64($t35);


    // lbr_num_coin1 := $t35
    call $tmp := $CopyOrMoveValue($t35);
    lbr_num_coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6568, 4, $tmp); }

    // $t37 := 1
    $tmp := $Integer(1);
    $t37 := $tmp;

    // $t38 := -(coin2_value, $t37)
    call $tmp := $Sub(coin2_value, $t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6715);
      goto Abort;
    }
    $t38 := $tmp;

    // $t39 := move(reserve)
    call $t39 := $CopyOrMoveRef(reserve);

    // $t40 := get_field<LBR::Reserve>.coin2($t39)
    call $tmp := $GetFieldFromReference($t39, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed($tmp);
    $t40 := $tmp;

    // LBR::Reserve <- $t39
    call $WritebackToGlobal($t39);

    // PackRef($t39)
    call $LBR_Reserve_after_update_inv($Dereference($t39));

    // $t41 := get_field<LBR::ReserveComponent<Coin2::Coin2>>.ratio($t40)
    call $tmp := $GetFieldFromValue($t40, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t41 := $tmp;

    // $t42 := move($t41)
    call $tmp := $CopyOrMoveValue($t41);
    $t42 := $tmp;

    // $t43 := FixedPoint32::divide_u64($t38, $t42)
    call $t43 := $FixedPoint32_divide_u64($t38, $t42);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 6692);
      goto Abort;
    }
    assume $IsValidU64($t43);


    // lbr_num_coin2 := $t43
    call $tmp := $CopyOrMoveValue($t43);
    lbr_num_coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6662, 5, $tmp); }

    // $t46 := <(lbr_num_coin2, lbr_num_coin1)
    call $tmp := $Lt(lbr_num_coin2, lbr_num_coin1);
    $t46 := $tmp;

    // if ($t46) goto L7 else goto L8
    $tmp := $t46;
    if (b#$Boolean($tmp)) { goto L7; } else { goto L8; }

    // L8:
L8:

    // goto L9
    goto L9;

    // L7:
L7:

    // $t9 := lbr_num_coin2
    call $tmp := $CopyOrMoveValue(lbr_num_coin2);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6980, 9, $tmp); }

    // goto L10
    goto L10;

    // L9:
L9:

    // $t9 := lbr_num_coin1
    call $tmp := $CopyOrMoveValue(lbr_num_coin1);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6980, 9, $tmp); }

    // goto L10
    goto L10;

    // L10:
L10:

    // num_lbr := $t9
    call $tmp := $CopyOrMoveValue($t9);
    num_lbr := $tmp;
    if (true) { assume $DebugTrackLocal(12, 6970, 6, $tmp); }

    // ($t53, $t54, $t55) := LBR::create(num_lbr, $t56, $t57)
    call $t53, $t54, $t55 := $LBR_create(num_lbr, $t56, $t57);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 7591);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t53);

    assume $Libra_Libra_is_well_formed($t54);

    assume $Libra_Libra_is_well_formed($t55);


    // return ($t53, $t54, $t55)
    $ret0 := $t53;
    if (true) { assume $DebugTrackLocal(12, 7105, 58, $ret0); }
    $ret1 := $t54;
    if (true) { assume $DebugTrackLocal(12, 7105, 59, $ret1); }
    $ret2 := $t55;
    if (true) { assume $DebugTrackLocal(12, 7105, 60, $ret2); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
    $ret2 := $DefaultValue();
}
procedure {:inline 1} $LBR_swap_into(coin1: $Value, coin2: $Value) returns ($ret0: $Value, $ret1: $Value, $ret2: $Value)
free requires $Libra_Libra_is_well_formed(coin1);
free requires $Libra_Libra_is_well_formed(coin2);
{
    call $ret0, $ret1, $ret2 := $LBR_swap_into_def(coin1, coin2);
}

procedure {:inline 1} $LBR_unpack_def(coin: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var coin1: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var coin1_amount: $Value; // $IntegerType()
    var coin2: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var coin2_amount: $Value; // $IntegerType()
    var ratio_multiplier: $Value; // $IntegerType()
    var reserve: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var sender: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t10: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t14: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t15: $Reference; // ReferenceType($Libra_Preburn_type_value($LBR_LBR_type_value()))
    var $t16: $Value; // $AddressType()
    var $t17: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t18: $Reference; // ReferenceType($Libra_Preburn_type_value($LBR_LBR_type_value()))
    var $t19: $Value; // $AddressType()
    var $t20: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t21: $Value; // $Libra_BurnCapability_type_value($LBR_LBR_type_value())
    var $t22: $Value; // $IntegerType()
    var $t23: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t24: $Value; // $LBR_ReserveComponent_type_value($Coin1_Coin1_type_value())
    var $t25: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t26: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t30: $Value; // $LBR_ReserveComponent_type_value($Coin2_Coin2_type_value())
    var $t31: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t32: $Value; // $FixedPoint32_FixedPoint32_type_value()
    var $t33: $Value; // $IntegerType()
    var $t34: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t35: $Reference; // ReferenceType($LBR_ReserveComponent_type_value($Coin1_Coin1_type_value()))
    var $t36: $Reference; // ReferenceType($Libra_Libra_type_value($Coin1_Coin1_type_value()))
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t39: $Reference; // ReferenceType($LBR_Reserve_type_value())
    var $t40: $Reference; // ReferenceType($LBR_ReserveComponent_type_value($Coin2_Coin2_type_value()))
    var $t41: $Reference; // ReferenceType($Libra_Libra_type_value($Coin2_Coin2_type_value()))
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t44: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t45: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t46: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t47: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t48: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t49: $Value; // $Libra_Preburn_type_value($LBR_LBR_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(12, 9511, 0, coin); }

    // bytecode translation starts here
    // $t46 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t46 := $tmp;

    // $t8 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t8 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 9664);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t9 := borrow_global<LBR::Reserve>($t8)
    call $t9 := $BorrowGlobal($t8, $LBR_Reserve_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 9622);
      goto Abort;
    }
    assume $LBR_Reserve_is_well_formed($Dereference($t9));

    // UnpackRef($t9)
    call $LBR_Reserve_before_update_inv($Dereference($t9));

    // reserve := $t9
    call reserve := $CopyOrMoveRef($t9);
    if (true) { assume $DebugTrackLocal(12, 9612, 6, $Dereference(reserve)); }

    // $t10 := copy($t46)
    call $tmp := $CopyOrMoveValue($t46);
    $t10 := $tmp;

    // $t11 := Libra::value<LBR::LBR>($t10)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t11 := $Libra_value($LBR_LBR_type_value(), $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 9725);
      goto Abort;
    }
    assume $IsValidU64($t11);


    // ratio_multiplier := $t11
    call $tmp := $CopyOrMoveValue($t11);
    ratio_multiplier := $tmp;
    if (true) { assume $DebugTrackLocal(12, 9699, 5, $tmp); }

    // $t12 := LBR::reserve_address()
    call $t12 := $LBR_reserve_address();
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 10437);
      goto Abort;
    }
    assume is#$Address($t12);


    // sender := $t12
    call $tmp := $CopyOrMoveValue($t12);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(12, 9751, 7, $tmp); }

    // $t14 := copy(reserve)
    call $t14 := $CopyOrMoveRef(reserve);

    // $t15 := borrow_field<LBR::Reserve>.preburn_cap($t14)
    call $t15 := $BorrowField($t14, $LBR_Reserve_preburn_cap);
    assume $Libra_Preburn_is_well_formed_types($Dereference($t15));

    // Reference(reserve) <- $t14
    call reserve := $WritebackToReference($t14, reserve);

    // UnpackRef($t15)

    // PackRef($t15)

    // $t49 := read_ref($t15)
    call $tmp := $ReadRef($t15);
    assume $Libra_Preburn_is_well_formed($tmp);
    $t49 := $tmp;

    // $t49 := Libra::preburn_with_resource<LBR::LBR>($t46, $t49, sender)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t49 := $Libra_preburn_with_resource($LBR_LBR_type_value(), $t46, $t49, sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 9794);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t49);


    // write_ref($t15, $t49)
    call $t15 := $WriteRef($t15, $t49);
    if (true) { assume $DebugTrackLocal(12, 10256, 6, $Dereference(reserve)); }

    // Reference(reserve) <- $t15
    call reserve := $WritebackToReference($t15, reserve);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // UnpackRef($t15)

    // PackRef($t15)

    // $t17 := copy(reserve)
    call $t17 := $CopyOrMoveRef(reserve);

    // $t18 := borrow_field<LBR::Reserve>.preburn_cap($t17)
    call $t18 := $BorrowField($t17, $LBR_Reserve_preburn_cap);
    assume $Libra_Preburn_is_well_formed_types($Dereference($t18));

    // Reference(reserve) <- $t17
    call reserve := $WritebackToReference($t17, reserve);

    // UnpackRef($t18)

    // $t20 := copy(reserve)
    call $t20 := $CopyOrMoveRef(reserve);

    // $t21 := get_field<LBR::Reserve>.burn_cap($t20)
    call $tmp := $GetFieldFromReference($t20, $LBR_Reserve_burn_cap);
    assume $Libra_BurnCapability_is_well_formed($tmp);
    $t21 := $tmp;

    // Reference(reserve) <- $t20
    call reserve := $WritebackToReference($t20, reserve);

    // PackRef($t18)

    // $t49 := read_ref($t18)
    call $tmp := $ReadRef($t18);
    assume $Libra_Preburn_is_well_formed($tmp);
    $t49 := $tmp;

    // $t49 := Libra::burn_with_resource_cap<LBR::LBR>($t49, sender, $t21)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t49 := $Libra_burn_with_resource_cap($LBR_LBR_type_value(), $t49, sender, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 9872);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t49);


    // write_ref($t18, $t49)
    call $t18 := $WriteRef($t18, $t49);
    if (true) { assume $DebugTrackLocal(12, 10247, 6, $Dereference(reserve)); }

    // Reference(reserve) <- $t18
    call reserve := $WritebackToReference($t18, reserve);

    // Reference($t17) <- $t18
    call $t17 := $WritebackToReference($t18, $t17);

    // Reference($t20) <- $t18
    call $t20 := $WritebackToReference($t18, $t20);

    // UnpackRef($t18)

    // PackRef($t18)

    // $t23 := copy(reserve)
    call $t23 := $CopyOrMoveRef(reserve);

    // $t24 := get_field<LBR::Reserve>.coin1($t23)
    call $tmp := $GetFieldFromReference($t23, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed($tmp);
    $t24 := $tmp;

    // Reference(reserve) <- $t23
    call reserve := $WritebackToReference($t23, reserve);

    // $t25 := get_field<LBR::ReserveComponent<Coin1::Coin1>>.ratio($t24)
    call $tmp := $GetFieldFromValue($t24, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t25 := $tmp;

    // $t26 := move($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t26 := $tmp;

    // $t27 := FixedPoint32::multiply_u64(ratio_multiplier, $t26)
    call $t27 := $FixedPoint32_multiply_u64(ratio_multiplier, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 9990);
      goto Abort;
    }
    assume $IsValidU64($t27);


    // coin1_amount := $t27
    call $tmp := $CopyOrMoveValue($t27);
    coin1_amount := $tmp;
    if (true) { assume $DebugTrackLocal(12, 9961, 2, $tmp); }

    // $t29 := copy(reserve)
    call $t29 := $CopyOrMoveRef(reserve);

    // $t30 := get_field<LBR::Reserve>.coin2($t29)
    call $tmp := $GetFieldFromReference($t29, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed($tmp);
    $t30 := $tmp;

    // Reference(reserve) <- $t29
    call reserve := $WritebackToReference($t29, reserve);

    // $t31 := get_field<LBR::ReserveComponent<Coin2::Coin2>>.ratio($t30)
    call $tmp := $GetFieldFromValue($t30, $LBR_ReserveComponent_ratio);
    assume $FixedPoint32_FixedPoint32_is_well_formed($tmp);
    $t31 := $tmp;

    // $t32 := move($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t32 := $tmp;

    // $t33 := FixedPoint32::multiply_u64(ratio_multiplier, $t32)
    call $t33 := $FixedPoint32_multiply_u64(ratio_multiplier, $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 10086);
      goto Abort;
    }
    assume $IsValidU64($t33);


    // coin2_amount := $t33
    call $tmp := $CopyOrMoveValue($t33);
    coin2_amount := $tmp;
    if (true) { assume $DebugTrackLocal(12, 10057, 4, $tmp); }

    // $t34 := copy(reserve)
    call $t34 := $CopyOrMoveRef(reserve);

    // $t35 := borrow_field<LBR::Reserve>.coin1($t34)
    call $t35 := $BorrowField($t34, $LBR_Reserve_coin1);
    assume $LBR_ReserveComponent_is_well_formed_types($Dereference($t35));

    // Reference(reserve) <- $t34
    call reserve := $WritebackToReference($t34, reserve);

    // UnpackRef($t35)
    call $LBR_ReserveComponent_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t35));

    // $t36 := borrow_field<LBR::ReserveComponent<Coin1::Coin1>>.backing($t35)
    call $t36 := $BorrowField($t35, $LBR_ReserveComponent_backing);
    assume $Libra_Libra_is_well_formed_types($Dereference($t36));

    // Reference(reserve) <- $t35
    call reserve := $WritebackToReference($t35, reserve);

    // Reference($t34) <- $t35
    call $t34 := $WritebackToReference($t35, $t34);

    // UnpackRef($t36)
    call $Libra_Libra_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t36));

    // PackRef($t36)
    call $Libra_Libra_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t36));

    // $t48 := read_ref($t36)
    call $tmp := $ReadRef($t36);
    assume $Libra_Libra_is_well_formed($tmp);
    $t48 := $tmp;

    // ($t38, $t48) := Libra::withdraw<Coin1::Coin1>($t48, coin1_amount)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t38, $t48 := $Libra_withdraw($Coin1_Coin1_type_value(), $t48, coin1_amount);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 10168);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t38);

    assume $Libra_Libra_is_well_formed($t48);


    // write_ref($t36, $t48)
    call $t36 := $WriteRef($t36, $t48);
    if (true) { assume $DebugTrackLocal(12, 10308, 6, $Dereference(reserve)); }

    // Reference(reserve) <- $t36
    call reserve := $WritebackToReference($t36, reserve);

    // Reference($t35) <- $t36
    call $t35 := $WritebackToReference($t36, $t35);

    // Reference($t34) <- $t35
    call $t34 := $WritebackToReference($t35, $t34);

    // UnpackRef($t36)
    call $Libra_Libra_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t36));

    // PackRef($t35)
    call $LBR_ReserveComponent_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t35));

    // PackRef($t36)
    call $Libra_Libra_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t36));

    // coin1 := $t38
    call $tmp := $CopyOrMoveValue($t38);
    coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 10153, 1, $tmp); }

    // $t39 := move(reserve)
    call $t39 := $CopyOrMoveRef(reserve);

    // $t40 := borrow_field<LBR::Reserve>.coin2($t39)
    call $t40 := $BorrowField($t39, $LBR_Reserve_coin2);
    assume $LBR_ReserveComponent_is_well_formed_types($Dereference($t40));

    // LBR::Reserve <- $t39
    call $WritebackToGlobal($t39);

    // UnpackRef($t40)
    call $LBR_ReserveComponent_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t40));

    // $t41 := borrow_field<LBR::ReserveComponent<Coin2::Coin2>>.backing($t40)
    call $t41 := $BorrowField($t40, $LBR_ReserveComponent_backing);
    assume $Libra_Libra_is_well_formed_types($Dereference($t41));

    // LBR::Reserve <- $t40
    call $WritebackToGlobal($t40);

    // Reference($t39) <- $t40
    call $t39 := $WritebackToReference($t40, $t39);

    // UnpackRef($t41)
    call $Libra_Libra_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t41));

    // PackRef($t41)
    call $Libra_Libra_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t41));

    // $t47 := read_ref($t41)
    call $tmp := $ReadRef($t41);
    assume $Libra_Libra_is_well_formed($tmp);
    $t47 := $tmp;

    // ($t43, $t47) := Libra::withdraw<Coin2::Coin2>($t47, coin2_amount)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t43, $t47 := $Libra_withdraw($Coin2_Coin2_type_value(), $t47, coin2_amount);
    if ($abort_flag) {
      assume $DebugTrackAbort(12, 10247);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t43);

    assume $Libra_Libra_is_well_formed($t47);


    // write_ref($t41, $t47)
    call $t41 := $WriteRef($t41, $t47);
    if (true) { assume $DebugTrackLocal(12, 10307, 6, $Dereference(reserve)); }

    // LBR::Reserve <- $t41
    call $WritebackToGlobal($t41);

    // Reference($t40) <- $t41
    call $t40 := $WritebackToReference($t41, $t40);

    // Reference($t39) <- $t40
    call $t39 := $WritebackToReference($t40, $t39);

    // UnpackRef($t41)
    call $Libra_Libra_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t41));

    // PackRef($t39)
    call $LBR_Reserve_after_update_inv($Dereference($t39));

    // PackRef($t40)
    call $LBR_ReserveComponent_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t40));

    // PackRef($t41)
    call $Libra_Libra_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t41));

    // coin2 := $t43
    call $tmp := $CopyOrMoveValue($t43);
    coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(12, 10232, 3, $tmp); }

    // return (coin1, coin2)
    $ret0 := coin1;
    if (true) { assume $DebugTrackLocal(12, 10307, 50, $ret0); }
    $ret1 := coin2;
    if (true) { assume $DebugTrackLocal(12, 10307, 51, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $LBR_unpack(coin: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $Libra_Libra_is_well_formed(coin);
{
    call $ret0, $ret1 := $LBR_unpack_def(coin);
}



// ** spec vars of module AccountLimits



// ** spec funs of module AccountLimits

function {:inline} $AccountLimits_spec_update_deposit_limits($tv0: $TypeValue, amount: $Value, addr: $Value): $Value;
axiom (forall $tv0: $TypeValue, amount: $Value, addr: $Value :: is#$Boolean($AccountLimits_spec_update_deposit_limits($tv0, amount, addr)));


// ** structs of module AccountLimits

const unique $AccountLimits_CallingCapability: $TypeName;
const $AccountLimits_CallingCapability_dummy_field: $FieldName;
axiom $AccountLimits_CallingCapability_dummy_field == 0;
function $AccountLimits_CallingCapability_type_value(): $TypeValue {
    $StructType($AccountLimits_CallingCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $AccountLimits_CallingCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $AccountLimits_CallingCapability_dummy_field))
}
function {:inline} $AccountLimits_CallingCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $AccountLimits_CallingCapability_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $AccountLimits_CallingCapability_is_well_formed($ResourceValue(m, $AccountLimits_CallingCapability_type_value(), a))
);

procedure {:inline 1} $AccountLimits_CallingCapability_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountLimits_CallingCapability_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $AccountLimits_CallingCapability_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $AccountLimits_LimitsDefinition: $TypeName;
const $AccountLimits_LimitsDefinition_max_inflow: $FieldName;
axiom $AccountLimits_LimitsDefinition_max_inflow == 0;
const $AccountLimits_LimitsDefinition_max_outflow: $FieldName;
axiom $AccountLimits_LimitsDefinition_max_outflow == 1;
const $AccountLimits_LimitsDefinition_time_period: $FieldName;
axiom $AccountLimits_LimitsDefinition_time_period == 2;
const $AccountLimits_LimitsDefinition_max_holding: $FieldName;
axiom $AccountLimits_LimitsDefinition_max_holding == 3;
function $AccountLimits_LimitsDefinition_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($AccountLimits_LimitsDefinition, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $IntegerType()][2 := $IntegerType()][3 := $IntegerType()], 4))
}
function {:inline} $AccountLimits_LimitsDefinition_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_time_period))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_holding))
}
function {:inline} $AccountLimits_LimitsDefinition_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_inflow))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_outflow))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_time_period))
      && $IsValidU64($SelectField($this, $AccountLimits_LimitsDefinition_max_holding))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $AccountLimits_LimitsDefinition_is_well_formed($ResourceValue(m, $AccountLimits_LimitsDefinition_type_value($tv0), a))
);

procedure {:inline 1} $AccountLimits_LimitsDefinition_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(max_inflow);
    assume $IsValidU64(max_outflow);
    assume $IsValidU64(time_period);
    assume $IsValidU64(max_holding);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := max_inflow][1 := max_outflow][2 := time_period][3 := max_holding], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountLimits_LimitsDefinition_unpack($tv0: $TypeValue, $struct: $Value) returns (max_inflow: $Value, max_outflow: $Value, time_period: $Value, max_holding: $Value)
{
    assume is#$Vector($struct);
    max_inflow := $SelectField($struct, $AccountLimits_LimitsDefinition_max_inflow);
    assume $IsValidU64(max_inflow);
    max_outflow := $SelectField($struct, $AccountLimits_LimitsDefinition_max_outflow);
    assume $IsValidU64(max_outflow);
    time_period := $SelectField($struct, $AccountLimits_LimitsDefinition_time_period);
    assume $IsValidU64(time_period);
    max_holding := $SelectField($struct, $AccountLimits_LimitsDefinition_max_holding);
    assume $IsValidU64(max_holding);
}

const unique $AccountLimits_Window: $TypeName;
const $AccountLimits_Window_window_start: $FieldName;
axiom $AccountLimits_Window_window_start == 0;
const $AccountLimits_Window_window_inflow: $FieldName;
axiom $AccountLimits_Window_window_inflow == 1;
const $AccountLimits_Window_window_outflow: $FieldName;
axiom $AccountLimits_Window_window_outflow == 2;
const $AccountLimits_Window_tracked_balance: $FieldName;
axiom $AccountLimits_Window_tracked_balance == 3;
const $AccountLimits_Window_limit_address: $FieldName;
axiom $AccountLimits_Window_limit_address == 4;
function $AccountLimits_Window_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($AccountLimits_Window, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $IntegerType()][2 := $IntegerType()][3 := $IntegerType()][4 := $AddressType()], 5))
}
function {:inline} $AccountLimits_Window_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 5
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_start))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_inflow))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_outflow))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_tracked_balance))
      && is#$Address($SelectField($this, $AccountLimits_Window_limit_address))
}
function {:inline} $AccountLimits_Window_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 5
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_start))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_inflow))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_window_outflow))
      && $IsValidU64($SelectField($this, $AccountLimits_Window_tracked_balance))
      && is#$Address($SelectField($this, $AccountLimits_Window_limit_address))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $AccountLimits_Window_is_well_formed($ResourceValue(m, $AccountLimits_Window_type_value($tv0), a))
);

procedure {:inline 1} $AccountLimits_Window_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(window_start);
    assume $IsValidU64(window_inflow);
    assume $IsValidU64(window_outflow);
    assume $IsValidU64(tracked_balance);
    assume is#$Address(limit_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := window_start][1 := window_inflow][2 := window_outflow][3 := tracked_balance][4 := limit_address], 5));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $AccountLimits_Window_unpack($tv0: $TypeValue, $struct: $Value) returns (window_start: $Value, window_inflow: $Value, window_outflow: $Value, tracked_balance: $Value, limit_address: $Value)
{
    assume is#$Vector($struct);
    window_start := $SelectField($struct, $AccountLimits_Window_window_start);
    assume $IsValidU64(window_start);
    window_inflow := $SelectField($struct, $AccountLimits_Window_window_inflow);
    assume $IsValidU64(window_inflow);
    window_outflow := $SelectField($struct, $AccountLimits_Window_window_outflow);
    assume $IsValidU64(window_outflow);
    tracked_balance := $SelectField($struct, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64(tracked_balance);
    limit_address := $SelectField($struct, $AccountLimits_Window_limit_address);
    assume is#$Address(limit_address);
}



// ** functions of module AccountLimits

procedure {:inline 1} $AccountLimits_initialize_def(lr_account: $Value, calling_cap: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $AccountLimits_CallingCapability_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 2636, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(2, 2636, 1, calling_cap); }

    // bytecode translation starts here
    // $t25 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t25 := $tmp;

    // $t26 := move(calling_cap)
    call $tmp := $CopyOrMoveValue(calling_cap);
    $t26 := $tmp;

    // $t6 := LibraTimestamp::is_genesis()
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2745);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t2 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 2722, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 0
    $tmp := $Integer(0);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(2, 2722); }
    goto Abort;

    // L0:
L0:

    // $t11 := copy($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t11 := $tmp;

    // $t12 := Signer::address_of($t11)
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2797);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t13 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2838);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := ==($t12, $t13)
    $tmp := $Boolean($IsEqual($t12, $t13));
    $t14 := $tmp;

    // $t4 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 2782, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t16 := move($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t17 := $tmp;

    // destroy($t17)

    // $t18 := 1
    $tmp := $Integer(1);
    $t18 := $tmp;

    // abort($t18)
    if (true) { assume $DebugTrackAbort(2, 2782); }
    goto Abort;

    // L2:
L2:

    // $t19 := copy($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t19 := $tmp;

    // $t20 := copy($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t20 := $tmp;

    // AccountLimits::publish_unrestricted_limits<LBR::LBR>($t19, $t20)
    call $AccountLimits_publish_unrestricted_limits($LBR_LBR_type_value(), $t19, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 6005);
      goto Abort;
    }

    // $t21 := copy($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t21 := $tmp;

    // $t22 := copy($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t22 := $tmp;

    // AccountLimits::publish_unrestricted_limits<Coin1::Coin1>($t21, $t22)
    call $AccountLimits_publish_unrestricted_limits($Coin1_Coin1_type_value(), $t21, $t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 6005);
      goto Abort;
    }

    // $t23 := move($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t23 := $tmp;

    // $t24 := move($t26)
    call $tmp := $CopyOrMoveValue($t26);
    $t24 := $tmp;

    // AccountLimits::publish_unrestricted_limits<Coin2::Coin2>($t23, $t24)
    call $AccountLimits_publish_unrestricted_limits($Coin2_Coin2_type_value(), $t23, $t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 6005);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $AccountLimits_initialize(lr_account: $Value, calling_cap: $Value) returns ()
free requires is#$Address(lr_account);
free requires $AccountLimits_CallingCapability_is_well_formed(calling_cap);
{
    call $AccountLimits_initialize_def(lr_account, calling_cap);
}

procedure {:inline 1} $AccountLimits_can_receive_def($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var holding_ok: $Value; // $BooleanType()
    var inflow_ok: $Value; // $BooleanType()
    var limits_definition: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t5: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t6: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t7: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t11: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t12: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t13: $Value; // $BooleanType()
    var $t14: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t15: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t16: $Value; // $BooleanType()
    var $t17: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t18: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t19: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t20: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t21: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t22: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $BooleanType()
    var $t40: $Value; // $BooleanType()
    var $t41: $Value; // $BooleanType()
    var $t42: $Value; // $BooleanType()
    var $t43: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $IntegerType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t49: $Reference; // ReferenceType($IntegerType())
    var $t50: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t51: $Value; // $IntegerType()
    var $t52: $Value; // $IntegerType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Value; // $IntegerType()
    var $t55: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t56: $Reference; // ReferenceType($IntegerType())
    var $t57: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t58: $Value; // $BooleanType()
    var $t59: $Value; // $BooleanType()
    var $t60: $Value; // $BooleanType()
    var $t61: $Value; // $IntegerType()
    var $t62: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t63: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t64: $Value; // $AccountLimits_Window_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 8777, 0, amount); }
    if (true) { assume $DebugTrackLocal(2, 8777, 1, receiving); }

    // bytecode translation starts here
    // $t61 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t61 := $tmp;

    // $t62 := move(receiving)
    call $tmp := $CopyOrMoveValue(receiving);
    $t62 := $tmp;

    // $t63 := borrow_local($t62)
    call $t63 := $BorrowLoc(62, $t62);
    assume $AccountLimits_Window_is_well_formed($Dereference($t63));

    // $t7 := copy($t63)
    call $t7 := $CopyOrMoveRef($t63);

    // $t8 := get_field<AccountLimits::Window<#0>>.limit_address($t7)
    call $tmp := $GetFieldFromReference($t7, $AccountLimits_Window_limit_address);
    assume is#$Address($tmp);
    $t8 := $tmp;

    // Reference($t63) <- $t7
    call $t63 := $WritebackToReference($t7, $t63);

    // $t9 := move($t8)
    call $tmp := $CopyOrMoveValue($t8);
    $t9 := $tmp;

    // $t10 := borrow_global<AccountLimits::LimitsDefinition<#0>>($t9)
    call $t10 := $BorrowGlobal($t9, $AccountLimits_LimitsDefinition_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 8939);
      goto Abort;
    }
    assume $AccountLimits_LimitsDefinition_is_well_formed($Dereference($t10));

    // UnpackRef($t10)

    // limits_definition := $t10
    call limits_definition := $CopyOrMoveRef($t10);
    if (true) { assume $DebugTrackLocal(2, 8919, 4, $Dereference(limits_definition)); }

    // $t11 := copy(limits_definition)
    call $t11 := $CopyOrMoveRef(limits_definition);

    // $t12 := read_ref($t11)
    call $tmp := $ReadRef($t11);
    assume $AccountLimits_LimitsDefinition_is_well_formed($tmp);
    $t12 := $tmp;

    // Reference(limits_definition) <- $t11
    call limits_definition := $WritebackToReference($t11, limits_definition);

    // $t13 := AccountLimits::is_unrestricted<#0>($t12)
    call $t13 := $AccountLimits_is_unrestricted($tv0, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10930);
      goto Abort;
    }
    assume is#$Boolean($t13);


    // if ($t13) goto L0 else goto L1
    $tmp := $t13;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t14 := move($t63)
    call $t14 := $CopyOrMoveRef($t63);

    // destroy($t14)

    // LocalRoot($t62) <- $t14
    call $t62 := $WritebackToValue($t14, 62, $t62);

    // $t15 := move(limits_definition)
    call $t15 := $CopyOrMoveRef(limits_definition);

    // destroy($t15)

    // AccountLimits::LimitsDefinition <- $t15
    call $WritebackToGlobal($t15);

    // PackRef($t15)

    // $t16 := true
    $tmp := $Boolean(true);
    $t16 := $tmp;

    // return ($t16, $t62)
    $ret0 := $t16;
    if (true) { assume $DebugTrackLocal(2, 9130, 65, $ret0); }
    $ret1 := $t62;
    if (true) { assume $DebugTrackLocal(2, 9130, 66, $ret1); }
    return;

    // L2:
L2:

    // $t17 := copy($t63)
    call $t17 := $CopyOrMoveRef($t63);

    // $t18 := copy(limits_definition)
    call $t18 := $CopyOrMoveRef(limits_definition);

    // $t6 := $t18
    call $t6 := $CopyOrMoveRef($t18);
    if (true) { assume $DebugTrackLocal(2, 9164, 6, $Dereference($t6)); }

    // $t5 := $t17
    call $t5 := $CopyOrMoveRef($t17);
    if (true) { assume $DebugTrackLocal(2, 9164, 5, $Dereference($t5)); }

    // $t19 := move($t5)
    call $t19 := $CopyOrMoveRef($t5);

    // $t20 := move($t6)
    call $t20 := $CopyOrMoveRef($t6);

    // $t21 := read_ref($t20)
    call $tmp := $ReadRef($t20);
    assume $AccountLimits_LimitsDefinition_is_well_formed($tmp);
    $t21 := $tmp;

    // Reference(limits_definition) <- $t20
    call limits_definition := $WritebackToReference($t20, limits_definition);

    // $t64 := read_ref($t19)
    call $tmp := $ReadRef($t19);
    assume $AccountLimits_Window_is_well_formed($tmp);
    $t64 := $tmp;

    // $t64 := AccountLimits::reset_window<#0>($t64, $t21)
    call $t64 := $AccountLimits_reset_window($tv0, $t64, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 8187);
      goto Abort;
    }
    assume $AccountLimits_Window_is_well_formed($t64);


    // write_ref($t19, $t64)
    call $t19 := $WriteRef($t19, $t64);
    if (true) { assume $DebugTrackLocal(2, 9781, 4, $Dereference(limits_definition)); }

    // Reference($t63) <- $t19
    call $t63 := $WritebackToReference($t19, $t63);

    // $t22 := copy($t63)
    call $t22 := $CopyOrMoveRef($t63);

    // $t23 := get_field<AccountLimits::Window<#0>>.window_inflow($t22)
    call $tmp := $GetFieldFromReference($t22, $AccountLimits_Window_window_inflow);
    assume $IsValidU64($tmp);
    $t23 := $tmp;

    // Reference($t63) <- $t22
    call $t63 := $WritebackToReference($t22, $t63);

    // $t24 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;

    // $t26 := +($t24, $t61)
    call $tmp := $AddU64($t24, $t61);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 9283);
      goto Abort;
    }
    $t26 := $tmp;

    // $t27 := copy(limits_definition)
    call $t27 := $CopyOrMoveRef(limits_definition);

    // $t28 := get_field<AccountLimits::LimitsDefinition<#0>>.max_inflow($t27)
    call $tmp := $GetFieldFromReference($t27, $AccountLimits_LimitsDefinition_max_inflow);
    assume $IsValidU64($tmp);
    $t28 := $tmp;

    // Reference(limits_definition) <- $t27
    call limits_definition := $WritebackToReference($t27, limits_definition);

    // $t29 := move($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t29 := $tmp;

    // $t30 := <=($t26, $t29)
    call $tmp := $Le($t26, $t29);
    $t30 := $tmp;

    // inflow_ok := $t30
    call $tmp := $CopyOrMoveValue($t30);
    inflow_ok := $tmp;
    if (true) { assume $DebugTrackLocal(2, 9247, 3, $tmp); }

    // $t31 := copy($t63)
    call $t31 := $CopyOrMoveRef($t63);

    // $t32 := get_field<AccountLimits::Window<#0>>.tracked_balance($t31)
    call $tmp := $GetFieldFromReference($t31, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($tmp);
    $t32 := $tmp;

    // Reference($t63) <- $t31
    call $t63 := $WritebackToReference($t31, $t63);

    // $t33 := move($t32)
    call $tmp := $CopyOrMoveValue($t32);
    $t33 := $tmp;

    // $t35 := +($t33, $t61)
    call $tmp := $AddU64($t33, $t61);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 9434);
      goto Abort;
    }
    $t35 := $tmp;

    // $t36 := move(limits_definition)
    call $t36 := $CopyOrMoveRef(limits_definition);

    // $t37 := get_field<AccountLimits::LimitsDefinition<#0>>.max_holding($t36)
    call $tmp := $GetFieldFromReference($t36, $AccountLimits_LimitsDefinition_max_holding);
    assume $IsValidU64($tmp);
    $t37 := $tmp;

    // AccountLimits::LimitsDefinition <- $t36
    call $WritebackToGlobal($t36);

    // PackRef($t36)

    // $t38 := move($t37)
    call $tmp := $CopyOrMoveValue($t37);
    $t38 := $tmp;

    // $t39 := <=($t35, $t38)
    call $tmp := $Le($t35, $t38);
    $t39 := $tmp;

    // holding_ok := $t39
    call $tmp := $CopyOrMoveValue($t39);
    holding_ok := $tmp;
    if (true) { assume $DebugTrackLocal(2, 9395, 2, $tmp); }

    // $t42 := &&(inflow_ok, holding_ok)
    call $tmp := $And(inflow_ok, holding_ok);
    $t42 := $tmp;

    // if ($t42) goto L3 else goto L4
    $tmp := $t42;
    if (b#$Boolean($tmp)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // $t43 := copy($t63)
    call $t43 := $CopyOrMoveRef($t63);

    // $t44 := get_field<AccountLimits::Window<#0>>.window_inflow($t43)
    call $tmp := $GetFieldFromReference($t43, $AccountLimits_Window_window_inflow);
    assume $IsValidU64($tmp);
    $t44 := $tmp;

    // Reference($t63) <- $t43
    call $t63 := $WritebackToReference($t43, $t63);

    // $t45 := move($t44)
    call $tmp := $CopyOrMoveValue($t44);
    $t45 := $tmp;

    // $t47 := +($t45, $t61)
    call $tmp := $AddU64($t45, $t61);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 9663);
      goto Abort;
    }
    $t47 := $tmp;

    // $t48 := copy($t63)
    call $t48 := $CopyOrMoveRef($t63);

    // $t49 := borrow_field<AccountLimits::Window<#0>>.window_inflow($t48)
    call $t49 := $BorrowField($t48, $AccountLimits_Window_window_inflow);
    assume $IsValidU64($Dereference($t49));

    // Reference($t63) <- $t48
    call $t63 := $WritebackToReference($t48, $t63);

    // UnpackRef($t49)

    // write_ref($t49, $t47)
    call $t49 := $WriteRef($t49, $t47);
    if (true) { assume $DebugTrackLocal(2, 9613, 4, $Dereference(limits_definition)); }

    // Reference($t63) <- $t49
    call $t63 := $WritebackToReference($t49, $t63);

    // Reference($t48) <- $t49
    call $t48 := $WritebackToReference($t49, $t48);

    // PackRef($t49)

    // $t50 := copy($t63)
    call $t50 := $CopyOrMoveRef($t63);

    // $t51 := get_field<AccountLimits::Window<#0>>.tracked_balance($t50)
    call $tmp := $GetFieldFromReference($t50, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($tmp);
    $t51 := $tmp;

    // Reference($t63) <- $t50
    call $t63 := $WritebackToReference($t50, $t63);

    // $t52 := move($t51)
    call $tmp := $CopyOrMoveValue($t51);
    $t52 := $tmp;

    // $t54 := +($t52, $t61)
    call $tmp := $AddU64($t52, $t61);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 9739);
      goto Abort;
    }
    $t54 := $tmp;

    // $t55 := move($t63)
    call $t55 := $CopyOrMoveRef($t63);

    // $t56 := borrow_field<AccountLimits::Window<#0>>.tracked_balance($t55)
    call $t56 := $BorrowField($t55, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($Dereference($t56));

    // LocalRoot($t62) <- $t55
    call $t62 := $WritebackToValue($t55, 62, $t62);

    // UnpackRef($t56)

    // write_ref($t56, $t54)
    call $t56 := $WriteRef($t56, $t54);
    if (true) { assume $DebugTrackLocal(2, 9685, 4, $Dereference(limits_definition)); }

    // LocalRoot($t62) <- $t56
    call $t62 := $WritebackToValue($t56, 62, $t62);

    // Reference($t55) <- $t56
    call $t55 := $WritebackToReference($t56, $t55);

    // PackRef($t56)

    // goto L6
    goto L6;

    // L5:
L5:

    // $t57 := move($t63)
    call $t57 := $CopyOrMoveRef($t63);

    // destroy($t57)

    // LocalRoot($t62) <- $t57
    call $t62 := $WritebackToValue($t57, 62, $t62);

    // goto L6
    goto L6;

    // L6:
L6:

    // $t60 := &&(inflow_ok, holding_ok)
    call $tmp := $And(inflow_ok, holding_ok);
    $t60 := $tmp;

    // return ($t60, $t62)
    $ret0 := $t60;
    if (true) { assume $DebugTrackLocal(2, 9768, 65, $ret0); }
    $ret1 := $t62;
    if (true) { assume $DebugTrackLocal(2, 9768, 66, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_can_receive($tv0: $TypeValue, amount: $Value, receiving: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $IsValidU64(amount);
free requires $AccountLimits_Window_is_well_formed(receiving);
{
    call $ret0, $ret1 := $AccountLimits_can_receive_def($tv0, amount, receiving);
}

procedure {:inline 1} $AccountLimits_can_withdraw_def($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var limits_definition: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var outflow_ok: $Value; // $BooleanType()
    var $t4: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t5: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t6: $Value; // $IntegerType()
    var $t7: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t11: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t12: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t13: $Value; // $BooleanType()
    var $t14: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t15: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t16: $Value; // $BooleanType()
    var $t17: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t18: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t19: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t20: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t21: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t22: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $BooleanType()
    var $t32: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t38: $Reference; // ReferenceType($IntegerType())
    var $t39: $Value; // $IntegerType()
    var $t40: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $BooleanType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t46: $Value; // $IntegerType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Value; // $IntegerType()
    var $t50: $Value; // $IntegerType()
    var $t51: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t52: $Reference; // ReferenceType($IntegerType())
    var $t53: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t54: $Value; // $BooleanType()
    var $t55: $Value; // $IntegerType()
    var $t56: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t57: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t58: $Value; // $AccountLimits_Window_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 9981, 0, amount); }
    if (true) { assume $DebugTrackLocal(2, 9981, 1, sending); }

    // bytecode translation starts here
    // $t55 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t55 := $tmp;

    // $t56 := move(sending)
    call $tmp := $CopyOrMoveValue(sending);
    $t56 := $tmp;

    // $t57 := borrow_local($t56)
    call $t57 := $BorrowLoc(56, $t56);
    assume $AccountLimits_Window_is_well_formed($Dereference($t57));

    // $t7 := copy($t57)
    call $t7 := $CopyOrMoveRef($t57);

    // $t8 := get_field<AccountLimits::Window<#0>>.limit_address($t7)
    call $tmp := $GetFieldFromReference($t7, $AccountLimits_Window_limit_address);
    assume is#$Address($tmp);
    $t8 := $tmp;

    // Reference($t57) <- $t7
    call $t57 := $WritebackToReference($t7, $t57);

    // $t9 := move($t8)
    call $tmp := $CopyOrMoveValue($t8);
    $t9 := $tmp;

    // $t10 := borrow_global<AccountLimits::LimitsDefinition<#0>>($t9)
    call $t10 := $BorrowGlobal($t9, $AccountLimits_LimitsDefinition_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10142);
      goto Abort;
    }
    assume $AccountLimits_LimitsDefinition_is_well_formed($Dereference($t10));

    // UnpackRef($t10)

    // limits_definition := $t10
    call limits_definition := $CopyOrMoveRef($t10);
    if (true) { assume $DebugTrackLocal(2, 10122, 2, $Dereference(limits_definition)); }

    // $t11 := copy(limits_definition)
    call $t11 := $CopyOrMoveRef(limits_definition);

    // $t12 := read_ref($t11)
    call $tmp := $ReadRef($t11);
    assume $AccountLimits_LimitsDefinition_is_well_formed($tmp);
    $t12 := $tmp;

    // Reference(limits_definition) <- $t11
    call limits_definition := $WritebackToReference($t11, limits_definition);

    // $t13 := AccountLimits::is_unrestricted<#0>($t12)
    call $t13 := $AccountLimits_is_unrestricted($tv0, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10930);
      goto Abort;
    }
    assume is#$Boolean($t13);


    // if ($t13) goto L0 else goto L1
    $tmp := $t13;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t14 := move($t57)
    call $t14 := $CopyOrMoveRef($t57);

    // destroy($t14)

    // LocalRoot($t56) <- $t14
    call $t56 := $WritebackToValue($t14, 56, $t56);

    // $t15 := move(limits_definition)
    call $t15 := $CopyOrMoveRef(limits_definition);

    // destroy($t15)

    // AccountLimits::LimitsDefinition <- $t15
    call $WritebackToGlobal($t15);

    // PackRef($t15)

    // $t16 := true
    $tmp := $Boolean(true);
    $t16 := $tmp;

    // return ($t16, $t56)
    $ret0 := $t16;
    if (true) { assume $DebugTrackLocal(2, 10331, 59, $ret0); }
    $ret1 := $t56;
    if (true) { assume $DebugTrackLocal(2, 10331, 60, $ret1); }
    return;

    // L2:
L2:

    // $t17 := copy($t57)
    call $t17 := $CopyOrMoveRef($t57);

    // $t18 := copy(limits_definition)
    call $t18 := $CopyOrMoveRef(limits_definition);

    // $t5 := $t18
    call $t5 := $CopyOrMoveRef($t18);
    if (true) { assume $DebugTrackLocal(2, 10365, 5, $Dereference($t5)); }

    // $t4 := $t17
    call $t4 := $CopyOrMoveRef($t17);
    if (true) { assume $DebugTrackLocal(2, 10365, 4, $Dereference($t4)); }

    // $t19 := move($t4)
    call $t19 := $CopyOrMoveRef($t4);

    // $t20 := move($t5)
    call $t20 := $CopyOrMoveRef($t5);

    // $t21 := read_ref($t20)
    call $tmp := $ReadRef($t20);
    assume $AccountLimits_LimitsDefinition_is_well_formed($tmp);
    $t21 := $tmp;

    // Reference(limits_definition) <- $t20
    call limits_definition := $WritebackToReference($t20, limits_definition);

    // $t58 := read_ref($t19)
    call $tmp := $ReadRef($t19);
    assume $AccountLimits_Window_is_well_formed($tmp);
    $t58 := $tmp;

    // $t58 := AccountLimits::reset_window<#0>($t58, $t21)
    call $t58 := $AccountLimits_reset_window($tv0, $t58, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 8187);
      goto Abort;
    }
    assume $AccountLimits_Window_is_well_formed($t58);


    // write_ref($t19, $t58)
    call $t19 := $WriteRef($t19, $t58);
    if (true) { assume $DebugTrackLocal(2, 10826, 2, $Dereference(limits_definition)); }

    // Reference($t57) <- $t19
    call $t57 := $WritebackToReference($t19, $t57);

    // $t22 := copy($t57)
    call $t22 := $CopyOrMoveRef($t57);

    // $t23 := get_field<AccountLimits::Window<#0>>.window_outflow($t22)
    call $tmp := $GetFieldFromReference($t22, $AccountLimits_Window_window_outflow);
    assume $IsValidU64($tmp);
    $t23 := $tmp;

    // Reference($t57) <- $t22
    call $t57 := $WritebackToReference($t22, $t57);

    // $t24 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t24 := $tmp;

    // $t26 := +($t24, $t55)
    call $tmp := $AddU64($t24, $t55);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10474);
      goto Abort;
    }
    $t26 := $tmp;

    // $t27 := move(limits_definition)
    call $t27 := $CopyOrMoveRef(limits_definition);

    // $t28 := get_field<AccountLimits::LimitsDefinition<#0>>.max_outflow($t27)
    call $tmp := $GetFieldFromReference($t27, $AccountLimits_LimitsDefinition_max_outflow);
    assume $IsValidU64($tmp);
    $t28 := $tmp;

    // AccountLimits::LimitsDefinition <- $t27
    call $WritebackToGlobal($t27);

    // PackRef($t27)

    // $t29 := move($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t29 := $tmp;

    // $t30 := <=($t26, $t29)
    call $tmp := $Le($t26, $t29);
    $t30 := $tmp;

    // outflow_ok := $t30
    call $tmp := $CopyOrMoveValue($t30);
    outflow_ok := $tmp;
    if (true) { assume $DebugTrackLocal(2, 10438, 3, $tmp); }

    // if (outflow_ok) goto L3 else goto L4
    $tmp := outflow_ok;
    if (b#$Boolean($tmp)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // $t32 := copy($t57)
    call $t32 := $CopyOrMoveRef($t57);

    // $t33 := get_field<AccountLimits::Window<#0>>.window_outflow($t32)
    call $tmp := $GetFieldFromReference($t32, $AccountLimits_Window_window_outflow);
    assume $IsValidU64($tmp);
    $t33 := $tmp;

    // Reference($t57) <- $t32
    call $t57 := $WritebackToReference($t32, $t57);

    // $t34 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t34 := $tmp;

    // $t36 := +($t34, $t55)
    call $tmp := $AddU64($t34, $t55);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10640);
      goto Abort;
    }
    $t36 := $tmp;

    // $t37 := copy($t57)
    call $t37 := $CopyOrMoveRef($t57);

    // $t38 := borrow_field<AccountLimits::Window<#0>>.window_outflow($t37)
    call $t38 := $BorrowField($t37, $AccountLimits_Window_window_outflow);
    assume $IsValidU64($Dereference($t38));

    // Reference($t57) <- $t37
    call $t57 := $WritebackToReference($t37, $t57);

    // UnpackRef($t38)

    // write_ref($t38, $t36)
    call $t38 := $WriteRef($t38, $t36);
    if (true) { assume $DebugTrackLocal(2, 10592, 2, $Dereference(limits_definition)); }

    // Reference($t57) <- $t38
    call $t57 := $WritebackToReference($t38, $t57);

    // Reference($t37) <- $t38
    call $t37 := $WritebackToReference($t38, $t37);

    // PackRef($t38)

    // $t40 := copy($t57)
    call $t40 := $CopyOrMoveRef($t57);

    // $t41 := get_field<AccountLimits::Window<#0>>.tracked_balance($t40)
    call $tmp := $GetFieldFromReference($t40, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($tmp);
    $t41 := $tmp;

    // Reference($t57) <- $t40
    call $t57 := $WritebackToReference($t40, $t57);

    // $t42 := move($t41)
    call $tmp := $CopyOrMoveValue($t41);
    $t42 := $tmp;

    // $t43 := >=($t55, $t42)
    call $tmp := $Ge($t55, $t42);
    $t43 := $tmp;

    // if ($t43) goto L6 else goto L7
    $tmp := $t43;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t44 := 0
    $tmp := $Integer(0);
    $t44 := $tmp;

    // $t6 := $t44
    call $tmp := $CopyOrMoveValue($t44);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 10688, 6, $tmp); }

    // goto L9
    goto L9;

    // L8:
L8:

    // $t45 := copy($t57)
    call $t45 := $CopyOrMoveRef($t57);

    // $t46 := get_field<AccountLimits::Window<#0>>.tracked_balance($t45)
    call $tmp := $GetFieldFromReference($t45, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($tmp);
    $t46 := $tmp;

    // Reference($t57) <- $t45
    call $t57 := $WritebackToReference($t45, $t57);

    // $t47 := move($t46)
    call $tmp := $CopyOrMoveValue($t46);
    $t47 := $tmp;

    // $t49 := -($t47, $t55)
    call $tmp := $Sub($t47, $t55);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10797);
      goto Abort;
    }
    $t49 := $tmp;

    // $t6 := $t49
    call $tmp := $CopyOrMoveValue($t49);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 10688, 6, $tmp); }

    // goto L9
    goto L9;

    // L9:
L9:

    // $t51 := move($t57)
    call $t51 := $CopyOrMoveRef($t57);

    // $t52 := borrow_field<AccountLimits::Window<#0>>.tracked_balance($t51)
    call $t52 := $BorrowField($t51, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($Dereference($t52));

    // LocalRoot($t56) <- $t51
    call $t56 := $WritebackToValue($t51, 56, $t56);

    // UnpackRef($t52)

    // write_ref($t52, $t6)
    call $t52 := $WriteRef($t52, $t6);
    if (true) { assume $DebugTrackLocal(2, 10662, 2, $Dereference(limits_definition)); }

    // LocalRoot($t56) <- $t52
    call $t56 := $WritebackToValue($t52, 56, $t56);

    // Reference($t51) <- $t52
    call $t51 := $WritebackToReference($t52, $t51);

    // PackRef($t52)

    // goto L10
    goto L10;

    // L5:
L5:

    // $t53 := move($t57)
    call $t53 := $CopyOrMoveRef($t57);

    // destroy($t53)

    // LocalRoot($t56) <- $t53
    call $t56 := $WritebackToValue($t53, 56, $t56);

    // goto L10
    goto L10;

    // L10:
L10:

    // return (outflow_ok, $t56)
    $ret0 := outflow_ok;
    if (true) { assume $DebugTrackLocal(2, 10826, 59, $ret0); }
    $ret1 := $t56;
    if (true) { assume $DebugTrackLocal(2, 10826, 60, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_can_withdraw($tv0: $TypeValue, amount: $Value, sending: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $IsValidU64(amount);
free requires $AccountLimits_Window_is_well_formed(sending);
{
    call $ret0, $ret1 := $AccountLimits_can_withdraw_def($tv0, amount, sending);
}

procedure {:inline 1} $AccountLimits_current_time_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $IntegerType()
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := LibraTimestamp::is_not_initialized()
    call $t1 := $LibraTimestamp_is_not_initialized();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 11706);
      goto Abort;
    }
    assume is#$Boolean($t1);


    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t2 := 0
    $tmp := $Integer(0);
    $t2 := $tmp;

    // $t0 := $t2
    call $tmp := $CopyOrMoveValue($t2);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11686, 0, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t3 := LibraTimestamp::now_microseconds()
    call $t3 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 11751);
      goto Abort;
    }
    assume $IsValidU64($t3);


    // $t0 := $t3
    call $tmp := $CopyOrMoveValue($t3);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11686, 0, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(2, 11686, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_current_time() returns ($ret0: $Value)
{
    call $ret0 := $AccountLimits_current_time_def();
}

procedure {:inline 1} $AccountLimits_grant_calling_capability_def(lr_account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t15: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 2331, 0, lr_account); }

    // bytecode translation starts here
    // $t15 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t15 := $tmp;

    // $t5 := LibraTimestamp::is_genesis()
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 2440);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // $t1 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 2417, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t7 := $tmp;

    // destroy($t7)

    // $t8 := 0
    $tmp := $Integer(0);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(2, 2417); }
    goto Abort;

    // L0:
L0:

    // $t9 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t9 := $tmp;

    // $t10 := Roles::has_libra_root_role($t9)
    call $t10 := $Roles_has_libra_root_role($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 165);
      goto Abort;
    }
    assume is#$Boolean($t10);


    // $t3 := $t10
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 2477, 3, $tmp); }

    // if ($t3) goto L2 else goto L3
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t12 := 2
    $tmp := $Integer(2);
    $t12 := $tmp;

    // abort($t12)
    if (true) { assume $DebugTrackAbort(2, 2477); }
    goto Abort;

    // L2:
L2:

    // $t13 := false
    $tmp := $Boolean(false);
    $t13 := $tmp;

    // $t14 := pack AccountLimits::CallingCapability($t13)
    call $tmp := $AccountLimits_CallingCapability_pack(0, 0, 0, $t13);
    $t14 := $tmp;

    // return $t14
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(2, 2543, 16, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_grant_calling_capability(lr_account: $Value) returns ($ret0: $Value)
free requires is#$Address(lr_account);
{
    call $ret0 := $AccountLimits_grant_calling_capability_def(lr_account);
}

procedure {:inline 1} $AccountLimits_has_limits_published_def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 11527, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;

    // $t2 := exists<AccountLimits::LimitsDefinition<#0>>($t3)
    call $tmp := $Exists($t3, $AccountLimits_LimitsDefinition_type_value($tv0));
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(2, 11600, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_has_limits_published($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $AccountLimits_has_limits_published_def($tv0, addr);
}

procedure {:inline 1} $AccountLimits_is_unlimited_account_def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 11352, 0, addr); }

    // bytecode translation starts here
    // $t4 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;

    // $t2 := get_global<AccountLimits::LimitsDefinition<#0>>($t4)
    call $tmp := $GetGlobal($t4, $AccountLimits_LimitsDefinition_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 11467);
      goto Abort;
    }
    assume $AccountLimits_LimitsDefinition_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := AccountLimits::is_unrestricted<#0>($t2)
    call $t3 := $AccountLimits_is_unrestricted($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 10930);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(2, 11451, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_is_unlimited_account($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $AccountLimits_is_unlimited_account_def($tv0, addr);
}

procedure {:inline 1} $AccountLimits_is_unrestricted_def($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 10926, 0, limits_def); }

    // bytecode translation starts here
    // $t31 := move(limits_def)
    call $tmp := $CopyOrMoveValue(limits_def);
    $t31 := $tmp;

    // $t4 := copy($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t4 := $tmp;

    // $t5 := get_field<AccountLimits::LimitsDefinition<#0>>.max_inflow($t4)
    call $tmp := $GetFieldFromValue($t4, $AccountLimits_LimitsDefinition_max_inflow);
    assume $IsValidU64($tmp);
    $t5 := $tmp;

    // $t6 := move($t5)
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;

    // $t7 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t7 := $tmp;

    // $t8 := ==($t6, $t7)
    $tmp := $Boolean($IsEqual($t6, $t7));
    $t8 := $tmp;

    // if ($t8) goto L0 else goto L1
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t9 := copy($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t9 := $tmp;

    // $t10 := get_field<AccountLimits::LimitsDefinition<#0>>.max_outflow($t9)
    call $tmp := $GetFieldFromValue($t9, $AccountLimits_LimitsDefinition_max_outflow);
    assume $IsValidU64($tmp);
    $t10 := $tmp;

    // $t11 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t11 := $tmp;

    // $t12 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t12 := $tmp;

    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t1 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11013, 1, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t14 := false
    $tmp := $Boolean(false);
    $t14 := $tmp;

    // $t1 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11013, 1, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if ($t1) goto L4 else goto L5
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t16 := copy($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t16 := $tmp;

    // $t17 := get_field<AccountLimits::LimitsDefinition<#0>>.max_holding($t16)
    call $tmp := $GetFieldFromValue($t16, $AccountLimits_LimitsDefinition_max_holding);
    assume $IsValidU64($tmp);
    $t17 := $tmp;

    // $t18 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;

    // $t19 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t19 := $tmp;

    // $t20 := ==($t18, $t19)
    $tmp := $Boolean($IsEqual($t18, $t19));
    $t20 := $tmp;

    // $t2 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11013, 2, $tmp); }

    // goto L7
    goto L7;

    // L6:
L6:

    // $t21 := false
    $tmp := $Boolean(false);
    $t21 := $tmp;

    // $t2 := $t21
    call $tmp := $CopyOrMoveValue($t21);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11013, 2, $tmp); }

    // goto L7
    goto L7;

    // L7:
L7:

    // if ($t2) goto L8 else goto L9
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // goto L10
    goto L10;

    // L8:
L8:

    // $t23 := move($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t23 := $tmp;

    // $t24 := get_field<AccountLimits::LimitsDefinition<#0>>.time_period($t23)
    call $tmp := $GetFieldFromValue($t23, $AccountLimits_LimitsDefinition_time_period);
    assume $IsValidU64($tmp);
    $t24 := $tmp;

    // $t25 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t25 := $tmp;

    // $t26 := 86400000000
    $tmp := $Integer(86400000000);
    $t26 := $tmp;

    // $t27 := ==($t25, $t26)
    $tmp := $Boolean($IsEqual($t25, $t26));
    $t27 := $tmp;

    // $t3 := $t27
    call $tmp := $CopyOrMoveValue($t27);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11013, 3, $tmp); }

    // goto L11
    goto L11;

    // L10:
L10:

    // $t28 := move($t31)
    call $tmp := $CopyOrMoveValue($t31);
    $t28 := $tmp;

    // destroy($t28)

    // $t29 := false
    $tmp := $Boolean(false);
    $t29 := $tmp;

    // $t3 := $t29
    call $tmp := $CopyOrMoveValue($t29);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 11013, 3, $tmp); }

    // goto L11
    goto L11;

    // L11:
L11:

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(2, 11013, 32, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_is_unrestricted($tv0: $TypeValue, limits_def: $Value) returns ($ret0: $Value)
free requires $AccountLimits_LimitsDefinition_is_well_formed(limits_def);
{
    call $ret0 := $AccountLimits_is_unrestricted_def($tv0, limits_def);
}

procedure {:inline 1} $AccountLimits_limits_definition_address_def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 11192, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<AccountLimits::Window<#0>>($t5)
    call $tmp := $GetGlobal($t5, $AccountLimits_Window_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 11289);
      goto Abort;
    }
    assume $AccountLimits_Window_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<AccountLimits::Window<#0>>.limit_address($t2)
    call $tmp := $GetFieldFromValue($t2, $AccountLimits_Window_limit_address);
    assume is#$Address($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(2, 11289, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_limits_definition_address($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $AccountLimits_limits_definition_address_def($tv0, addr);
}

procedure {:inline 1} $AccountLimits_publish_limits_definition_def($tv0: $TypeValue, account: $Value, _: $Value, max_inflow: $Value, max_outflow: $Value, max_holding: $Value, time_period: $Value) returns (){
    // declare local variables
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 5437, 0, account); }
    if (true) { assume $DebugTrackLocal(2, 5437, 1, _); }
    if (true) { assume $DebugTrackLocal(2, 5437, 2, max_inflow); }
    if (true) { assume $DebugTrackLocal(2, 5437, 3, max_outflow); }
    if (true) { assume $DebugTrackLocal(2, 5437, 4, max_holding); }
    if (true) { assume $DebugTrackLocal(2, 5437, 5, time_period); }

    // bytecode translation starts here
    // $t22 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t22 := $tmp;

    // $t23 := move(_)
    call $tmp := $CopyOrMoveValue(_);
    $t23 := $tmp;

    // $t24 := move(max_inflow)
    call $tmp := $CopyOrMoveValue(max_inflow);
    $t24 := $tmp;

    // $t25 := move(max_outflow)
    call $tmp := $CopyOrMoveValue(max_outflow);
    $t25 := $tmp;

    // $t26 := move(max_holding)
    call $tmp := $CopyOrMoveValue(max_holding);
    $t26 := $tmp;

    // $t27 := move(time_period)
    call $tmp := $CopyOrMoveValue(time_period);
    $t27 := $tmp;

    // $t11 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t11 := $tmp;

    // $t10 := $t11
    call $tmp := $CopyOrMoveValue($t11);
    $t10 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 5681, 10, $tmp); }

    // $t6 := $t24
    call $tmp := $CopyOrMoveValue($t24);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 5747, 6, $tmp); }

    // $t7 := $t25
    call $tmp := $CopyOrMoveValue($t25);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 5775, 7, $tmp); }

    // $t8 := $t26
    call $tmp := $CopyOrMoveValue($t26);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 5804, 8, $tmp); }

    // $t9 := $t27
    call $tmp := $CopyOrMoveValue($t27);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 5833, 9, $tmp); }

    // $t16 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t16 := $tmp;

    // $t21 := pack AccountLimits::LimitsDefinition<#0>($t6, $t7, $t9, $t8)
    call $tmp := $AccountLimits_LimitsDefinition_pack(0, 0, 0, $tv0, $t6, $t7, $t9, $t8);
    $t21 := $tmp;

    // move_to<AccountLimits::LimitsDefinition<#0>>($t21, $t16)
    call $MoveTo($AccountLimits_LimitsDefinition_type_value($tv0), $t21, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 5660);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $AccountLimits_publish_limits_definition($tv0: $TypeValue, account: $Value, _: $Value, max_inflow: $Value, max_outflow: $Value, max_holding: $Value, time_period: $Value) returns ()
free requires is#$Address(account);
free requires $AccountLimits_CallingCapability_is_well_formed(_);
free requires $IsValidU64(max_inflow);
free requires $IsValidU64(max_outflow);
free requires $IsValidU64(max_holding);
free requires $IsValidU64(time_period);
{
    call $AccountLimits_publish_limits_definition_def($tv0, account, _, max_inflow, max_outflow, max_holding, time_period);
}

procedure {:inline 1} $AccountLimits_publish_unrestricted_limits_def($tv0: $TypeValue, account: $Value, cap: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AccountLimits_CallingCapability_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 5994, 0, account); }
    if (true) { assume $DebugTrackLocal(2, 5994, 1, cap); }

    // bytecode translation starts here
    // $t8 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t8 := $tmp;

    // $t9 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;

    // $t2 := move($t8)
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;

    // $t3 := move($t9)
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;

    // $t4 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t4 := $tmp;

    // $t5 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t5 := $tmp;

    // $t6 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t6 := $tmp;

    // $t7 := 86400000000
    $tmp := $Integer(86400000000);
    $t7 := $tmp;

    // AccountLimits::publish_limits_definition<#0>($t2, $t3, $t4, $t5, $t6, $t7)
    call $AccountLimits_publish_limits_definition($tv0, $t2, $t3, $t4, $t5, $t6, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 5448);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $AccountLimits_publish_unrestricted_limits($tv0: $TypeValue, account: $Value, cap: $Value) returns ()
free requires is#$Address(account);
free requires $AccountLimits_CallingCapability_is_well_formed(cap);
{
    call $AccountLimits_publish_unrestricted_limits_def($tv0, account, cap);
}

procedure {:inline 1} $AccountLimits_publish_window_def($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t12: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 4853, 0, to_limit); }
    if (true) { assume $DebugTrackLocal(2, 4853, 1, _); }
    if (true) { assume $DebugTrackLocal(2, 4853, 2, limit_address); }

    // bytecode translation starts here
    // $t10 := move(to_limit)
    call $tmp := $CopyOrMoveValue(to_limit);
    $t10 := $tmp;

    // $t11 := move(_)
    call $tmp := $CopyOrMoveValue(_);
    $t11 := $tmp;

    // $t12 := move(limit_address)
    call $tmp := $CopyOrMoveValue(limit_address);
    $t12 := $tmp;

    // $t3 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;

    // $t4 := AccountLimits::current_time()
    call $t4 := $AccountLimits_current_time();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 11656);
      goto Abort;
    }
    assume $IsValidU64($t4);


    // $t5 := 0
    $tmp := $Integer(0);
    $t5 := $tmp;

    // $t6 := 0
    $tmp := $Integer(0);
    $t6 := $tmp;

    // $t7 := 0
    $tmp := $Integer(0);
    $t7 := $tmp;

    // $t9 := pack AccountLimits::Window<#0>($t4, $t5, $t6, $t7, $t12)
    call $tmp := $AccountLimits_Window_pack(0, 0, 0, $tv0, $t4, $t5, $t6, $t7, $t12);
    $t9 := $tmp;

    // move_to<AccountLimits::Window<#0>>($t9, $t3)
    call $MoveTo($AccountLimits_Window_type_value($tv0), $t9, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4996);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $AccountLimits_publish_window($tv0: $TypeValue, to_limit: $Value, _: $Value, limit_address: $Value) returns ()
free requires is#$Address(to_limit);
free requires $AccountLimits_CallingCapability_is_well_formed(_);
free requires is#$Address(limit_address);
{
    call $AccountLimits_publish_window_def($tv0, to_limit, _, limit_address);
}

procedure {:inline 1} $AccountLimits_reset_window_def($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value){
    // declare local variables
    var current_time: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t15: $Reference; // ReferenceType($IntegerType())
    var $t16: $Value; // $IntegerType()
    var $t17: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t18: $Reference; // ReferenceType($IntegerType())
    var $t19: $Value; // $IntegerType()
    var $t20: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t21: $Reference; // ReferenceType($IntegerType())
    var $t22: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t23: $Value; // $AccountLimits_Window_type_value($tv0)
    var $t24: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t25: $Value; // $AccountLimits_LimitsDefinition_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 8183, 0, window); }
    if (true) { assume $DebugTrackLocal(2, 8183, 1, limits_definition); }

    // bytecode translation starts here
    // $t23 := move(window)
    call $tmp := $CopyOrMoveValue(window);
    $t23 := $tmp;

    // $t25 := move(limits_definition)
    call $tmp := $CopyOrMoveValue(limits_definition);
    $t25 := $tmp;

    // $t24 := borrow_local($t23)
    call $t24 := $BorrowLoc(23, $t23);
    assume $AccountLimits_Window_is_well_formed($Dereference($t24));

    // $t3 := LibraTimestamp::now_microseconds()
    call $t3 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 8334);
      goto Abort;
    }
    assume $IsValidU64($t3);


    // current_time := $t3
    call $tmp := $CopyOrMoveValue($t3);
    current_time := $tmp;
    if (true) { assume $DebugTrackLocal(2, 8303, 2, $tmp); }

    // $t5 := copy($t24)
    call $t5 := $CopyOrMoveRef($t24);

    // $t6 := get_field<AccountLimits::Window<#0>>.window_start($t5)
    call $tmp := $GetFieldFromReference($t5, $AccountLimits_Window_window_start);
    assume $IsValidU64($tmp);
    $t6 := $tmp;

    // Reference($t24) <- $t5
    call $t24 := $WritebackToReference($t5, $t24);

    // $t7 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;

    // $t8 := move($t25)
    call $tmp := $CopyOrMoveValue($t25);
    $t8 := $tmp;

    // $t9 := get_field<AccountLimits::LimitsDefinition<#0>>.time_period($t8)
    call $tmp := $GetFieldFromValue($t8, $AccountLimits_LimitsDefinition_time_period);
    assume $IsValidU64($tmp);
    $t9 := $tmp;

    // $t10 := move($t9)
    call $tmp := $CopyOrMoveValue($t9);
    $t10 := $tmp;

    // $t11 := +($t7, $t10)
    call $tmp := $AddU64($t7, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 8401);
      goto Abort;
    }
    $t11 := $tmp;

    // $t12 := >(current_time, $t11)
    call $tmp := $Gt(current_time, $t11);
    $t12 := $tmp;

    // if ($t12) goto L0 else goto L1
    $tmp := $t12;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t14 := copy($t24)
    call $t14 := $CopyOrMoveRef($t24);

    // $t15 := borrow_field<AccountLimits::Window<#0>>.window_start($t14)
    call $t15 := $BorrowField($t14, $AccountLimits_Window_window_start);
    assume $IsValidU64($Dereference($t15));

    // Reference($t24) <- $t14
    call $t24 := $WritebackToReference($t14, $t24);

    // UnpackRef($t15)

    // write_ref($t15, current_time)
    call $t15 := $WriteRef($t15, current_time);

    // Reference($t24) <- $t15
    call $t24 := $WritebackToReference($t15, $t24);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // PackRef($t15)

    // $t16 := 0
    $tmp := $Integer(0);
    $t16 := $tmp;

    // $t17 := copy($t24)
    call $t17 := $CopyOrMoveRef($t24);

    // $t18 := borrow_field<AccountLimits::Window<#0>>.window_inflow($t17)
    call $t18 := $BorrowField($t17, $AccountLimits_Window_window_inflow);
    assume $IsValidU64($Dereference($t18));

    // Reference($t24) <- $t17
    call $t24 := $WritebackToReference($t17, $t24);

    // UnpackRef($t18)

    // write_ref($t18, $t16)
    call $t18 := $WriteRef($t18, $t16);

    // Reference($t24) <- $t18
    call $t24 := $WritebackToReference($t18, $t24);

    // Reference($t17) <- $t18
    call $t17 := $WritebackToReference($t18, $t17);

    // PackRef($t18)

    // $t19 := 0
    $tmp := $Integer(0);
    $t19 := $tmp;

    // $t20 := move($t24)
    call $t20 := $CopyOrMoveRef($t24);

    // $t21 := borrow_field<AccountLimits::Window<#0>>.window_outflow($t20)
    call $t21 := $BorrowField($t20, $AccountLimits_Window_window_outflow);
    assume $IsValidU64($Dereference($t21));

    // LocalRoot($t23) <- $t20
    call $t23 := $WritebackToValue($t20, 23, $t23);

    // UnpackRef($t21)

    // write_ref($t21, $t19)
    call $t21 := $WriteRef($t21, $t19);

    // LocalRoot($t23) <- $t21
    call $t23 := $WritebackToValue($t21, 23, $t23);

    // Reference($t20) <- $t21
    call $t20 := $WritebackToReference($t21, $t20);

    // PackRef($t21)

    // goto L3
    goto L3;

    // L2:
L2:

    // $t22 := move($t24)
    call $t22 := $CopyOrMoveRef($t24);

    // destroy($t22)

    // LocalRoot($t23) <- $t22
    call $t23 := $WritebackToValue($t22, 23, $t23);

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t23
    $ret0 := $t23;
    if (true) { assume $DebugTrackLocal(2, 8362, 26, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_reset_window($tv0: $TypeValue, window: $Value, limits_definition: $Value) returns ($ret0: $Value)
free requires $AccountLimits_Window_is_well_formed(window);
free requires $AccountLimits_LimitsDefinition_is_well_formed(limits_definition);
{
    call $ret0 := $AccountLimits_reset_window_def($tv0, window, limits_definition);
}

procedure {:inline 1} $AccountLimits_set_current_holdings_def($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t12: $Reference; // ReferenceType($IntegerType())
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 7442, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(2, 7442, 1, window_address); }
    if (true) { assume $DebugTrackLocal(2, 7442, 2, aggregate_balance); }

    // bytecode translation starts here
    // $t13 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t13 := $tmp;

    // $t14 := move(window_address)
    call $tmp := $CopyOrMoveValue(window_address);
    $t14 := $tmp;

    // $t15 := move(aggregate_balance)
    call $tmp := $CopyOrMoveValue(aggregate_balance);
    $t15 := $tmp;

    // $t5 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t5 := $tmp;

    // $t6 := Roles::has_treasury_compliance_role($t5)
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 186);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 7611, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := 3
    $tmp := $Integer(3);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(2, 7611); }
    goto Abort;

    // L0:
L0:

    // $t11 := borrow_global<AccountLimits::Window<#0>>($t14)
    call $t11 := $BorrowGlobal($t14, $AccountLimits_Window_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 7695);
      goto Abort;
    }
    assume $AccountLimits_Window_is_well_formed($Dereference($t11));

    // UnpackRef($t11)

    // $t12 := borrow_field<AccountLimits::Window<#0>>.tracked_balance($t11)
    call $t12 := $BorrowField($t11, $AccountLimits_Window_tracked_balance);
    assume $IsValidU64($Dereference($t12));

    // AccountLimits::Window <- $t11
    call $WritebackToGlobal($t11);

    // UnpackRef($t12)

    // write_ref($t12, $t15)
    call $t12 := $WriteRef($t12, $t15);

    // AccountLimits::Window <- $t12
    call $WritebackToGlobal($t12);

    // Reference($t11) <- $t12
    call $t11 := $WritebackToReference($t12, $t11);

    // PackRef($t11)

    // PackRef($t12)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $AccountLimits_set_current_holdings($tv0: $TypeValue, tc_account: $Value, window_address: $Value, aggregate_balance: $Value) returns ()
free requires is#$Address(tc_account);
free requires is#$Address(window_address);
free requires $IsValidU64(aggregate_balance);
{
    call $AccountLimits_set_current_holdings_def($tv0, tc_account, window_address, aggregate_balance);
}

procedure {:inline 1} $AccountLimits_update_deposit_limits_def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t10: $Value; // $AccountLimits_Window_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 3324, 0, amount); }
    if (true) { assume $DebugTrackLocal(2, 3324, 1, addr); }
    if (true) { assume $DebugTrackLocal(2, 3324, 2, _cap); }

    // bytecode translation starts here
    // $t7 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t7 := $tmp;

    // $t8 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;

    // $t9 := move(_cap)
    call $tmp := $CopyOrMoveValue(_cap);
    $t9 := $tmp;

    // $t5 := borrow_global<AccountLimits::Window<#0>>($t8)
    call $t5 := $BorrowGlobal($t8, $AccountLimits_Window_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 3557);
      goto Abort;
    }
    assume $AccountLimits_Window_is_well_formed($Dereference($t5));

    // UnpackRef($t5)

    // $t10 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $AccountLimits_Window_is_well_formed($tmp);
    $t10 := $tmp;

    // ($t6, $t10) := AccountLimits::can_receive<#0>($t7, $t10)
    call $t6, $t10 := $AccountLimits_can_receive($tv0, $t7, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 8781);
      goto Abort;
    }
    assume is#$Boolean($t6);

    assume $AccountLimits_Window_is_well_formed($t10);


    // write_ref($t5, $t10)
    call $t5 := $WriteRef($t5, $t10);

    // AccountLimits::Window <- $t5
    call $WritebackToGlobal($t5);

    // PackRef($t5)

    // return $t6
    $ret0 := $t6;
    if (true) { assume $DebugTrackLocal(2, 3502, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_update_deposit_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value);
free requires $IsValidU64(amount);
free requires is#$Address(addr);
free requires $AccountLimits_CallingCapability_is_well_formed(_cap);
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $AccountLimits_spec_update_deposit_limits($tv0, amount, addr)))));
procedure {:inline 1} $AccountLimits_update_limits_definition_def($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value) returns (){
    // declare local variables
    var limits_def: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t19: $Reference; // ReferenceType($IntegerType())
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t25: $Reference; // ReferenceType($IntegerType())
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t31: $Reference; // ReferenceType($IntegerType())
    var $t32: $Reference; // ReferenceType($AccountLimits_LimitsDefinition_type_value($tv0))
    var $t33: $Value; // $AddressType()
    var $t34: $Value; // $AddressType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 6356, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(2, 6356, 1, limit_address); }
    if (true) { assume $DebugTrackLocal(2, 6356, 2, new_max_inflow); }
    if (true) { assume $DebugTrackLocal(2, 6356, 3, new_max_outflow); }
    if (true) { assume $DebugTrackLocal(2, 6356, 4, new_max_holding_balance); }

    // bytecode translation starts here
    // $t33 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t33 := $tmp;

    // $t34 := move(limit_address)
    call $tmp := $CopyOrMoveValue(limit_address);
    $t34 := $tmp;

    // $t35 := move(new_max_inflow)
    call $tmp := $CopyOrMoveValue(new_max_inflow);
    $t35 := $tmp;

    // $t36 := move(new_max_outflow)
    call $tmp := $CopyOrMoveValue(new_max_outflow);
    $t36 := $tmp;

    // $t37 := move(new_max_holding_balance)
    call $tmp := $CopyOrMoveValue(new_max_holding_balance);
    $t37 := $tmp;

    // $t8 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t8 := $tmp;

    // $t9 := Roles::has_treasury_compliance_role($t8)
    call $t9 := $Roles_has_treasury_compliance_role($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 186);
      goto Abort;
    }
    assume is#$Boolean($t9);


    // $t6 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(2, 6603, 6, $tmp); }

    // if ($t6) goto L0 else goto L1
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t11 := 3
    $tmp := $Integer(3);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(2, 6603); }
    goto Abort;

    // L0:
L0:

    // $t13 := borrow_global<AccountLimits::LimitsDefinition<#0>>($t34)
    call $t13 := $BorrowGlobal($t34, $AccountLimits_LimitsDefinition_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 6875);
      goto Abort;
    }
    assume $AccountLimits_LimitsDefinition_is_well_formed($Dereference($t13));

    // UnpackRef($t13)

    // limits_def := $t13
    call limits_def := $CopyOrMoveRef($t13);
    if (true) { assume $DebugTrackLocal(2, 6862, 5, $Dereference(limits_def)); }

    // $t15 := 0
    $tmp := $Integer(0);
    $t15 := $tmp;

    // $t16 := >($t35, $t15)
    call $tmp := $Gt($t35, $t15);
    $t16 := $tmp;

    // if ($t16) goto L2 else goto L3
    $tmp := $t16;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t18 := copy(limits_def)
    call $t18 := $CopyOrMoveRef(limits_def);

    // $t19 := borrow_field<AccountLimits::LimitsDefinition<#0>>.max_inflow($t18)
    call $t19 := $BorrowField($t18, $AccountLimits_LimitsDefinition_max_inflow);
    assume $IsValidU64($Dereference($t19));

    // Reference(limits_def) <- $t18
    call limits_def := $WritebackToReference($t18, limits_def);

    // UnpackRef($t19)

    // write_ref($t19, $t35)
    call $t19 := $WriteRef($t19, $t35);
    if (true) { assume $DebugTrackLocal(2, 6971, 5, $Dereference(limits_def)); }

    // Reference(limits_def) <- $t19
    call limits_def := $WritebackToReference($t19, limits_def);

    // Reference($t18) <- $t19
    call $t18 := $WritebackToReference($t19, $t18);

    // PackRef($t19)

    // goto L4
    goto L4;

    // L4:
L4:

    // $t21 := 0
    $tmp := $Integer(0);
    $t21 := $tmp;

    // $t22 := >($t36, $t21)
    call $tmp := $Gt($t36, $t21);
    $t22 := $tmp;

    // if ($t22) goto L5 else goto L6
    $tmp := $t22;
    if (b#$Boolean($tmp)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // goto L7
    goto L7;

    // L5:
L5:

    // $t24 := copy(limits_def)
    call $t24 := $CopyOrMoveRef(limits_def);

    // $t25 := borrow_field<AccountLimits::LimitsDefinition<#0>>.max_outflow($t24)
    call $t25 := $BorrowField($t24, $AccountLimits_LimitsDefinition_max_outflow);
    assume $IsValidU64($Dereference($t25));

    // Reference(limits_def) <- $t24
    call limits_def := $WritebackToReference($t24, limits_def);

    // UnpackRef($t25)

    // write_ref($t25, $t36)
    call $t25 := $WriteRef($t25, $t36);
    if (true) { assume $DebugTrackLocal(2, 7048, 5, $Dereference(limits_def)); }

    // Reference(limits_def) <- $t25
    call limits_def := $WritebackToReference($t25, limits_def);

    // Reference($t24) <- $t25
    call $t24 := $WritebackToReference($t25, $t24);

    // PackRef($t25)

    // goto L7
    goto L7;

    // L7:
L7:

    // $t27 := 0
    $tmp := $Integer(0);
    $t27 := $tmp;

    // $t28 := >($t37, $t27)
    call $tmp := $Gt($t37, $t27);
    $t28 := $tmp;

    // if ($t28) goto L8 else goto L9
    $tmp := $t28;
    if (b#$Boolean($tmp)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // goto L10
    goto L10;

    // L8:
L8:

    // $t30 := move(limits_def)
    call $t30 := $CopyOrMoveRef(limits_def);

    // $t31 := borrow_field<AccountLimits::LimitsDefinition<#0>>.max_holding($t30)
    call $t31 := $BorrowField($t30, $AccountLimits_LimitsDefinition_max_holding);
    assume $IsValidU64($Dereference($t31));

    // AccountLimits::LimitsDefinition <- $t30
    call $WritebackToGlobal($t30);

    // UnpackRef($t31)

    // write_ref($t31, $t37)
    call $t31 := $WriteRef($t31, $t37);
    if (true) { assume $DebugTrackLocal(2, 7135, 5, $Dereference(limits_def)); }

    // AccountLimits::LimitsDefinition <- $t31
    call $WritebackToGlobal($t31);

    // Reference($t30) <- $t31
    call $t30 := $WritebackToReference($t31, $t30);

    // PackRef($t30)

    // PackRef($t31)

    // goto L11
    goto L11;

    // L10:
L10:

    // $t32 := move(limits_def)
    call $t32 := $CopyOrMoveRef(limits_def);

    // destroy($t32)

    // AccountLimits::LimitsDefinition <- $t32
    call $WritebackToGlobal($t32);

    // PackRef($t32)

    // goto L11
    goto L11;

    // L11:
L11:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $AccountLimits_update_limits_definition($tv0: $TypeValue, tc_account: $Value, limit_address: $Value, new_max_inflow: $Value, new_max_outflow: $Value, new_max_holding_balance: $Value) returns ()
free requires is#$Address(tc_account);
free requires is#$Address(limit_address);
free requires $IsValidU64(new_max_inflow);
free requires $IsValidU64(new_max_outflow);
free requires $IsValidU64(new_max_holding_balance);
{
    call $AccountLimits_update_limits_definition_def($tv0, tc_account, limit_address, new_max_inflow, new_max_outflow, new_max_holding_balance);
}

procedure {:inline 1} $AccountLimits_update_withdrawal_limits_def($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Reference; // ReferenceType($AccountLimits_Window_type_value($tv0))
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t10: $Value; // $AccountLimits_Window_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(2, 4291, 0, amount); }
    if (true) { assume $DebugTrackLocal(2, 4291, 1, addr); }
    if (true) { assume $DebugTrackLocal(2, 4291, 2, _cap); }

    // bytecode translation starts here
    // $t7 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t7 := $tmp;

    // $t8 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;

    // $t9 := move(_cap)
    call $tmp := $CopyOrMoveValue(_cap);
    $t9 := $tmp;

    // $t5 := borrow_global<AccountLimits::Window<#0>>($t8)
    call $t5 := $BorrowGlobal($t8, $AccountLimits_Window_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 4528);
      goto Abort;
    }
    assume $AccountLimits_Window_is_well_formed($Dereference($t5));

    // UnpackRef($t5)

    // $t10 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $AccountLimits_Window_is_well_formed($tmp);
    $t10 := $tmp;

    // ($t6, $t10) := AccountLimits::can_withdraw<#0>($t7, $t10)
    call $t6, $t10 := $AccountLimits_can_withdraw($tv0, $t7, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(2, 9985);
      goto Abort;
    }
    assume is#$Boolean($t6);

    assume $AccountLimits_Window_is_well_formed($t10);


    // write_ref($t5, $t10)
    call $t5 := $WriteRef($t5, $t10);

    // AccountLimits::Window <- $t5
    call $WritebackToGlobal($t5);

    // PackRef($t5)

    // return $t6
    $ret0 := $t6;
    if (true) { assume $DebugTrackLocal(2, 4472, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $AccountLimits_update_withdrawal_limits($tv0: $TypeValue, amount: $Value, addr: $Value, _cap: $Value) returns ($ret0: $Value)
free requires $IsValidU64(amount);
free requires is#$Address(addr);
free requires $AccountLimits_CallingCapability_is_well_formed(_cap);
{
    call $ret0 := $AccountLimits_update_withdrawal_limits_def($tv0, amount, addr, _cap);
}



// ** spec vars of module DesignatedDealer



// ** spec funs of module DesignatedDealer



// ** structs of module DesignatedDealer

const unique $DesignatedDealer_Dealer: $TypeName;
const $DesignatedDealer_Dealer_window_start: $FieldName;
axiom $DesignatedDealer_Dealer_window_start == 0;
const $DesignatedDealer_Dealer_window_inflow: $FieldName;
axiom $DesignatedDealer_Dealer_window_inflow == 1;
const $DesignatedDealer_Dealer_tiers: $FieldName;
axiom $DesignatedDealer_Dealer_tiers == 2;
const $DesignatedDealer_Dealer_mint_event_handle: $FieldName;
axiom $DesignatedDealer_Dealer_mint_event_handle == 3;
function $DesignatedDealer_Dealer_type_value(): $TypeValue {
    $StructType($DesignatedDealer_Dealer, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $IntegerType()][2 := $Vector_type_value($IntegerType())][3 := $Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value())], 4))
}
function {:inline} $DesignatedDealer_Dealer_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $DesignatedDealer_Dealer_window_start))
      && $IsValidU64($SelectField($this, $DesignatedDealer_Dealer_window_inflow))
      && $Vector_is_well_formed($SelectField($this, $DesignatedDealer_Dealer_tiers)) && (forall $$0: int :: {$select_vector($SelectField($this, $DesignatedDealer_Dealer_tiers),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_Dealer_tiers)) ==> $IsValidU64($select_vector($SelectField($this, $DesignatedDealer_Dealer_tiers),$$0)))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $DesignatedDealer_Dealer_mint_event_handle))
}
function {:inline} $DesignatedDealer_Dealer_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $DesignatedDealer_Dealer_window_start))
      && $IsValidU64($SelectField($this, $DesignatedDealer_Dealer_window_inflow))
      && $Vector_is_well_formed($SelectField($this, $DesignatedDealer_Dealer_tiers)) && (forall $$0: int :: {$select_vector($SelectField($this, $DesignatedDealer_Dealer_tiers),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DesignatedDealer_Dealer_tiers)) ==> $IsValidU64($select_vector($SelectField($this, $DesignatedDealer_Dealer_tiers),$$0)))
      && $Event_EventHandle_is_well_formed($SelectField($this, $DesignatedDealer_Dealer_mint_event_handle))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $DesignatedDealer_Dealer_is_well_formed($ResourceValue(m, $DesignatedDealer_Dealer_type_value(), a))
);

procedure {:inline 1} $DesignatedDealer_Dealer_pack($file_id: int, $byte_index: int, $var_idx: int, window_start: $Value, window_inflow: $Value, tiers: $Value, mint_event_handle: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(window_start);
    assume $IsValidU64(window_inflow);
    assume $Vector_is_well_formed(tiers) && (forall $$0: int :: {$select_vector(tiers,$$0)} $$0 >= 0 && $$0 < $vlen(tiers) ==> $IsValidU64($select_vector(tiers,$$0)));
    assume $Event_EventHandle_is_well_formed(mint_event_handle);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := window_start][1 := window_inflow][2 := tiers][3 := mint_event_handle], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DesignatedDealer_Dealer_unpack($struct: $Value) returns (window_start: $Value, window_inflow: $Value, tiers: $Value, mint_event_handle: $Value)
{
    assume is#$Vector($struct);
    window_start := $SelectField($struct, $DesignatedDealer_Dealer_window_start);
    assume $IsValidU64(window_start);
    window_inflow := $SelectField($struct, $DesignatedDealer_Dealer_window_inflow);
    assume $IsValidU64(window_inflow);
    tiers := $SelectField($struct, $DesignatedDealer_Dealer_tiers);
    assume $Vector_is_well_formed(tiers) && (forall $$0: int :: {$select_vector(tiers,$$0)} $$0 >= 0 && $$0 < $vlen(tiers) ==> $IsValidU64($select_vector(tiers,$$0)));
    mint_event_handle := $SelectField($struct, $DesignatedDealer_Dealer_mint_event_handle);
    assume $Event_EventHandle_is_well_formed(mint_event_handle);
}

const unique $DesignatedDealer_ReceivedMintEvent: $TypeName;
const $DesignatedDealer_ReceivedMintEvent_destination_address: $FieldName;
axiom $DesignatedDealer_ReceivedMintEvent_destination_address == 0;
const $DesignatedDealer_ReceivedMintEvent_amount: $FieldName;
axiom $DesignatedDealer_ReceivedMintEvent_amount == 1;
function $DesignatedDealer_ReceivedMintEvent_type_value(): $TypeValue {
    $StructType($DesignatedDealer_ReceivedMintEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AddressType()][1 := $IntegerType()], 2))
}
function {:inline} $DesignatedDealer_ReceivedMintEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $DesignatedDealer_ReceivedMintEvent_destination_address))
      && $IsValidU64($SelectField($this, $DesignatedDealer_ReceivedMintEvent_amount))
}
function {:inline} $DesignatedDealer_ReceivedMintEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $DesignatedDealer_ReceivedMintEvent_destination_address))
      && $IsValidU64($SelectField($this, $DesignatedDealer_ReceivedMintEvent_amount))
}

procedure {:inline 1} $DesignatedDealer_ReceivedMintEvent_pack($file_id: int, $byte_index: int, $var_idx: int, destination_address: $Value, amount: $Value) returns ($struct: $Value)
{
    assume is#$Address(destination_address);
    assume $IsValidU64(amount);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := destination_address][1 := amount], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DesignatedDealer_ReceivedMintEvent_unpack($struct: $Value) returns (destination_address: $Value, amount: $Value)
{
    assume is#$Vector($struct);
    destination_address := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_destination_address);
    assume is#$Address(destination_address);
    amount := $SelectField($struct, $DesignatedDealer_ReceivedMintEvent_amount);
    assume $IsValidU64(amount);
}



// ** functions of module DesignatedDealer

procedure {:inline 1} $DesignatedDealer_exists_at_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 5647, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;

    // $t2 := exists<DesignatedDealer::Dealer>($t3)
    call $tmp := $Exists($t3, $DesignatedDealer_Dealer_type_value());
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(6, 5699, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_exists_at(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $DesignatedDealer_exists_at_def(addr);
}

procedure {:inline 1} $DesignatedDealer_reset_window_def(dealer: $Value) returns ($ret0: $Value){
    // declare local variables
    var current_time: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t12: $Reference; // ReferenceType($IntegerType())
    var $t13: $Value; // $IntegerType()
    var $t14: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t15: $Reference; // ReferenceType($IntegerType())
    var $t16: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t17: $Value; // $DesignatedDealer_Dealer_type_value()
    var $t18: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 5904, 0, dealer); }

    // bytecode translation starts here
    // $t17 := move(dealer)
    call $tmp := $CopyOrMoveValue(dealer);
    $t17 := $tmp;

    // $t18 := borrow_local($t17)
    call $t18 := $BorrowLoc(17, $t17);
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t18));

    // $t2 := LibraTimestamp::now_microseconds()
    call $t2 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5987);
      goto Abort;
    }
    assume $IsValidU64($t2);


    // current_time := $t2
    call $tmp := $CopyOrMoveValue($t2);
    current_time := $tmp;
    if (true) { assume $DebugTrackLocal(6, 5956, 1, $tmp); }

    // $t4 := copy($t18)
    call $t4 := $CopyOrMoveRef($t18);

    // $t5 := get_field<DesignatedDealer::Dealer>.window_start($t4)
    call $tmp := $GetFieldFromReference($t4, $DesignatedDealer_Dealer_window_start);
    assume $IsValidU64($tmp);
    $t5 := $tmp;

    // Reference($t18) <- $t4
    call $t18 := $WritebackToReference($t4, $t18);

    // $t6 := move($t5)
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;

    // $t7 := DesignatedDealer::window_length()
    call $t7 := $DesignatedDealer_window_length();
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 6186);
      goto Abort;
    }
    assume $IsValidU64($t7);


    // $t8 := +($t6, $t7)
    call $tmp := $AddU64($t6, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 6054);
      goto Abort;
    }
    $t8 := $tmp;

    // $t9 := >(current_time, $t8)
    call $tmp := $Gt(current_time, $t8);
    $t9 := $tmp;

    // if ($t9) goto L0 else goto L1
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t11 := copy($t18)
    call $t11 := $CopyOrMoveRef($t18);

    // $t12 := borrow_field<DesignatedDealer::Dealer>.window_start($t11)
    call $t12 := $BorrowField($t11, $DesignatedDealer_Dealer_window_start);
    assume $IsValidU64($Dereference($t12));

    // Reference($t18) <- $t11
    call $t18 := $WritebackToReference($t11, $t18);

    // UnpackRef($t12)

    // write_ref($t12, current_time)
    call $t12 := $WriteRef($t12, current_time);

    // Reference($t18) <- $t12
    call $t18 := $WritebackToReference($t12, $t18);

    // Reference($t11) <- $t12
    call $t11 := $WritebackToReference($t12, $t11);

    // PackRef($t12)

    // $t13 := 0
    $tmp := $Integer(0);
    $t13 := $tmp;

    // $t14 := move($t18)
    call $t14 := $CopyOrMoveRef($t18);

    // $t15 := borrow_field<DesignatedDealer::Dealer>.window_inflow($t14)
    call $t15 := $BorrowField($t14, $DesignatedDealer_Dealer_window_inflow);
    assume $IsValidU64($Dereference($t15));

    // LocalRoot($t17) <- $t14
    call $t17 := $WritebackToValue($t14, 17, $t17);

    // UnpackRef($t15)

    // write_ref($t15, $t13)
    call $t15 := $WriteRef($t15, $t13);

    // LocalRoot($t17) <- $t15
    call $t17 := $WritebackToValue($t15, 17, $t17);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // PackRef($t15)

    // goto L3
    goto L3;

    // L2:
L2:

    // $t16 := move($t18)
    call $t16 := $CopyOrMoveRef($t18);

    // destroy($t16)

    // LocalRoot($t17) <- $t16
    call $t17 := $WritebackToValue($t16, 17, $t17);

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t17
    $ret0 := $t17;
    if (true) { assume $DebugTrackLocal(6, 6015, 19, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_reset_window(dealer: $Value) returns ($ret0: $Value)
free requires $DesignatedDealer_Dealer_is_well_formed(dealer);
{
    call $ret0 := $DesignatedDealer_reset_window_def(dealer);
}

procedure {:inline 1} $DesignatedDealer_add_tier_def(tc_account: $Value, addr: $Value, tier_upperbound: $Value) returns (){
    // declare local variables
    var dealer: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t12: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $DesignatedDealer_Dealer_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 2520, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(6, 2520, 1, addr); }
    if (true) { assume $DebugTrackLocal(6, 2520, 2, tier_upperbound); }

    // bytecode translation starts here
    // $t14 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t14 := $tmp;

    // $t15 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t15 := $tmp;

    // $t16 := move(tier_upperbound)
    call $tmp := $CopyOrMoveValue(tier_upperbound);
    $t16 := $tmp;

    // $t6 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;

    // $t7 := Roles::has_treasury_compliance_role($t6)
    call $t7 := $Roles_has_treasury_compliance_role($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2668);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t4 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2654, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(6, 2654); }
    goto Abort;

    // L0:
L0:

    // $t11 := borrow_global<DesignatedDealer::Dealer>($t15)
    call $t11 := $BorrowGlobal($t15, $DesignatedDealer_Dealer_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2766);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t11));

    // UnpackRef($t11)

    // dealer := $t11
    call dealer := $CopyOrMoveRef($t11);
    if (true) { assume $DebugTrackLocal(6, 2757, 3, $Dereference(dealer)); }

    // $t12 := move(dealer)
    call $t12 := $CopyOrMoveRef(dealer);

    // $t17 := read_ref($t12)
    call $tmp := $ReadRef($t12);
    assume $DesignatedDealer_Dealer_is_well_formed($tmp);
    $t17 := $tmp;

    // $t17 := DesignatedDealer::add_tier_($t17, $t16)
    call $t17 := $DesignatedDealer_add_tier_($t17, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2040);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($t17);


    // write_ref($t12, $t17)
    call $t12 := $WriteRef($t12, $t17);
    if (true) { assume $DebugTrackLocal(6, 2520, 3, $Dereference(dealer)); }

    // DesignatedDealer::Dealer <- $t12
    call $WritebackToGlobal($t12);

    // PackRef($t12)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DesignatedDealer_add_tier(tc_account: $Value, addr: $Value, tier_upperbound: $Value) returns ()
free requires is#$Address(tc_account);
free requires is#$Address(addr);
free requires $IsValidU64(tier_upperbound);
{
    call $DesignatedDealer_add_tier_def(tc_account, addr, tier_upperbound);
}

procedure {:inline 1} $DesignatedDealer_add_tier__def(dealer: $Value, next_tier_upperbound: $Value) returns ($ret0: $Value){
    // declare local variables
    var number_of_tiers: $Value; // $IntegerType()
    var prev_tier: $Value; // $IntegerType()
    var tiers: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t12: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t13: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t14: $Value; // $Vector_type_value($IntegerType())
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t30: $Value; // $Vector_type_value($IntegerType())
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $BooleanType()
    var $t37: $Value; // $BooleanType()
    var $t38: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t39: $Value; // $IntegerType()
    var $t40: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $DesignatedDealer_Dealer_type_value()
    var $t43: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 2036, 0, dealer); }
    if (true) { assume $DebugTrackLocal(6, 2036, 1, next_tier_upperbound); }

    // bytecode translation starts here
    // $t42 := move(dealer)
    call $tmp := $CopyOrMoveValue(dealer);
    $t42 := $tmp;

    // $t44 := move(next_tier_upperbound)
    call $tmp := $CopyOrMoveValue(next_tier_upperbound);
    $t44 := $tmp;

    // $t43 := borrow_local($t42)
    call $t43 := $BorrowLoc(42, $t42);
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t43));

    // $t11 := move($t43)
    call $t11 := $CopyOrMoveRef($t43);

    // $t12 := borrow_field<DesignatedDealer::Dealer>.tiers($t11)
    call $t12 := $BorrowField($t11, $DesignatedDealer_Dealer_tiers);
    assume $Vector_is_well_formed($Dereference($t12)) && (forall $$1: int :: {$select_vector($Dereference($t12),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t12)) ==> $IsValidU64($select_vector($Dereference($t12),$$1)));

    // LocalRoot($t42) <- $t11
    call $t42 := $WritebackToValue($t11, 42, $t42);

    // UnpackRef($t12)

    // tiers := $t12
    call tiers := $CopyOrMoveRef($t12);
    if (true) { assume $DebugTrackLocal(6, 2112, 4, $Dereference(tiers)); }

    // $t13 := copy(tiers)
    call $t13 := $CopyOrMoveRef(tiers);

    // $t14 := read_ref($t13)
    call $tmp := $ReadRef($t13);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t14 := $tmp;

    // Reference(tiers) <- $t13
    call tiers := $WritebackToReference($t13, tiers);

    // $t15 := Vector::length<u64>($t14)
    call $t15 := $Vector_length($IntegerType(), $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2182);
      goto Abort;
    }
    assume $IsValidU64($t15);


    // number_of_tiers := $t15
    call $tmp := $CopyOrMoveValue($t15);
    number_of_tiers := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2151, 2, $tmp); }

    // $t17 := 4
    $tmp := $Integer(4);
    $t17 := $tmp;

    // $t18 := <=(number_of_tiers, $t17)
    call $tmp := $Le(number_of_tiers, $t17);
    $t18 := $tmp;

    // $t5 := $t18
    call $tmp := $CopyOrMoveValue($t18);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2205, 5, $tmp); }

    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t20 := move(tiers)
    call $t20 := $CopyOrMoveRef(tiers);

    // destroy($t20)

    // LocalRoot($t42) <- $t20
    call $t42 := $WritebackToValue($t20, 42, $t42);

    // Reference($t11) <- $t20
    call $t11 := $WritebackToReference($t20, $t11);

    // PackRef($t20)

    // $t21 := 1
    $tmp := $Integer(1);
    $t21 := $tmp;

    // abort($t21)
    if (true) { assume $DebugTrackAbort(6, 2205); }
    goto Abort;

    // L0:
L0:

    // $t23 := 1
    $tmp := $Integer(1);
    $t23 := $tmp;

    // $t24 := >(number_of_tiers, $t23)
    call $tmp := $Gt(number_of_tiers, $t23);
    $t24 := $tmp;

    // if ($t24) goto L2 else goto L3
    $tmp := $t24;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t25 := copy(tiers)
    call $t25 := $CopyOrMoveRef(tiers);

    // $t27 := 1
    $tmp := $Integer(1);
    $t27 := $tmp;

    // $t28 := -(number_of_tiers, $t27)
    call $tmp := $Sub(number_of_tiers, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2361);
      goto Abort;
    }
    $t28 := $tmp;

    // $t8 := $t28
    call $tmp := $CopyOrMoveValue($t28);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2337, 8, $tmp); }

    // $t7 := $t25
    call $t7 := $CopyOrMoveRef($t25);
    if (true) { assume $DebugTrackLocal(6, 2337, 7, $Dereference($t7)); }

    // $t29 := move($t7)
    call $t29 := $CopyOrMoveRef($t7);

    // $t30 := read_ref($t29)
    call $tmp := $ReadRef($t29);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t30 := $tmp;

    // Reference(tiers) <- $t29
    call tiers := $WritebackToReference($t29, tiers);

    // $t32 := Vector::borrow<u64>($t30, $t8)
    call $t32 := $Vector_borrow($IntegerType(), $t30, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2331);
      goto Abort;
    }
    assume $IsValidU64($t32);


    // $t33 := move($t32)
    call $tmp := $CopyOrMoveValue($t32);
    $t33 := $tmp;

    // prev_tier := $t33
    call $tmp := $CopyOrMoveValue($t33);
    prev_tier := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2310, 3, $tmp); }

    // $t36 := <(prev_tier, $t44)
    call $tmp := $Lt(prev_tier, $t44);
    $t36 := $tmp;

    // $t9 := $t36
    call $tmp := $CopyOrMoveValue($t36);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2379, 9, $tmp); }

    // if ($t9) goto L4 else goto L5
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t38 := move(tiers)
    call $t38 := $CopyOrMoveRef(tiers);

    // destroy($t38)

    // LocalRoot($t42) <- $t38
    call $t42 := $WritebackToValue($t38, 42, $t42);

    // Reference($t11) <- $t38
    call $t11 := $WritebackToReference($t38, $t11);

    // PackRef($t38)

    // $t39 := 2
    $tmp := $Integer(2);
    $t39 := $tmp;

    // abort($t39)
    if (true) { assume $DebugTrackAbort(6, 2379); }
    goto Abort;

    // L4:
L4:

    // $t40 := move(tiers)
    call $t40 := $CopyOrMoveRef(tiers);

    // PackRef($t40)

    // $t45 := read_ref($t40)
    call $tmp := $ReadRef($t40);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t45 := $tmp;

    // $t45 := Vector::push_back<u64>($t45, $t44)
    call $t45 := $Vector_push_back($IntegerType(), $t45, $t44);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2469);
      goto Abort;
    }
    assume $Vector_is_well_formed($t45) && (forall $$0: int :: {$select_vector($t45,$$0)} $$0 >= 0 && $$0 < $vlen($t45) ==> $IsValidU64($select_vector($t45,$$0)));


    // write_ref($t40, $t45)
    call $t40 := $WriteRef($t40, $t45);
    if (true) { assume $DebugTrackLocal(6, 2479, 4, $Dereference(tiers)); }

    // LocalRoot($t42) <- $t40
    call $t42 := $WritebackToValue($t40, 42, $t42);

    // Reference($t11) <- $t40
    call $t11 := $WritebackToReference($t40, $t11);

    // UnpackRef($t40)

    // PackRef($t40)

    // return $t42
    $ret0 := $t42;
    if (true) { assume $DebugTrackLocal(6, 2507, 46, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_add_tier_(dealer: $Value, next_tier_upperbound: $Value) returns ($ret0: $Value)
free requires $DesignatedDealer_Dealer_is_well_formed(dealer);
free requires $IsValidU64(next_tier_upperbound);
{
    call $ret0 := $DesignatedDealer_add_tier__def(dealer, next_tier_upperbound);
}

procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential_def(dd: $Value, tc_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value())
    var $t15: $Value; // $DesignatedDealer_Dealer_type_value()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 1295, 0, dd); }
    if (true) { assume $DebugTrackLocal(6, 1295, 1, tc_account); }

    // bytecode translation starts here
    // $t16 := move(dd)
    call $tmp := $CopyOrMoveValue(dd);
    $t16 := $tmp;

    // $t17 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t17 := $tmp;

    // $t4 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t4 := $tmp;

    // $t5 := Roles::has_treasury_compliance_role($t4)
    call $t5 := $Roles_has_treasury_compliance_role($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 1424);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // $t2 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 1410, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;

    // destroy($t7)

    // $t8 := 0
    $tmp := $Integer(0);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(6, 1410); }
    goto Abort;

    // L0:
L0:

    // $t9 := copy($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;

    // $t10 := LibraTimestamp::now_microseconds()
    call $t10 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 1601);
      goto Abort;
    }
    assume $IsValidU64($t10);


    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // $t12 := Vector::empty<u64>()
    call $t12 := $Vector_empty($IntegerType());
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 1686);
      goto Abort;
    }
    assume $Vector_is_well_formed($t12) && (forall $$0: int :: {$select_vector($t12,$$0)} $$0 >= 0 && $$0 < $vlen($t12) ==> $IsValidU64($select_vector($t12,$$0)));


    // $t13 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t13 := $tmp;

    // $t14 := Event::new_event_handle<DesignatedDealer::ReceivedMintEvent>($t13)
    call $t14 := $Event_new_event_handle($DesignatedDealer_ReceivedMintEvent_type_value(), $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 1737);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t14);


    // $t15 := pack DesignatedDealer::Dealer($t10, $t11, $t12, $t14)
    call $tmp := $DesignatedDealer_Dealer_pack(0, 0, 0, $t10, $t11, $t12, $t14);
    $t15 := $tmp;

    // move_to<DesignatedDealer::Dealer>($t15, $t9)
    call $MoveTo($DesignatedDealer_Dealer_type_value(), $t15, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 1509);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DesignatedDealer_publish_designated_dealer_credential(dd: $Value, tc_account: $Value) returns ()
free requires is#$Address(dd);
free requires is#$Address(tc_account);
{
    call $DesignatedDealer_publish_designated_dealer_credential_def(dd, tc_account);
}

procedure {:inline 1} $DesignatedDealer_tiered_mint_def($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value){
    // declare local variables
    var tier_check: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $AddressType()
    var $t30: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $BooleanType()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $AddressType()
    var $t39: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t40: $Reference; // ReferenceType($Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value()))
    var $t41: $Value; // $AddressType()
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $DesignatedDealer_ReceivedMintEvent_type_value()
    var $t44: $Value; // $AddressType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $Libra_Libra_type_value($tv0)
    var $t47: $Value; // $AddressType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Value; // $AddressType()
    var $t50: $Value; // $IntegerType()
    var $t51: $Value; // $Event_EventHandle_type_value($DesignatedDealer_ReceivedMintEvent_type_value())
    var $t52: $Value; // $DesignatedDealer_Dealer_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 4776, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(6, 4776, 1, amount); }
    if (true) { assume $DebugTrackLocal(6, 4776, 2, dd_addr); }
    if (true) { assume $DebugTrackLocal(6, 4776, 3, tier_index); }

    // bytecode translation starts here
    // $t47 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t47 := $tmp;

    // $t48 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t48 := $tmp;

    // $t49 := move(dd_addr)
    call $tmp := $CopyOrMoveValue(dd_addr);
    $t49 := $tmp;

    // $t50 := move(tier_index)
    call $tmp := $CopyOrMoveValue(tier_index);
    $t50 := $tmp;

    // $t13 := copy($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t13 := $tmp;

    // $t14 := Roles::has_treasury_compliance_role($t13)
    call $t14 := $Roles_has_treasury_compliance_role($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4975);
      goto Abort;
    }
    assume is#$Boolean($t14);


    // $t5 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4961, 5, $tmp); }

    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t16 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t16 := $tmp;

    // destroy($t16)

    // $t17 := 0
    $tmp := $Integer(0);
    $t17 := $tmp;

    // abort($t17)
    if (true) { assume $DebugTrackAbort(6, 4961); }
    goto Abort;

    // L0:
L0:

    // $t19 := 0
    $tmp := $Integer(0);
    $t19 := $tmp;

    // $t20 := >($t48, $t19)
    call $tmp := $Gt($t48, $t19);
    $t20 := $tmp;

    // $t7 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 5060, 7, $tmp); }

    // if ($t7) goto L2 else goto L3
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t22 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t22 := $tmp;

    // destroy($t22)

    // $t23 := 4
    $tmp := $Integer(4);
    $t23 := $tmp;

    // abort($t23)
    if (true) { assume $DebugTrackAbort(6, 5060); }
    goto Abort;

    // L2:
L2:

    // $t25 := DesignatedDealer::exists_at($t49)
    call $t25 := $DesignatedDealer_exists_at($t49);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5658);
      goto Abort;
    }
    assume is#$Boolean($t25);


    // $t9 := $t25
    call $tmp := $CopyOrMoveValue($t25);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 5111, 9, $tmp); }

    // if ($t9) goto L4 else goto L5
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t27 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t27 := $tmp;

    // destroy($t27)

    // $t28 := 5
    $tmp := $Integer(5);
    $t28 := $tmp;

    // abort($t28)
    if (true) { assume $DebugTrackAbort(6, 5111); }
    goto Abort;

    // L4:
L4:

    // $t30 := borrow_global<DesignatedDealer::Dealer>($t49)
    call $t30 := $BorrowGlobal($t49, $DesignatedDealer_Dealer_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5188);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t30));

    // UnpackRef($t30)

    // $t52 := read_ref($t30)
    call $tmp := $ReadRef($t30);
    assume $DesignatedDealer_Dealer_is_well_formed($tmp);
    $t52 := $tmp;

    // ($t33, $t52) := DesignatedDealer::tiered_mint_($t52, $t48, $t50)
    call $t33, $t52 := $DesignatedDealer_tiered_mint_($t52, $t48, $t50);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3944);
      goto Abort;
    }
    assume is#$Boolean($t33);

    assume $DesignatedDealer_Dealer_is_well_formed($t52);


    // write_ref($t30, $t52)
    call $t30 := $WriteRef($t30, $t52);

    // DesignatedDealer::Dealer <- $t30
    call $WritebackToGlobal($t30);

    // PackRef($t30)

    // tier_check := $t33
    call $tmp := $CopyOrMoveValue($t33);
    tier_check := $tmp;
    if (true) { assume $DebugTrackLocal(6, 5162, 4, $tmp); }

    // $t11 := tier_check
    call $tmp := $CopyOrMoveValue(tier_check);
    $t11 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 5253, 11, $tmp); }

    // if ($t11) goto L6 else goto L7
    $tmp := $t11;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // $t36 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t36 := $tmp;

    // destroy($t36)

    // $t37 := 6
    $tmp := $Integer(6);
    $t37 := $tmp;

    // abort($t37)
    if (true) { assume $DebugTrackAbort(6, 5253); }
    goto Abort;

    // L6:
L6:

    // $t39 := borrow_global<DesignatedDealer::Dealer>($t49)
    call $t39 := $BorrowGlobal($t49, $DesignatedDealer_Dealer_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5396);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t39));

    // UnpackRef($t39)

    // $t40 := borrow_field<DesignatedDealer::Dealer>.mint_event_handle($t39)
    call $t40 := $BorrowField($t39, $DesignatedDealer_Dealer_mint_event_handle);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t40));

    // DesignatedDealer::Dealer <- $t39
    call $WritebackToGlobal($t39);

    // UnpackRef($t40)

    // $t43 := pack DesignatedDealer::ReceivedMintEvent($t49, $t48)
    call $tmp := $DesignatedDealer_ReceivedMintEvent_pack(0, 0, 0, $t49, $t48);
    $t43 := $tmp;

    // PackRef($t40)

    // $t51 := read_ref($t40)
    call $tmp := $ReadRef($t40);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t51 := $tmp;

    // $t51 := Event::emit_event<DesignatedDealer::ReceivedMintEvent>($t51, $t43)
    call $t51 := $Event_emit_event($DesignatedDealer_ReceivedMintEvent_type_value(), $t51, $t43);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5348);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t51);


    // write_ref($t40, $t51)
    call $t40 := $WriteRef($t40, $t51);

    // DesignatedDealer::Dealer <- $t40
    call $WritebackToGlobal($t40);

    // Reference($t39) <- $t40
    call $t39 := $WritebackToReference($t40, $t39);

    // UnpackRef($t40)

    // PackRef($t39)

    // PackRef($t40)

    // $t44 := move($t47)
    call $tmp := $CopyOrMoveValue($t47);
    $t44 := $tmp;

    // $t46 := Libra::mint<#0>($t44, $t48)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t46 := $Libra_mint($tv0, $t44, $t48);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5601);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t46);


    // return $t46
    $ret0 := $t46;
    if (true) { assume $DebugTrackLocal(6, 5594, 53, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_tiered_mint($tv0: $TypeValue, tc_account: $Value, amount: $Value, dd_addr: $Value, tier_index: $Value) returns ($ret0: $Value)
free requires is#$Address(tc_account);
free requires $IsValidU64(amount);
free requires is#$Address(dd_addr);
free requires $IsValidU64(tier_index);
{
    call $ret0 := $DesignatedDealer_tiered_mint_def($tv0, tc_account, amount, dd_addr, tier_index);
}

procedure {:inline 1} $DesignatedDealer_tiered_mint__def(dealer: $Value, amount: $Value, tier_index: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var cur_inflow: $Value; // $IntegerType()
    var number_of_tiers: $Value; // $IntegerType()
    var tier_check: $Reference; // ReferenceType($BooleanType())
    var tier_upperbound: $Value; // $IntegerType()
    var tiers: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t18: $Value; // $IntegerType()
    var $t19: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t20: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t24: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t25: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t26: $Value; // $Vector_type_value($IntegerType())
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Reference; // ReferenceType($BooleanType())
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $BooleanType()
    var $t33: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t34: $Value; // $BooleanType()
    var $t35: $Reference; // ReferenceType($BooleanType())
    var $t36: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t37: $Value; // $IntegerType()
    var $t38: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t39: $Value; // $Vector_type_value($IntegerType())
    var $t40: $Value; // $IntegerType()
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $IntegerType()
    var $t47: $Value; // $BooleanType()
    var $t48: $Reference; // ReferenceType($BooleanType())
    var $t49: $Reference; // ReferenceType($BooleanType())
    var $t50: $Value; // $BooleanType()
    var $t51: $Value; // $IntegerType()
    var $t52: $Value; // $IntegerType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t55: $Reference; // ReferenceType($IntegerType())
    var $t56: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t57: $Reference; // ReferenceType($BooleanType())
    var $t58: $Value; // $BooleanType()
    var $t59: $Value; // $DesignatedDealer_Dealer_type_value()
    var $t60: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t61: $Value; // $IntegerType()
    var $t62: $Value; // $IntegerType()
    var $t63: $Value; // $DesignatedDealer_Dealer_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 3940, 0, dealer); }
    if (true) { assume $DebugTrackLocal(6, 3940, 1, amount); }
    if (true) { assume $DebugTrackLocal(6, 3940, 2, tier_index); }

    // bytecode translation starts here
    // $t59 := move(dealer)
    call $tmp := $CopyOrMoveValue(dealer);
    $t59 := $tmp;

    // $t61 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t61 := $tmp;

    // $t62 := move(tier_index)
    call $tmp := $CopyOrMoveValue(tier_index);
    $t62 := $tmp;

    // $t60 := borrow_local($t59)
    call $t60 := $BorrowLoc(59, $t59);
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t60));

    // $t14 := 4
    $tmp := $Integer(4);
    $t14 := $tmp;

    // $t15 := <=($t62, $t14)
    call $tmp := $Le($t62, $t14);
    $t15 := $tmp;

    // $t8 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4068, 8, $tmp); }

    // if ($t8) goto L0 else goto L1
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t17 := move($t60)
    call $t17 := $CopyOrMoveRef($t60);

    // destroy($t17)

    // LocalRoot($t59) <- $t17
    call $t59 := $WritebackToValue($t17, 59, $t59);

    // $t18 := 3
    $tmp := $Integer(3);
    $t18 := $tmp;

    // abort($t18)
    if (true) { assume $DebugTrackAbort(6, 4068); }
    goto Abort;

    // L0:
L0:

    // $t19 := copy($t60)
    call $t19 := $CopyOrMoveRef($t60);

    // $t63 := read_ref($t19)
    call $tmp := $ReadRef($t19);
    assume $DesignatedDealer_Dealer_is_well_formed($tmp);
    $t63 := $tmp;

    // $t63 := DesignatedDealer::reset_window($t63)
    call $t63 := $DesignatedDealer_reset_window($t63);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 5908);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($t63);


    // write_ref($t19, $t63)
    call $t19 := $WriteRef($t19, $t63);
    if (true) { assume $DebugTrackLocal(6, 4754, 5, $Dereference(tier_check)); }
    if (true) { assume $DebugTrackLocal(6, 4754, 7, $Dereference(tiers)); }
    if (true) { assume $DebugTrackLocal(6, 4754, 11, $Dereference($t11)); }

    // Reference($t60) <- $t19
    call $t60 := $WritebackToReference($t19, $t60);

    // $t20 := copy($t60)
    call $t20 := $CopyOrMoveRef($t60);

    // $t21 := get_field<DesignatedDealer::Dealer>.window_inflow($t20)
    call $tmp := $GetFieldFromReference($t20, $DesignatedDealer_Dealer_window_inflow);
    assume $IsValidU64($tmp);
    $t21 := $tmp;

    // Reference($t60) <- $t20
    call $t60 := $WritebackToReference($t20, $t60);

    // $t22 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t22 := $tmp;

    // cur_inflow := $t22
    call $tmp := $CopyOrMoveValue($t22);
    cur_inflow := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4156, 3, $tmp); }

    // $t23 := copy($t60)
    call $t23 := $CopyOrMoveRef($t60);

    // $t24 := borrow_field<DesignatedDealer::Dealer>.tiers($t23)
    call $t24 := $BorrowField($t23, $DesignatedDealer_Dealer_tiers);
    assume $Vector_is_well_formed($Dereference($t24)) && (forall $$1: int :: {$select_vector($Dereference($t24),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t24)) ==> $IsValidU64($select_vector($Dereference($t24),$$1)));

    // Reference($t60) <- $t23
    call $t60 := $WritebackToReference($t23, $t60);

    // UnpackRef($t24)

    // tiers := $t24
    call tiers := $CopyOrMoveRef($t24);
    if (true) { assume $DebugTrackLocal(6, 4205, 7, $Dereference(tiers)); }

    // $t25 := copy(tiers)
    call $t25 := $CopyOrMoveRef(tiers);

    // $t26 := read_ref($t25)
    call $tmp := $ReadRef($t25);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t26 := $tmp;

    // Reference(tiers) <- $t25
    call tiers := $WritebackToReference($t25, tiers);

    // $t27 := Vector::length<u64>($t26)
    call $t27 := $Vector_length($IntegerType(), $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4351);
      goto Abort;
    }
    assume $IsValidU64($t27);


    // number_of_tiers := $t27
    call $tmp := $CopyOrMoveValue($t27);
    number_of_tiers := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4325, 4, $tmp); }

    // $t28 := false
    $tmp := $Boolean(false);
    $t28 := $tmp;

    // $t10 := $t28
    call $tmp := $CopyOrMoveValue($t28);
    $t10 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4396, 10, $tmp); }

    // $t29 := borrow_local($t10)
    call $t29 := $BorrowLoc(10, $t10);
    assume is#$Boolean($Dereference($t29));

    // UnpackRef($t29)

    // tier_check := $t29
    call tier_check := $CopyOrMoveRef($t29);
    if (true) { assume $DebugTrackLocal(6, 4378, 5, $Dereference(tier_check)); }

    // $t32 := ==($t62, number_of_tiers)
    $tmp := $Boolean($IsEqual($t62, number_of_tiers));
    $t32 := $tmp;

    // if ($t32) goto L2 else goto L3
    $tmp := $t32;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t33 := move(tiers)
    call $t33 := $CopyOrMoveRef(tiers);

    // destroy($t33)

    // Reference($t60) <- $t33
    call $t60 := $WritebackToReference($t33, $t60);

    // Reference($t23) <- $t33
    call $t23 := $WritebackToReference($t33, $t23);

    // PackRef($t33)

    // $t34 := true
    $tmp := $Boolean(true);
    $t34 := $tmp;

    // $t35 := copy(tier_check)
    call $t35 := $CopyOrMoveRef(tier_check);

    // write_ref($t35, $t34)
    call $t35 := $WriteRef($t35, $t34);
    if (true) { assume $DebugTrackLocal(6, 4460, 5, $Dereference(tier_check)); }
    if (true) { assume $DebugTrackLocal(6, 4460, 7, $Dereference(tiers)); }
    if (true) { assume $DebugTrackLocal(6, 4460, 11, $Dereference($t11)); }

    // Reference(tier_check) <- $t35
    call tier_check := $WritebackToReference($t35, tier_check);

    // goto L5
    goto L5;

    // L4:
L4:

    // $t36 := move(tiers)
    call $t36 := $CopyOrMoveRef(tiers);

    // $t12 := $t62
    call $tmp := $CopyOrMoveValue($t62);
    $t12 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4551, 12, $tmp); }

    // $t11 := $t36
    call $t11 := $CopyOrMoveRef($t36);
    if (true) { assume $DebugTrackLocal(6, 4551, 11, $Dereference($t11)); }

    // $t38 := move($t11)
    call $t38 := $CopyOrMoveRef($t11);

    // $t39 := read_ref($t38)
    call $tmp := $ReadRef($t38);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t39 := $tmp;

    // Reference($t60) <- $t38
    call $t60 := $WritebackToReference($t38, $t60);

    // Reference($t23) <- $t38
    call $t23 := $WritebackToReference($t38, $t23);

    // PackRef($t38)

    // $t41 := Vector::borrow<u64>($t39, $t12)
    call $t41 := $Vector_borrow($IntegerType(), $t39, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4545);
      goto Abort;
    }
    assume $IsValidU64($t41);


    // $t42 := move($t41)
    call $tmp := $CopyOrMoveValue($t41);
    $t42 := $tmp;

    // tier_upperbound := $t42
    call $tmp := $CopyOrMoveValue($t42);
    tier_upperbound := $tmp;
    if (true) { assume $DebugTrackLocal(6, 4513, 6, $tmp); }

    // $t45 := +(cur_inflow, $t61)
    call $tmp := $AddU64(cur_inflow, $t61);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4610);
      goto Abort;
    }
    $t45 := $tmp;

    // $t47 := <=($t45, tier_upperbound)
    call $tmp := $Le($t45, tier_upperbound);
    $t47 := $tmp;

    // $t48 := copy(tier_check)
    call $t48 := $CopyOrMoveRef(tier_check);

    // write_ref($t48, $t47)
    call $t48 := $WriteRef($t48, $t47);
    if (true) { assume $DebugTrackLocal(6, 4584, 5, $Dereference(tier_check)); }
    if (true) { assume $DebugTrackLocal(6, 4584, 7, $Dereference(tiers)); }
    if (true) { assume $DebugTrackLocal(6, 4584, 11, $Dereference($t11)); }

    // Reference(tier_check) <- $t48
    call tier_check := $WritebackToReference($t48, tier_check);

    // goto L5
    goto L5;

    // L5:
L5:

    // $t49 := copy(tier_check)
    call $t49 := $CopyOrMoveRef(tier_check);

    // $t50 := read_ref($t49)
    call $tmp := $ReadRef($t49);
    assume is#$Boolean($tmp);
    $t50 := $tmp;

    // Reference(tier_check) <- $t49
    call tier_check := $WritebackToReference($t49, tier_check);

    // if ($t50) goto L6 else goto L7
    $tmp := $t50;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t53 := +(cur_inflow, $t61)
    call $tmp := $AddU64(cur_inflow, $t61);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 4724);
      goto Abort;
    }
    $t53 := $tmp;

    // $t54 := move($t60)
    call $t54 := $CopyOrMoveRef($t60);

    // $t55 := borrow_field<DesignatedDealer::Dealer>.window_inflow($t54)
    call $t55 := $BorrowField($t54, $DesignatedDealer_Dealer_window_inflow);
    assume $IsValidU64($Dereference($t55));

    // LocalRoot($t59) <- $t54
    call $t59 := $WritebackToValue($t54, 59, $t59);

    // UnpackRef($t55)

    // write_ref($t55, $t53)
    call $t55 := $WriteRef($t55, $t53);
    if (true) { assume $DebugTrackLocal(6, 4690, 5, $Dereference(tier_check)); }
    if (true) { assume $DebugTrackLocal(6, 4690, 7, $Dereference(tiers)); }
    if (true) { assume $DebugTrackLocal(6, 4690, 11, $Dereference($t11)); }

    // LocalRoot($t59) <- $t55
    call $t59 := $WritebackToValue($t55, 59, $t59);

    // Reference($t54) <- $t55
    call $t54 := $WritebackToReference($t55, $t54);

    // PackRef($t55)

    // goto L9
    goto L9;

    // L8:
L8:

    // $t56 := move($t60)
    call $t56 := $CopyOrMoveRef($t60);

    // destroy($t56)

    // LocalRoot($t59) <- $t56
    call $t59 := $WritebackToValue($t56, 59, $t59);

    // goto L9
    goto L9;

    // L9:
L9:

    // $t57 := move(tier_check)
    call $t57 := $CopyOrMoveRef(tier_check);

    // $t58 := read_ref($t57)
    call $tmp := $ReadRef($t57);
    assume is#$Boolean($tmp);
    $t58 := $tmp;

    // LocalRoot($t10) <- $t57
    call $t10 := $WritebackToValue($t57, 10, $t10);

    // PackRef($t57)

    // return ($t58, $t59)
    $ret0 := $t58;
    if (true) { assume $DebugTrackLocal(6, 4753, 64, $ret0); }
    $ret1 := $t59;
    if (true) { assume $DebugTrackLocal(6, 4753, 65, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_tiered_mint_(dealer: $Value, amount: $Value, tier_index: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $DesignatedDealer_Dealer_is_well_formed(dealer);
free requires $IsValidU64(amount);
free requires $IsValidU64(tier_index);
{
    call $ret0, $ret1 := $DesignatedDealer_tiered_mint__def(dealer, amount, tier_index);
}

procedure {:inline 1} $DesignatedDealer_update_tier_def(tc_account: $Value, addr: $Value, tier_index: $Value, new_upperbound: $Value) returns (){
    // declare local variables
    var dealer: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t13: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $DesignatedDealer_Dealer_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 3566, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(6, 3566, 1, addr); }
    if (true) { assume $DebugTrackLocal(6, 3566, 2, tier_index); }
    if (true) { assume $DebugTrackLocal(6, 3566, 3, new_upperbound); }

    // bytecode translation starts here
    // $t16 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t16 := $tmp;

    // $t17 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t17 := $tmp;

    // $t18 := move(tier_index)
    call $tmp := $CopyOrMoveValue(tier_index);
    $t18 := $tmp;

    // $t19 := move(new_upperbound)
    call $tmp := $CopyOrMoveValue(new_upperbound);
    $t19 := $tmp;

    // $t7 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;

    // $t8 := Roles::has_treasury_compliance_role($t7)
    call $t8 := $Roles_has_treasury_compliance_role($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3741);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t5 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 3727, 5, $tmp); }

    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := 0
    $tmp := $Integer(0);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(6, 3727); }
    goto Abort;

    // L0:
L0:

    // $t12 := borrow_global<DesignatedDealer::Dealer>($t17)
    call $t12 := $BorrowGlobal($t17, $DesignatedDealer_Dealer_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3839);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t12));

    // UnpackRef($t12)

    // dealer := $t12
    call dealer := $CopyOrMoveRef($t12);
    if (true) { assume $DebugTrackLocal(6, 3830, 4, $Dereference(dealer)); }

    // $t13 := move(dealer)
    call $t13 := $CopyOrMoveRef(dealer);

    // $t20 := read_ref($t13)
    call $tmp := $ReadRef($t13);
    assume $DesignatedDealer_Dealer_is_well_formed($tmp);
    $t20 := $tmp;

    // $t20 := DesignatedDealer::update_tier_($t20, $t18, $t19)
    call $t20 := $DesignatedDealer_update_tier_($t20, $t18, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 2857);
      goto Abort;
    }
    assume $DesignatedDealer_Dealer_is_well_formed($t20);


    // write_ref($t13, $t20)
    call $t13 := $WriteRef($t13, $t20);
    if (true) { assume $DebugTrackLocal(6, 3566, 4, $Dereference(dealer)); }

    // DesignatedDealer::Dealer <- $t13
    call $WritebackToGlobal($t13);

    // PackRef($t13)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DesignatedDealer_update_tier(tc_account: $Value, addr: $Value, tier_index: $Value, new_upperbound: $Value) returns ()
free requires is#$Address(tc_account);
free requires is#$Address(addr);
free requires $IsValidU64(tier_index);
free requires $IsValidU64(new_upperbound);
{
    call $DesignatedDealer_update_tier_def(tc_account, addr, tier_index, new_upperbound);
}

procedure {:inline 1} $DesignatedDealer_update_tier__def(dealer: $Value, tier_index: $Value, new_upperbound: $Value) returns ($ret0: $Value){
    // declare local variables
    var next_tier: $Value; // $IntegerType()
    var number_of_tiers: $Value; // $IntegerType()
    var tier_mut: $Reference; // ReferenceType($IntegerType())
    var tiers: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t14: $Value; // $IntegerType()
    var $t15: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t16: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t17: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $BooleanType()
    var $t38: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t39: $Value; // $IntegerType()
    var $t40: $Value; // $IntegerType()
    var $t41: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t42: $Value; // $Vector_type_value($IntegerType())
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $BooleanType()
    var $t47: $Value; // $BooleanType()
    var $t48: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t49: $Value; // $IntegerType()
    var $t50: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t51: $Value; // $IntegerType()
    var $t52: $Reference; // ReferenceType($IntegerType())
    var $t53: $Value; // $IntegerType()
    var $t54: $Reference; // ReferenceType($IntegerType())
    var $t55: $Value; // $DesignatedDealer_Dealer_type_value()
    var $t56: $Reference; // ReferenceType($DesignatedDealer_Dealer_type_value())
    var $t57: $Value; // $IntegerType()
    var $t58: $Value; // $IntegerType()
    var $t59: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(6, 2853, 0, dealer); }
    if (true) { assume $DebugTrackLocal(6, 2853, 1, tier_index); }
    if (true) { assume $DebugTrackLocal(6, 2853, 2, new_upperbound); }

    // bytecode translation starts here
    // $t55 := move(dealer)
    call $tmp := $CopyOrMoveValue(dealer);
    $t55 := $tmp;

    // $t57 := move(tier_index)
    call $tmp := $CopyOrMoveValue(tier_index);
    $t57 := $tmp;

    // $t58 := move(new_upperbound)
    call $tmp := $CopyOrMoveValue(new_upperbound);
    $t58 := $tmp;

    // $t56 := borrow_local($t55)
    call $t56 := $BorrowLoc(55, $t55);
    assume $DesignatedDealer_Dealer_is_well_formed($Dereference($t56));

    // $t15 := move($t56)
    call $t15 := $CopyOrMoveRef($t56);

    // $t16 := borrow_field<DesignatedDealer::Dealer>.tiers($t15)
    call $t16 := $BorrowField($t15, $DesignatedDealer_Dealer_tiers);
    assume $Vector_is_well_formed($Dereference($t16)) && (forall $$1: int :: {$select_vector($Dereference($t16),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t16)) ==> $IsValidU64($select_vector($Dereference($t16),$$1)));

    // LocalRoot($t55) <- $t15
    call $t55 := $WritebackToValue($t15, 55, $t55);

    // UnpackRef($t16)

    // tiers := $t16
    call tiers := $CopyOrMoveRef($t16);
    if (true) { assume $DebugTrackLocal(6, 2943, 6, $Dereference(tiers)); }

    // $t17 := copy(tiers)
    call $t17 := $CopyOrMoveRef(tiers);

    // $t18 := read_ref($t17)
    call $tmp := $ReadRef($t17);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t18 := $tmp;

    // Reference(tiers) <- $t17
    call tiers := $WritebackToReference($t17, tiers);

    // $t19 := Vector::length<u64>($t18)
    call $t19 := $Vector_length($IntegerType(), $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3008);
      goto Abort;
    }
    assume $IsValidU64($t19);


    // number_of_tiers := $t19
    call $tmp := $CopyOrMoveValue($t19);
    number_of_tiers := $tmp;
    if (true) { assume $DebugTrackLocal(6, 2982, 4, $tmp); }

    // $t21 := 3
    $tmp := $Integer(3);
    $t21 := $tmp;

    // $t22 := <=($t57, $t21)
    call $tmp := $Le($t57, $t21);
    $t22 := $tmp;

    // $t7 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 3031, 7, $tmp); }

    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t24 := move(tiers)
    call $t24 := $CopyOrMoveRef(tiers);

    // destroy($t24)

    // LocalRoot($t55) <- $t24
    call $t55 := $WritebackToValue($t24, 55, $t55);

    // Reference($t15) <- $t24
    call $t15 := $WritebackToReference($t24, $t15);

    // PackRef($t24)

    // $t25 := 3
    $tmp := $Integer(3);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(6, 3031); }
    goto Abort;

    // L0:
L0:

    // $t28 := <($t57, number_of_tiers)
    call $tmp := $Lt($t57, number_of_tiers);
    $t28 := $tmp;

    // $t9 := $t28
    call $tmp := $CopyOrMoveValue($t28);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 3108, 9, $tmp); }

    // if ($t9) goto L2 else goto L3
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t30 := move(tiers)
    call $t30 := $CopyOrMoveRef(tiers);

    // destroy($t30)

    // LocalRoot($t55) <- $t30
    call $t55 := $WritebackToValue($t30, 55, $t55);

    // Reference($t15) <- $t30
    call $t15 := $WritebackToReference($t30, $t15);

    // PackRef($t30)

    // $t31 := 3
    $tmp := $Integer(3);
    $t31 := $tmp;

    // abort($t31)
    if (true) { assume $DebugTrackAbort(6, 3108); }
    goto Abort;

    // L2:
L2:

    // $t33 := 1
    $tmp := $Integer(1);
    $t33 := $tmp;

    // $t34 := +($t57, $t33)
    call $tmp := $AddU64($t57, $t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3305);
      goto Abort;
    }
    $t34 := $tmp;

    // next_tier := $t34
    call $tmp := $CopyOrMoveValue($t34);
    next_tier := $tmp;
    if (true) { assume $DebugTrackLocal(6, 3282, 3, $tmp); }

    // $t37 := <(next_tier, number_of_tiers)
    call $tmp := $Lt(next_tier, number_of_tiers);
    $t37 := $tmp;

    // if ($t37) goto L4 else goto L5
    $tmp := $t37;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t38 := copy(tiers)
    call $t38 := $CopyOrMoveRef(tiers);

    // $t14 := next_tier
    call $tmp := $CopyOrMoveValue(next_tier);
    $t14 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 3404, 14, $tmp); }

    // $t13 := $t38
    call $t13 := $CopyOrMoveRef($t38);
    if (true) { assume $DebugTrackLocal(6, 3404, 13, $Dereference($t13)); }

    // $t41 := move($t13)
    call $t41 := $CopyOrMoveRef($t13);

    // $t42 := read_ref($t41)
    call $tmp := $ReadRef($t41);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t42 := $tmp;

    // Reference(tiers) <- $t41
    call tiers := $WritebackToReference($t41, tiers);

    // $t44 := Vector::borrow<u64>($t42, $t14)
    call $t44 := $Vector_borrow($IntegerType(), $t42, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3398);
      goto Abort;
    }
    assume $IsValidU64($t44);


    // $t45 := move($t44)
    call $tmp := $CopyOrMoveValue($t44);
    $t45 := $tmp;

    // $t46 := <($t58, $t45)
    call $tmp := $Lt($t58, $t45);
    $t46 := $tmp;

    // $t11 := $t46
    call $tmp := $CopyOrMoveValue($t46);
    $t11 := $tmp;
    if (true) { assume $DebugTrackLocal(6, 3365, 11, $tmp); }

    // if ($t11) goto L6 else goto L7
    $tmp := $t11;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // $t48 := move(tiers)
    call $t48 := $CopyOrMoveRef(tiers);

    // destroy($t48)

    // LocalRoot($t55) <- $t48
    call $t55 := $WritebackToValue($t48, 55, $t55);

    // Reference($t15) <- $t48
    call $t15 := $WritebackToReference($t48, $t15);

    // PackRef($t48)

    // $t49 := 2
    $tmp := $Integer(2);
    $t49 := $tmp;

    // abort($t49)
    if (true) { assume $DebugTrackAbort(6, 3365); }
    goto Abort;

    // L6:
L6:

    // $t50 := move(tiers)
    call $t50 := $CopyOrMoveRef(tiers);

    // $t59 := read_ref($t50)
    call $tmp := $ReadRef($t50);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU64($select_vector($tmp,$$0)));
    $t59 := $tmp;

    // ($t52, $t59) := Vector::borrow_mut<u64>($t59, $t57)
    call $t52, $t59 := $Vector_borrow_mut($IntegerType(), $t59, $t57);
    if ($abort_flag) {
      assume $DebugTrackAbort(6, 3488);
      goto Abort;
    }
    assume $IsValidU64($Dereference($t52));

    assume $Vector_is_well_formed($t59) && (forall $$0: int :: {$select_vector($t59,$$0)} $$0 >= 0 && $$0 < $vlen($t59) ==> $IsValidU64($select_vector($t59,$$0)));


    // write_ref($t50, $t59)
    call $t50 := $WriteRef($t50, $t59);
    if (true) { assume $DebugTrackLocal(6, 3499, 6, $Dereference(tiers)); }

    // $t52 ~- [0 -> $t50]
    call $t52 := $Splice1(0, $t50, $t52);

    // LocalRoot($t55) <- $t50
    call $t55 := $WritebackToValue($t50, 55, $t55);

    // Reference($t15) <- $t50
    call $t15 := $WritebackToReference($t50, $t15);

    // tier_mut := $t52
    call tier_mut := $CopyOrMoveRef($t52);
    if (true) { assume $DebugTrackLocal(6, 3469, 5, $Dereference(tier_mut)); }

    // $t54 := move(tier_mut)
    call $t54 := $CopyOrMoveRef(tier_mut);

    // write_ref($t54, $t58)
    call $t54 := $WriteRef($t54, $t58);
    if (true) { assume $DebugTrackLocal(6, 3527, 6, $Dereference(tiers)); }

    // LocalRoot($t55) <- $t54
    call $t55 := $WritebackToValue($t54, 55, $t55);

    // Reference($t50) <- $t54
    call $t50 := $WritebackToReference($t54, $t50);

    // Reference($t15) <- $t50
    call $t15 := $WritebackToReference($t50, $t15);

    // PackRef($t50)

    // PackRef($t54)

    // return $t55
    $ret0 := $t55;
    if (true) { assume $DebugTrackLocal(6, 3553, 60, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_update_tier_(dealer: $Value, tier_index: $Value, new_upperbound: $Value) returns ($ret0: $Value)
free requires $DesignatedDealer_Dealer_is_well_formed(dealer);
free requires $IsValidU64(tier_index);
free requires $IsValidU64(new_upperbound);
{
    call $ret0 := $DesignatedDealer_update_tier__def(dealer, tier_index, new_upperbound);
}

procedure {:inline 1} $DesignatedDealer_window_length_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 86400000000
    $tmp := $Integer(86400000000);
    $t0 := $tmp;

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(6, 6260, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DesignatedDealer_window_length() returns ($ret0: $Value)
{
    call $ret0 := $DesignatedDealer_window_length_def();
}



// ** spec vars of module VASP



// ** spec funs of module VASP

function {:inline} $VASP_spec_parent_address($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    if (b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, addr))) then (addr) else (if (b#$Boolean($VASP_spec_is_child_vasp($m, $txn, addr))) then ($SelectField($ResourceValue($m, $VASP_ChildVASP_type_value(), addr), $VASP_ChildVASP_parent_vasp_addr)) else ($Address(68719476735)))
}

function {:inline} $VASP_spec_is_parent_vasp($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $ResourceExists($m, $VASP_ParentVASP_type_value(), addr)
}

function {:inline} $VASP_spec_is_child_vasp($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $ResourceExists($m, $VASP_ChildVASP_type_value(), addr)
}

function {:inline} $VASP_spec_is_vasp($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $Boolean(b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, addr)) || b#$Boolean($VASP_spec_is_child_vasp($m, $txn, addr)))
}

function {:inline} $VASP_spec_is_same_vasp($m: $Memory, $txn: $Transaction, addr1: $Value, addr2: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($VASP_spec_is_vasp($m, $txn, addr1)) && b#$Boolean($VASP_spec_is_vasp($m, $txn, addr2)))) && b#$Boolean($Boolean($IsEqual($VASP_spec_parent_address($m, $txn, addr1), $VASP_spec_parent_address($m, $txn, addr2)))))
}

function {:inline} $VASP_spec_child_has_parent($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $Boolean(b#$Boolean($VASP_spec_is_child_vasp($m, $txn, addr)) ==> b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $SelectField($ResourceValue($m, $VASP_ChildVASP_type_value(), addr), $VASP_ChildVASP_parent_vasp_addr))))
}

function {:inline} $VASP_spec_get_num_children($m: $Memory, $txn: $Transaction, parent: $Value): $Value {
    $SelectField($ResourceValue($m, $VASP_ParentVASP_type_value(), parent), $VASP_ParentVASP_num_children)
}



// ** structs of module VASP

const unique $VASP_ChildVASP: $TypeName;
const $VASP_ChildVASP_parent_vasp_addr: $FieldName;
axiom $VASP_ChildVASP_parent_vasp_addr == 0;
function $VASP_ChildVASP_type_value(): $TypeValue {
    $StructType($VASP_ChildVASP, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AddressType()], 1))
}
function {:inline} $VASP_ChildVASP_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $VASP_ChildVASP_parent_vasp_addr))
}
function {:inline} $VASP_ChildVASP_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $VASP_ChildVASP_parent_vasp_addr))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $VASP_ChildVASP_is_well_formed($ResourceValue(m, $VASP_ChildVASP_type_value(), a))
);

procedure {:inline 1} $VASP_ChildVASP_pack($file_id: int, $byte_index: int, $var_idx: int, parent_vasp_addr: $Value) returns ($struct: $Value)
{
    assume is#$Address(parent_vasp_addr);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := parent_vasp_addr], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $VASP_ChildVASP_unpack($struct: $Value) returns (parent_vasp_addr: $Value)
{
    assume is#$Vector($struct);
    parent_vasp_addr := $SelectField($struct, $VASP_ChildVASP_parent_vasp_addr);
    assume is#$Address(parent_vasp_addr);
}

const unique $VASP_ParentVASP: $TypeName;
const $VASP_ParentVASP_num_children: $FieldName;
axiom $VASP_ParentVASP_num_children == 0;
function $VASP_ParentVASP_type_value(): $TypeValue {
    $StructType($VASP_ParentVASP, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $VASP_ParentVASP_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $VASP_ParentVASP_num_children))
}
function {:inline} $VASP_ParentVASP_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $VASP_ParentVASP_num_children))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $VASP_ParentVASP_is_well_formed($ResourceValue(m, $VASP_ParentVASP_type_value(), a))
);

procedure {:inline 1} $VASP_ParentVASP_pack($file_id: int, $byte_index: int, $var_idx: int, num_children: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(num_children);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := num_children], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $VASP_ParentVASP_unpack($struct: $Value) returns (num_children: $Value)
{
    assume is#$Vector($struct);
    num_children := $SelectField($struct, $VASP_ParentVASP_num_children);
    assume $IsValidU64(num_children);
}

const unique $VASP_VASPOperationsResource: $TypeName;
const $VASP_VASPOperationsResource_limits_cap: $FieldName;
axiom $VASP_VASPOperationsResource_limits_cap == 0;
function $VASP_VASPOperationsResource_type_value(): $TypeValue {
    $StructType($VASP_VASPOperationsResource, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AccountLimits_CallingCapability_type_value()], 1))
}
function {:inline} $VASP_VASPOperationsResource_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $AccountLimits_CallingCapability_is_well_formed_types($SelectField($this, $VASP_VASPOperationsResource_limits_cap))
}
function {:inline} $VASP_VASPOperationsResource_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $AccountLimits_CallingCapability_is_well_formed($SelectField($this, $VASP_VASPOperationsResource_limits_cap))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $VASP_VASPOperationsResource_is_well_formed($ResourceValue(m, $VASP_VASPOperationsResource_type_value(), a))
);

procedure {:inline 1} $VASP_VASPOperationsResource_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value) returns ($struct: $Value)
{
    assume $AccountLimits_CallingCapability_is_well_formed(limits_cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := limits_cap], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $VASP_VASPOperationsResource_unpack($struct: $Value) returns (limits_cap: $Value)
{
    assume is#$Vector($struct);
    limits_cap := $SelectField($struct, $VASP_VASPOperationsResource_limits_cap);
    assume $AccountLimits_CallingCapability_is_well_formed(limits_cap);
}



// ** functions of module VASP

procedure {:inline 1} $VASP_initialize_def(lr_account: $Value) returns (){
    // declare local variables
    var limits_cap: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t28: $Value; // $VASP_VASPOperationsResource_type_value()
    var $t29: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 1254, 0, lr_account); }

    // bytecode translation starts here
    // $t29 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t29 := $tmp;

    // $t8 := LibraTimestamp::is_genesis()
    call $t8 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1330);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t2 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 1307, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(26, 1307); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t12 := $tmp;

    // $t13 := Roles::has_libra_root_role($t12)
    call $t13 := $Roles_has_libra_root_role($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1381);
      goto Abort;
    }
    assume is#$Boolean($t13);


    // $t4 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 1367, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t15 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 3
    $tmp := $Integer(3);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(26, 1367); }
    goto Abort;

    // L2:
L2:

    // $t17 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t17 := $tmp;

    // $t18 := Signer::address_of($t17)
    call $t18 := $Signer_address_of($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1455);
      goto Abort;
    }
    assume is#$Address($t18);


    // $t19 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t19 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1496);
      goto Abort;
    }
    assume is#$Address($t19);


    // $t20 := ==($t18, $t19)
    $tmp := $Boolean($IsEqual($t18, $t19));
    $t20 := $tmp;

    // $t6 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 1440, 6, $tmp); }

    // if ($t6) goto L4 else goto L5
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t22 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t22 := $tmp;

    // destroy($t22)

    // $t23 := 2
    $tmp := $Integer(2);
    $t23 := $tmp;

    // abort($t23)
    if (true) { assume $DebugTrackAbort(26, 1440); }
    goto Abort;

    // L4:
L4:

    // $t24 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t24 := $tmp;

    // $t25 := AccountLimits::grant_calling_capability($t24)
    call $t25 := $AccountLimits_grant_calling_capability($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1587);
      goto Abort;
    }
    assume $AccountLimits_CallingCapability_is_well_formed($t25);


    // limits_cap := $t25
    call $tmp := $CopyOrMoveValue($t25);
    limits_cap := $tmp;
    if (true) { assume $DebugTrackLocal(26, 1559, 1, $tmp); }

    // $t26 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t26 := $tmp;

    // $t28 := pack VASP::VASPOperationsResource(limits_cap)
    call $tmp := $VASP_VASPOperationsResource_pack(0, 0, 0, limits_cap);
    $t28 := $tmp;

    // move_to<VASP::VASPOperationsResource>($t28, $t26)
    call $MoveTo($VASP_VASPOperationsResource_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 1633);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $VASP_initialize(lr_account: $Value) returns ()
free requires is#$Address(lr_account);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
{
    call $VASP_initialize_def(lr_account);
}

procedure {:inline 1} $VASP_is_child_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 7933, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;

    // $t2 := exists<VASP::ChildVASP>($t3)
    call $tmp := $Exists($t3, $VASP_ChildVASP_type_value());
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(26, 7984, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_is_child(addr: $Value) returns ($ret0: $Value);
free requires is#$Address(addr);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_child_vasp($m, $txn, addr)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
procedure {:inline 1} $VASP_is_parent_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 7507, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;

    // $t2 := exists<VASP::ParentVASP>($t3)
    call $tmp := $Exists($t3, $VASP_ParentVASP_type_value());
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(26, 7559, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_is_parent(addr: $Value) returns ($ret0: $Value);
free requires is#$Address(addr);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_parent_vasp($m, $txn, addr)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
procedure {:inline 1} $VASP_is_same_vasp_def(addr1: $Value, addr2: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 9183, 0, addr1); }
    if (true) { assume $DebugTrackLocal(26, 9183, 1, addr2); }

    // bytecode translation starts here
    // $t17 := move(addr1)
    call $tmp := $CopyOrMoveValue(addr1);
    $t17 := $tmp;

    // $t18 := move(addr2)
    call $tmp := $CopyOrMoveValue(addr2);
    $t18 := $tmp;

    // $t5 := VASP::is_vasp($t17)
    call $t5 := $VASP_is_vasp($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 8710);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t7 := VASP::is_vasp($t18)
    call $t7 := $VASP_is_vasp($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 8710);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t2 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 9274, 2, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t8 := false
    $tmp := $Boolean(false);
    $t8 := $tmp;

    // $t2 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 9274, 2, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if ($t2) goto L4 else goto L5
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t11 := VASP::parent_address($t17)
    call $t11 := $VASP_parent_address($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 6361);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t13 := VASP::parent_address($t18)
    call $t13 := $VASP_parent_address($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 6361);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := ==($t11, $t13)
    $tmp := $Boolean($IsEqual($t11, $t13));
    $t14 := $tmp;

    // $t3 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 9274, 3, $tmp); }

    // goto L7
    goto L7;

    // L6:
L6:

    // $t15 := false
    $tmp := $Boolean(false);
    $t15 := $tmp;

    // $t3 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 9274, 3, $tmp); }

    // goto L7
    goto L7;

    // L7:
L7:

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(26, 9274, 19, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_is_same_vasp(addr1: $Value, addr2: $Value) returns ($ret0: $Value);
free requires is#$Address(addr1);
free requires is#$Address(addr2);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_same_vasp($m, $txn, addr1, addr2)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
procedure {:inline 1} $VASP_is_vasp_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 8699, 0, addr); }

    // bytecode translation starts here
    // $t8 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t8 := $tmp;

    // $t3 := VASP::is_parent($t8)
    call $t3 := $VASP_is_parent($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 7518);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t4 := true
    $tmp := $Boolean(true);
    $t4 := $tmp;

    // $t1 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 8749, 1, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t6 := VASP::is_child($t8)
    call $t6 := $VASP_is_child($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 7944);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t1 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 8749, 1, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(26, 8749, 9, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_is_vasp(addr: $Value) returns ($ret0: $Value);
free requires is#$Address(addr);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_is_vasp($m, $txn, addr)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
procedure {:inline 1} $VASP_num_children_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $VASP_ParentVASP_type_value()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 9961, 0, addr); }

    // bytecode translation starts here
    // $t6 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t6 := $tmp;

    // $t2 := VASP::parent_address($t6)
    call $t2 := $VASP_parent_address($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 6361);
      goto Abort;
    }
    assume is#$Address($t2);


    // $t3 := get_global<VASP::ParentVASP>($t2)
    call $tmp := $GetGlobal($t2, $VASP_ParentVASP_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 10049);
      goto Abort;
    }
    assume $VASP_ParentVASP_is_well_formed($tmp);
    $t3 := $tmp;

    // $t4 := get_field<VASP::ParentVASP>.num_children($t3)
    call $tmp := $GetFieldFromValue($t3, $VASP_ParentVASP_num_children);
    assume $IsValidU64($tmp);
    $t4 := $tmp;

    // $t5 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t5 := $tmp;

    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(26, 10047, 7, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_num_children(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))))
    || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))
    || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $VASP_spec_parent_address($m, $txn, addr)))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $VASP_spec_parent_address($m, $txn, addr)))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $VASP_spec_parent_address($m, $txn, addr))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
{
    call $ret0 := $VASP_num_children_def(addr);
}

procedure {:inline 1} $VASP_parent_address_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $VASP_ChildVASP_type_value()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 6350, 0, addr); }

    // bytecode translation starts here
    // $t15 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t15 := $tmp;

    // $t4 := VASP::is_parent($t15)
    call $t4 := $VASP_is_parent($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 7518);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t2 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 6429, 2, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t7 := VASP::is_child($t15)
    call $t7 := $VASP_is_child($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 7944);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // if ($t7) goto L4 else goto L5
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t8 := 88
    $tmp := $Integer(88);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(26, 6624); }
    goto Abort;

    // L4:
L4:

    // $t10 := get_global<VASP::ChildVASP>($t15)
    call $tmp := $GetGlobal($t15, $VASP_ChildVASP_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 6518);
      goto Abort;
    }
    assume $VASP_ChildVASP_is_well_formed($tmp);
    $t10 := $tmp;

    // $t11 := get_field<VASP::ChildVASP>.parent_vasp_addr($t10)
    call $tmp := $GetFieldFromValue($t10, $VASP_ChildVASP_parent_vasp_addr);
    assume is#$Address($tmp);
    $t11 := $tmp;

    // $t12 := move($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;

    // $t1 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 6484, 1, $tmp); }

    // $t2 := $t1
    call $tmp := $CopyOrMoveValue($t1);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 6429, 2, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(26, 6429, 16, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_parent_address(addr: $Value) returns ($ret0: $Value);
free requires is#$Address(addr);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))))
    || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))
    || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, addr)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $VASP_spec_parent_address($m, $txn, addr)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
procedure {:inline 1} $VASP_publish_child_vasp_credential_def(parent: $Value, child: $Value) returns (){
    // declare local variables
    var child_vasp_addr: $Value; // $AddressType()
    var num_children: $Reference; // ReferenceType($IntegerType())
    var parent_vasp_addr: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $AddressType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Value; // $AddressType()
    var $t34: $Reference; // ReferenceType($VASP_ParentVASP_type_value())
    var $t35: $Reference; // ReferenceType($IntegerType())
    var $t36: $Reference; // ReferenceType($IntegerType())
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $IntegerType()
    var $t40: $Reference; // ReferenceType($IntegerType())
    var $t41: $Value; // $AddressType()
    var $t42: $Value; // $AddressType()
    var $t43: $Value; // $VASP_ChildVASP_type_value()
    var $t44: $Value; // $AddressType()
    var $t45: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 2840, 0, parent); }
    if (true) { assume $DebugTrackLocal(26, 2840, 1, child); }

    // bytecode translation starts here
    // $t44 := move(parent)
    call $tmp := $CopyOrMoveValue(parent);
    $t44 := $tmp;

    // $t45 := move(child)
    call $tmp := $CopyOrMoveValue(child);
    $t45 := $tmp;

    // $t11 := copy($t44)
    call $tmp := $CopyOrMoveValue($t44);
    $t11 := $tmp;

    // $t12 := Roles::has_parent_VASP_role($t11)
    call $t12 := $Roles_has_parent_VASP_role($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3324);
      goto Abort;
    }
    assume is#$Boolean($t12);


    // $t5 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 3310, 5, $tmp); }

    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t14 := move($t44)
    call $tmp := $CopyOrMoveValue($t44);
    $t14 := $tmp;

    // destroy($t14)

    // $t15 := move($t45)
    call $tmp := $CopyOrMoveValue($t45);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 4
    $tmp := $Integer(4);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(26, 3310); }
    goto Abort;

    // L0:
L0:

    // $t17 := copy($t45)
    call $tmp := $CopyOrMoveValue($t45);
    $t17 := $tmp;

    // $t18 := Signer::address_of($t17)
    call $t18 := $Signer_address_of($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3413);
      goto Abort;
    }
    assume is#$Address($t18);


    // child_vasp_addr := $t18
    call $tmp := $CopyOrMoveValue($t18);
    child_vasp_addr := $tmp;
    if (true) { assume $DebugTrackLocal(26, 3387, 2, $tmp); }

    // $t20 := VASP::is_vasp(child_vasp_addr)
    call $t20 := $VASP_is_vasp(child_vasp_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 8710);
      goto Abort;
    }
    assume is#$Boolean($t20);


    // $t21 := !($t20)
    call $tmp := $Not($t20);
    $t21 := $tmp;

    // $t7 := $t21
    call $tmp := $CopyOrMoveValue($t21);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 3440, 7, $tmp); }

    // if ($t7) goto L2 else goto L3
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t23 := move($t44)
    call $tmp := $CopyOrMoveValue($t44);
    $t23 := $tmp;

    // destroy($t23)

    // $t24 := move($t45)
    call $tmp := $CopyOrMoveValue($t45);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := 7
    $tmp := $Integer(7);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(26, 3440); }
    goto Abort;

    // L2:
L2:

    // $t26 := move($t44)
    call $tmp := $CopyOrMoveValue($t44);
    $t26 := $tmp;

    // $t27 := Signer::address_of($t26)
    call $t27 := $Signer_address_of($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3531);
      goto Abort;
    }
    assume is#$Address($t27);


    // parent_vasp_addr := $t27
    call $tmp := $CopyOrMoveValue($t27);
    parent_vasp_addr := $tmp;
    if (true) { assume $DebugTrackLocal(26, 3504, 4, $tmp); }

    // $t29 := VASP::is_parent(parent_vasp_addr)
    call $t29 := $VASP_is_parent(parent_vasp_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 7518);
      goto Abort;
    }
    assume is#$Boolean($t29);


    // $t9 := $t29
    call $tmp := $CopyOrMoveValue($t29);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 3559, 9, $tmp); }

    // if ($t9) goto L4 else goto L5
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t31 := move($t45)
    call $tmp := $CopyOrMoveValue($t45);
    $t31 := $tmp;

    // destroy($t31)

    // $t32 := 4
    $tmp := $Integer(4);
    $t32 := $tmp;

    // abort($t32)
    if (true) { assume $DebugTrackAbort(26, 3559); }
    goto Abort;

    // L4:
L4:

    // $t34 := borrow_global<VASP::ParentVASP>(parent_vasp_addr)
    call $t34 := $BorrowGlobal(parent_vasp_addr, $VASP_ParentVASP_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3648);
      goto Abort;
    }
    assume $VASP_ParentVASP_is_well_formed($Dereference($t34));

    // UnpackRef($t34)

    // $t35 := borrow_field<VASP::ParentVASP>.num_children($t34)
    call $t35 := $BorrowField($t34, $VASP_ParentVASP_num_children);
    assume $IsValidU64($Dereference($t35));

    // VASP::ParentVASP <- $t34
    call $WritebackToGlobal($t34);

    // UnpackRef($t35)

    // num_children := $t35
    call num_children := $CopyOrMoveRef($t35);
    if (true) { assume $DebugTrackLocal(26, 3628, 3, $Dereference(num_children)); }

    // $t36 := copy(num_children)
    call $t36 := $CopyOrMoveRef(num_children);

    // $t37 := read_ref($t36)
    call $tmp := $ReadRef($t36);
    assume $IsValidU64($tmp);
    $t37 := $tmp;

    // Reference(num_children) <- $t36
    call num_children := $WritebackToReference($t36, num_children);

    // $t38 := 1
    $tmp := $Integer(1);
    $t38 := $tmp;

    // $t39 := +($t37, $t38)
    call $tmp := $AddU64($t37, $t38);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3748);
      goto Abort;
    }
    $t39 := $tmp;

    // $t40 := move(num_children)
    call $t40 := $CopyOrMoveRef(num_children);

    // write_ref($t40, $t39)
    call $t40 := $WriteRef($t40, $t39);
    if (true) { assume $DebugTrackLocal(26, 3718, 3, $Dereference(num_children)); }

    // VASP::ParentVASP <- $t40
    call $WritebackToGlobal($t40);

    // Reference($t34) <- $t40
    call $t34 := $WritebackToReference($t40, $t34);

    // PackRef($t34)

    // PackRef($t40)

    // $t41 := move($t45)
    call $tmp := $CopyOrMoveValue($t45);
    $t41 := $tmp;

    // $t43 := pack VASP::ChildVASP(parent_vasp_addr)
    call $tmp := $VASP_ChildVASP_pack(0, 0, 0, parent_vasp_addr);
    $t43 := $tmp;

    // move_to<VASP::ChildVASP>($t43, $t41)
    call $MoveTo($VASP_ChildVASP_type_value(), $t43, $t41);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 3761);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $VASP_publish_child_vasp_credential(parent: $Value, child: $Value) returns ()
free requires is#$Address(parent);
free requires is#$Address(child);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))))
    || b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role($m, $txn, parent))))
    || b#$Boolean($VASP_spec_is_vasp($m, $txn, $Signer_spec_address_of($m, $txn, child)))
    || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $Signer_spec_address_of($m, $txn, parent)))))
    || b#$Boolean($Boolean(i#$Integer($Integer(i#$Integer($VASP_spec_get_num_children($m, $txn, $Signer_spec_address_of($m, $txn, parent))) + i#$Integer($Integer(1)))) > i#$Integer($Integer($MAX_U64))));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role($m, $txn, parent))))) ==> $abort_flag;
free ensures b#$Boolean(old($VASP_spec_is_vasp($m, $txn, $Signer_spec_address_of($m, $txn, child)))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $Signer_spec_address_of($m, $txn, parent)))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($VASP_spec_get_num_children($m, $txn, $Signer_spec_address_of($m, $txn, parent))) + i#$Integer($Integer(1)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Roles_spec_has_parent_VASP_role($m, $txn, parent))))))
    || b#$Boolean(old(($VASP_spec_is_vasp($m, $txn, $Signer_spec_address_of($m, $txn, child)))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $Signer_spec_address_of($m, $txn, parent)))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($VASP_spec_get_num_children($m, $txn, $Signer_spec_address_of($m, $txn, parent))) + i#$Integer($Integer(1)))) > i#$Integer($Integer($MAX_U64)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($VASP_spec_get_num_children($m, $txn, $Signer_spec_address_of($m, $txn, parent)), $Integer(i#$Integer(old($VASP_spec_get_num_children($m, $txn, $Signer_spec_address_of($m, $txn, parent)))) + i#$Integer($Integer(1)))))));
free ensures !$abort_flag ==> (b#$Boolean($VASP_spec_is_child_vasp($m, $txn, $Signer_spec_address_of($m, $txn, child))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($DebugTrackExp(17, 63, $VASP_spec_parent_address($m, $txn, $Signer_spec_address_of($m, $txn, child))), $DebugTrackExp(17, 66, $Signer_spec_address_of($m, $txn, parent))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
{
    call $VASP_publish_child_vasp_credential_def(parent, child);
}

procedure {:inline 1} $VASP_publish_parent_vasp_credential_def(vasp: $Value, lr_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var vasp_addr: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $VASP_ParentVASP_type_value()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 2098, 0, vasp); }
    if (true) { assume $DebugTrackLocal(26, 2098, 1, lr_account); }

    // bytecode translation starts here
    // $t23 := move(vasp)
    call $tmp := $CopyOrMoveValue(vasp);
    $t23 := $tmp;

    // $t24 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t24 := $tmp;

    // $t7 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t7 := $tmp;

    // $t8 := Roles::has_libra_root_role($t7)
    call $t8 := $Roles_has_libra_root_role($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2200);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t2 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 2186, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := 3
    $tmp := $Integer(3);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(26, 2186); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t12 := $tmp;

    // $t13 := Signer::address_of($t12)
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2283);
      goto Abort;
    }
    assume is#$Address($t13);


    // vasp_addr := $t13
    call $tmp := $CopyOrMoveValue($t13);
    vasp_addr := $tmp;
    if (true) { assume $DebugTrackLocal(26, 2263, 6, $tmp); }

    // $t15 := VASP::is_vasp(vasp_addr)
    call $t15 := $VASP_is_vasp(vasp_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 8710);
      goto Abort;
    }
    assume is#$Boolean($t15);


    // $t16 := !($t15)
    call $tmp := $Not($t15);
    $t16 := $tmp;

    // $t4 := $t16
    call $tmp := $CopyOrMoveValue($t16);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 2309, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t18 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t18 := $tmp;

    // destroy($t18)

    // $t19 := 5
    $tmp := $Integer(5);
    $t19 := $tmp;

    // abort($t19)
    if (true) { assume $DebugTrackAbort(26, 2309); }
    goto Abort;

    // L2:
L2:

    // $t20 := move($t23)
    call $tmp := $CopyOrMoveValue($t23);
    $t20 := $tmp;

    // $t21 := 0
    $tmp := $Integer(0);
    $t21 := $tmp;

    // $t22 := pack VASP::ParentVASP($t21)
    call $tmp := $VASP_ParentVASP_pack(0, 0, 0, $t21);
    $t22 := $tmp;

    // move_to<VASP::ParentVASP>($t22, $t20)
    call $MoveTo($VASP_ParentVASP_type_value(), $t22, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 2359);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $VASP_publish_parent_vasp_credential(vasp: $Value, lr_account: $Value) returns ()
free requires is#$Address(vasp);
free requires is#$Address(lr_account);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))))
    || b#$Boolean($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role($m, $txn, lr_account))))
    || b#$Boolean($VASP_spec_is_vasp($m, $txn, $Signer_spec_address_of($m, $txn, vasp)));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role($m, $txn, lr_account))))) ==> $abort_flag;
free ensures b#$Boolean(old($VASP_spec_is_vasp($m, $txn, $Signer_spec_address_of($m, $txn, vasp)))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Roles_spec_has_libra_root_role($m, $txn, lr_account))))))
    || b#$Boolean(old(($VASP_spec_is_vasp($m, $txn, $Signer_spec_address_of($m, $txn, vasp))))));
free ensures !$abort_flag ==> (b#$Boolean($VASP_spec_is_parent_vasp($m, $txn, $Signer_spec_address_of($m, $txn, vasp))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($VASP_spec_get_num_children($m, $txn, $Signer_spec_address_of($m, $txn, vasp)), $Integer(0)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
{
    call $VASP_publish_parent_vasp_credential_def(vasp, lr_account);
}

procedure {:inline 1} $VASP_try_allow_currency_def($tv0: $TypeValue, account: $Value) returns ($ret0: $Value){
    // declare local variables
    var account_address: $Value; // $AddressType()
    var cap: $Value; // $AccountLimits_CallingCapability_type_value()
    var parent_address: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $VASP_VASPOperationsResource_type_value()
    var $t29: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t30: $Value; // $AddressType()
    var $t31: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t34: $Value; // $AddressType()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $BooleanType()
    var $t38: $Value; // $BooleanType()
    var $t39: $Value; // $BooleanType()
    var $t40: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(26, 5099, 0, account); }

    // bytecode translation starts here
    // $t40 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t40 := $tmp;

    // $t8 := Libra::is_currency<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t8 := $Libra_is_currency($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5234);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t4 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5220, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := 1
    $tmp := $Integer(1);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(26, 5220); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t12 := $tmp;

    // $t13 := Signer::address_of($t12)
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5326);
      goto Abort;
    }
    assume is#$Address($t13);


    // account_address := $t13
    call $tmp := $CopyOrMoveValue($t13);
    account_address := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5300, 1, $tmp); }

    // $t15 := VASP::is_vasp(account_address)
    call $t15 := $VASP_is_vasp(account_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 8710);
      goto Abort;
    }
    assume is#$Boolean($t15);


    // $t16 := !($t15)
    call $tmp := $Not($t15);
    $t16 := $tmp;

    // if ($t16) goto L2 else goto L3
    $tmp := $t16;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t17 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t17 := $tmp;

    // destroy($t17)

    // $t18 := true
    $tmp := $Boolean(true);
    $t18 := $tmp;

    // return $t18
    $ret0 := $t18;
    if (true) { assume $DebugTrackLocal(26, 5386, 41, $ret0); }
    return;

    // L4:
L4:

    // $t20 := VASP::parent_address(account_address)
    call $t20 := $VASP_parent_address(account_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 6361);
      goto Abort;
    }
    assume is#$Address($t20);


    // parent_address := $t20
    call $tmp := $CopyOrMoveValue($t20);
    parent_address := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5411, 3, $tmp); }

    // $t22 := AccountLimits::has_limits_published<#0>(parent_address)
    call $t22 := $AccountLimits_has_limits_published($tv0, parent_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5488);
      goto Abort;
    }
    assume is#$Boolean($t22);


    // if ($t22) goto L5 else goto L6
    $tmp := $t22;
    if (b#$Boolean($tmp)) { goto L5; } else { goto L6; }

    // L6:
L6:

    // goto L7
    goto L7;

    // L5:
L5:

    // $t23 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t23 := $tmp;

    // destroy($t23)

    // $t24 := true
    $tmp := $Boolean(true);
    $t24 := $tmp;

    // $t7 := $t24
    call $tmp := $CopyOrMoveValue($t24);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5469, 7, $tmp); }

    // goto L8
    goto L8;

    // L7:
L7:

    // $t26 := VASP::is_parent(account_address)
    call $t26 := $VASP_is_parent(account_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 7518);
      goto Abort;
    }
    assume is#$Boolean($t26);


    // if ($t26) goto L9 else goto L10
    $tmp := $t26;
    if (b#$Boolean($tmp)) { goto L9; } else { goto L10; }

    // L10:
L10:

    // goto L11
    goto L11;

    // L9:
L9:

    // $t27 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t27 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5680);
      goto Abort;
    }
    assume is#$Address($t27);


    // $t28 := get_global<VASP::VASPOperationsResource>($t27)
    call $tmp := $GetGlobal($t27, $VASP_VASPOperationsResource_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5627);
      goto Abort;
    }
    assume $VASP_VASPOperationsResource_is_well_formed($tmp);
    $t28 := $tmp;

    // $t29 := get_field<VASP::VASPOperationsResource>.limits_cap($t28)
    call $tmp := $GetFieldFromValue($t28, $VASP_VASPOperationsResource_limits_cap);
    assume $AccountLimits_CallingCapability_is_well_formed($tmp);
    $t29 := $tmp;

    // cap := $t29
    call $tmp := $CopyOrMoveValue($t29);
    cap := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5620, 2, $tmp); }

    // $t30 := copy($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t30 := $tmp;

    // $t31 := copy(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t31 := $tmp;

    // AccountLimits::publish_unrestricted_limits<#0>($t30, $t31)
    call $AccountLimits_publish_unrestricted_limits($tv0, $t30, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5741);
      goto Abort;
    }

    // $t32 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t32 := $tmp;

    // $t33 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t33 := $tmp;

    // AccountLimits::publish_window<#0>($t32, $t33, parent_address)
    call $AccountLimits_publish_window($tv0, $t32, $t33, parent_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(26, 5821);
      goto Abort;
    }

    // $t35 := true
    $tmp := $Boolean(true);
    $t35 := $tmp;

    // $t6 := $t35
    call $tmp := $CopyOrMoveValue($t35);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5570, 6, $tmp); }

    // goto L12
    goto L12;

    // L11:
L11:

    // $t36 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t36 := $tmp;

    // destroy($t36)

    // $t37 := false
    $tmp := $Boolean(false);
    $t37 := $tmp;

    // $t6 := $t37
    call $tmp := $CopyOrMoveValue($t37);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5570, 6, $tmp); }

    // goto L12
    goto L12;

    // L12:
L12:

    // $t7 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(26, 5469, 7, $tmp); }

    // goto L8
    goto L8;

    // L8:
L8:

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(26, 5469, 41, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $VASP_try_allow_currency($tv0: $TypeValue, account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
requires b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(true)));
{
    call $ret0 := $VASP_try_allow_currency_def($tv0, account);
}



// ** spec vars of module Signature



// ** spec funs of module Signature



// ** structs of module Signature



// ** functions of module Signature



// ** spec vars of module DualAttestationLimit



// ** spec funs of module DualAttestationLimit

function {:inline} $DualAttestationLimit_spec_is_published($m: $Memory, $txn: $Transaction): $Value {
    $LibraConfig_spec_is_published($m, $txn, $DualAttestationLimit_DualAttestationLimit_type_value())
}

function {:inline} $DualAttestationLimit_spec_get_cur_microlibra_limit($m: $Memory, $txn: $Transaction): $Value {
    $SelectField($LibraConfig_spec_get($m, $txn, $DualAttestationLimit_DualAttestationLimit_type_value()), $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit)
}



// ** structs of module DualAttestationLimit

const unique $DualAttestationLimit_DualAttestationLimit: $TypeName;
const $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit: $FieldName;
axiom $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit == 0;
function $DualAttestationLimit_DualAttestationLimit_type_value(): $TypeValue {
    $StructType($DualAttestationLimit_DualAttestationLimit, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $DualAttestationLimit_DualAttestationLimit_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit))
}
function {:inline} $DualAttestationLimit_DualAttestationLimit_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit))
}

procedure {:inline 1} $DualAttestationLimit_DualAttestationLimit_pack($file_id: int, $byte_index: int, $var_idx: int, micro_lbr_limit: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(micro_lbr_limit);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := micro_lbr_limit], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestationLimit_DualAttestationLimit_unpack($struct: $Value) returns (micro_lbr_limit: $Value)
{
    assume is#$Vector($struct);
    micro_lbr_limit := $SelectField($struct, $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit);
    assume $IsValidU64(micro_lbr_limit);
}

const unique $DualAttestationLimit_ModifyLimitCapability: $TypeName;
const $DualAttestationLimit_ModifyLimitCapability_cap: $FieldName;
axiom $DualAttestationLimit_ModifyLimitCapability_cap == 0;
function $DualAttestationLimit_ModifyLimitCapability_type_value(): $TypeValue {
    $StructType($DualAttestationLimit_ModifyLimitCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())], 1))
}
function {:inline} $DualAttestationLimit_ModifyLimitCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $LibraConfig_ModifyConfigCapability_is_well_formed_types($SelectField($this, $DualAttestationLimit_ModifyLimitCapability_cap))
}
function {:inline} $DualAttestationLimit_ModifyLimitCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $LibraConfig_ModifyConfigCapability_is_well_formed($SelectField($this, $DualAttestationLimit_ModifyLimitCapability_cap))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $DualAttestationLimit_ModifyLimitCapability_is_well_formed($ResourceValue(m, $DualAttestationLimit_ModifyLimitCapability_type_value(), a))
);

procedure {:inline 1} $DualAttestationLimit_ModifyLimitCapability_pack($file_id: int, $byte_index: int, $var_idx: int, cap: $Value) returns ($struct: $Value)
{
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(cap);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := cap], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestationLimit_ModifyLimitCapability_unpack($struct: $Value) returns (cap: $Value)
{
    assume is#$Vector($struct);
    cap := $SelectField($struct, $DualAttestationLimit_ModifyLimitCapability_cap);
    assume $LibraConfig_ModifyConfigCapability_is_well_formed(cap);
}

const unique $DualAttestationLimit_UpdateDualAttestationThreshold: $TypeName;
const $DualAttestationLimit_UpdateDualAttestationThreshold_dummy_field: $FieldName;
axiom $DualAttestationLimit_UpdateDualAttestationThreshold_dummy_field == 0;
function $DualAttestationLimit_UpdateDualAttestationThreshold_type_value(): $TypeValue {
    $StructType($DualAttestationLimit_UpdateDualAttestationThreshold, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $DualAttestationLimit_UpdateDualAttestationThreshold_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $DualAttestationLimit_UpdateDualAttestationThreshold_dummy_field))
}
function {:inline} $DualAttestationLimit_UpdateDualAttestationThreshold_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $DualAttestationLimit_UpdateDualAttestationThreshold_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $DualAttestationLimit_UpdateDualAttestationThreshold_is_well_formed($ResourceValue(m, $DualAttestationLimit_UpdateDualAttestationThreshold_type_value(), a))
);

procedure {:inline 1} $DualAttestationLimit_UpdateDualAttestationThreshold_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestationLimit_UpdateDualAttestationThreshold_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $DualAttestationLimit_UpdateDualAttestationThreshold_dummy_field);
    assume is#$Boolean(dummy_field);
}



// ** functions of module DualAttestationLimit

procedure {:inline 1} $DualAttestationLimit_initialize_def(lr_account: $Value, tc_account: $Value) returns (){
    // declare local variables
    var cap: $Value; // $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $DualAttestationLimit_DualAttestationLimit_type_value()
    var $t25: $Value; // $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())
    var $t28: $Value; // $DualAttestationLimit_ModifyLimitCapability_type_value()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 830, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(8, 830, 1, tc_account); }

    // bytecode translation starts here
    // $t29 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t29 := $tmp;

    // $t30 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t30 := $tmp;

    // $t7 := LibraTimestamp::is_genesis()
    call $t7 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 950);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t3 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(8, 927, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(8, 927); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t12 := $tmp;

    // $t13 := Signer::address_of($t12)
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1002);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t14 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1043);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := ==($t13, $t14)
    $tmp := $Boolean($IsEqual($t13, $t14));
    $t15 := $tmp;

    // $t5 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(8, 987, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t17 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t17 := $tmp;

    // destroy($t17)

    // $t18 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t18 := $tmp;

    // destroy($t18)

    // $t19 := 1
    $tmp := $Integer(1);
    $t19 := $tmp;

    // abort($t19)
    if (true) { assume $DebugTrackAbort(8, 987); }
    goto Abort;

    // L2:
L2:

    // $t20 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t20 := $tmp;

    // $t21 := 1000
    $tmp := $Integer(1000);
    $t21 := $tmp;

    // $t22 := Libra::scaling_factor<LBR::LBR>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t22 := $Libra_scaling_factor($LBR_LBR_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1309);
      goto Abort;
    }
    assume $IsValidU64($t22);


    // $t23 := *($t21, $t22)
    call $tmp := $MulU64($t21, $t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1300);
      goto Abort;
    }
    $t23 := $tmp;

    // $t24 := pack DualAttestationLimit::DualAttestationLimit($t23)
    call $tmp := $DualAttestationLimit_DualAttestationLimit_pack(0, 0, 0, $t23);
    $t24 := $tmp;

    // $t25 := LibraConfig::publish_new_config_with_capability<DualAttestationLimit::DualAttestationLimit>($t20, $t24)
    call $t25 := $LibraConfig_publish_new_config_with_capability($DualAttestationLimit_DualAttestationLimit_type_value(), $t20, $t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1131);
      goto Abort;
    }
    assume $LibraConfig_ModifyConfigCapability_is_well_formed($t25);


    // cap := $t25
    call $tmp := $CopyOrMoveValue($t25);
    cap := $tmp;
    if (true) { assume $DebugTrackLocal(8, 1112, 2, $tmp); }

    // $t26 := move($t30)
    call $tmp := $CopyOrMoveValue($t30);
    $t26 := $tmp;

    // $t28 := pack DualAttestationLimit::ModifyLimitCapability(cap)
    call $tmp := $DualAttestationLimit_ModifyLimitCapability_pack(0, 0, 0, cap);
    $t28 := $tmp;

    // move_to<DualAttestationLimit::ModifyLimitCapability>($t28, $t26)
    call $MoveTo($DualAttestationLimit_ModifyLimitCapability_type_value(), $t28, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1353);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestationLimit_initialize(lr_account: $Value, tc_account: $Value) returns ()
free requires is#$Address(lr_account);
free requires is#$Address(tc_account);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn)))));
{
    call $DualAttestationLimit_initialize_def(lr_account, tc_account);
}

procedure {:inline 1} $DualAttestationLimit_get_cur_microlibra_limit_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $DualAttestationLimit_DualAttestationLimit_type_value()
    var $t1: $Value; // $DualAttestationLimit_DualAttestationLimit_type_value()
    var $t2: $Value; // $DualAttestationLimit_DualAttestationLimit_type_value()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t1 := LibraConfig::get<DualAttestationLimit::DualAttestationLimit>()
    call $t1 := $LibraConfig_get($DualAttestationLimit_DualAttestationLimit_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1527);
      goto Abort;
    }
    assume $DualAttestationLimit_DualAttestationLimit_is_well_formed($t1);


    // $t0 := $t1
    call $tmp := $CopyOrMoveValue($t1);
    $t0 := $tmp;
    if (true) { assume $DebugTrackLocal(8, 1514, 0, $tmp); }

    // $t2 := copy($t0)
    call $tmp := $CopyOrMoveValue($t0);
    $t2 := $tmp;

    // $t3 := get_field<DualAttestationLimit::DualAttestationLimit>.micro_lbr_limit($t2)
    call $tmp := $GetFieldFromValue($t2, $DualAttestationLimit_DualAttestationLimit_micro_lbr_limit);
    assume $IsValidU64($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(8, 1514, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestationLimit_get_cur_microlibra_limit() returns ($ret0: $Value)
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn)))));
{
    call $ret0 := $DualAttestationLimit_get_cur_microlibra_limit_def();
}

procedure {:inline 1} $DualAttestationLimit_set_microlibra_limit_def(tc_account: $Value, micro_lbr_limit: $Value) returns (){
    // declare local variables
    var modify_cap: $Value; // $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())
    var tc_address: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $DualAttestationLimit_ModifyLimitCapability_type_value()
    var $t23: $Value; // $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())
    var $t24: $Value; // $LibraConfig_ModifyConfigCapability_type_value($DualAttestationLimit_DualAttestationLimit_type_value())
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $DualAttestationLimit_DualAttestationLimit_type_value()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(8, 1582, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(8, 1582, 1, micro_lbr_limit); }

    // bytecode translation starts here
    // $t27 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t27 := $tmp;

    // $t28 := move(micro_lbr_limit)
    call $tmp := $CopyOrMoveValue(micro_lbr_limit);
    $t28 := $tmp;

    // $t8 := copy($t27)
    call $tmp := $CopyOrMoveValue($t27);
    $t8 := $tmp;

    // $t9 := Roles::has_update_dual_attestation_threshold_privilege($t8)
    call $t9 := $Roles_has_update_dual_attestation_threshold_privilege($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1734);
      goto Abort;
    }
    assume is#$Boolean($t9);


    // $t4 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(8, 1720, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t11 := move($t27)
    call $tmp := $CopyOrMoveValue($t27);
    $t11 := $tmp;

    // destroy($t11)

    // $t12 := 2
    $tmp := $Integer(2);
    $t12 := $tmp;

    // abort($t12)
    if (true) { assume $DebugTrackAbort(8, 1720); }
    goto Abort;

    // L0:
L0:

    // $t14 := 1000
    $tmp := $Integer(1000);
    $t14 := $tmp;

    // $t15 := >=($t28, $t14)
    call $tmp := $Ge($t28, $t14);
    $t15 := $tmp;

    // $t6 := $t15
    call $tmp := $CopyOrMoveValue($t15);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(8, 1830, 6, $tmp); }

    // if ($t6) goto L2 else goto L3
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t17 := move($t27)
    call $tmp := $CopyOrMoveValue($t27);
    $t17 := $tmp;

    // destroy($t17)

    // $t18 := 3
    $tmp := $Integer(3);
    $t18 := $tmp;

    // abort($t18)
    if (true) { assume $DebugTrackAbort(8, 1830); }
    goto Abort;

    // L2:
L2:

    // $t19 := move($t27)
    call $tmp := $CopyOrMoveValue($t27);
    $t19 := $tmp;

    // $t20 := Signer::address_of($t19)
    call $t20 := $Signer_address_of($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1916);
      goto Abort;
    }
    assume is#$Address($t20);


    // tc_address := $t20
    call $tmp := $CopyOrMoveValue($t20);
    tc_address := $tmp;
    if (true) { assume $DebugTrackLocal(8, 1895, 3, $tmp); }

    // $t22 := get_global<DualAttestationLimit::ModifyLimitCapability>(tc_address)
    call $tmp := $GetGlobal(tc_address, $DualAttestationLimit_ModifyLimitCapability_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 1966);
      goto Abort;
    }
    assume $DualAttestationLimit_ModifyLimitCapability_is_well_formed($tmp);
    $t22 := $tmp;

    // $t23 := get_field<DualAttestationLimit::ModifyLimitCapability>.cap($t22)
    call $tmp := $GetFieldFromValue($t22, $DualAttestationLimit_ModifyLimitCapability_cap);
    assume $LibraConfig_ModifyConfigCapability_is_well_formed($tmp);
    $t23 := $tmp;

    // modify_cap := $t23
    call $tmp := $CopyOrMoveValue($t23);
    modify_cap := $tmp;
    if (true) { assume $DebugTrackLocal(8, 1952, 2, $tmp); }

    // $t24 := move(modify_cap)
    call $tmp := $CopyOrMoveValue(modify_cap);
    $t24 := $tmp;

    // $t26 := pack DualAttestationLimit::DualAttestationLimit($t28)
    call $tmp := $DualAttestationLimit_DualAttestationLimit_pack(0, 0, 0, $t28);
    $t26 := $tmp;

    // LibraConfig::set_with_capability<DualAttestationLimit::DualAttestationLimit>($t24, $t26)
    call $LibraConfig_set_with_capability($DualAttestationLimit_DualAttestationLimit_type_value(), $t24, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(8, 2041);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestationLimit_set_microlibra_limit(tc_account: $Value, micro_lbr_limit: $Value) returns ()
free requires is#$Address(tc_account);
free requires $IsValidU64(micro_lbr_limit);
requires b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn)))));
{
    call $DualAttestationLimit_set_microlibra_limit_def(tc_account, micro_lbr_limit);
}



// ** spec vars of module DualAttestation



// ** spec funs of module DualAttestation

function {:inline} $DualAttestation_spec_compliance_public_key($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $SelectField($ResourceValue($m, $DualAttestation_Credential_type_value(), addr), $DualAttestation_Credential_compliance_public_key)
}

function {:inline} $DualAttestation_spec_cert_lifetime(): $Value {
    $Integer(31540000000000)
}

function {:inline} $DualAttestation_spec_dual_attestation_required($m: $Memory, $txn: $Transaction, $tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value): $Value {
    $Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(b#$Boolean($Boolean(i#$Integer($Libra_spec_approx_lbr_for_value($m, $txn, $tv0, deposit_value)) >= i#$Integer($DualAttestationLimit_spec_get_cur_microlibra_limit($m, $txn)))) && b#$Boolean($VASP_spec_is_vasp($m, $txn, payer)))) && b#$Boolean($VASP_spec_is_vasp($m, $txn, payee)))) && b#$Boolean($Boolean(!$IsEqual($VASP_spec_parent_address($m, $txn, payer), $VASP_spec_parent_address($m, $txn, payee)))))
}

function {:inline} $DualAttestation_spec_dual_attestation_message(payer: $Value, metadata: $Value, deposit_value: $Value): $Value;
axiom (forall payer: $Value, metadata: $Value, deposit_value: $Value :: $Vector_is_well_formed($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)) && (forall $$0: int :: {$select_vector($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value),$$0)} $$0 >= 0 && $$0 < $vlen($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)) ==> $IsValidU8($select_vector($DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value),$$0))));
function {:inline} $DualAttestation_signature_is_valid($m: $Memory, $txn: $Transaction, payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value): $Value {
    $Boolean(b#$Boolean($Boolean($IsEqual($vlen_value(metadata_signature), $Integer(64)))) && b#$Boolean($Signature_spec_ed25519_verify($m, $txn, metadata_signature, $DualAttestation_spec_compliance_public_key($m, $txn, payee), $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value))))
}



// ** structs of module DualAttestation

const unique $DualAttestation_Credential: $TypeName;
const $DualAttestation_Credential_human_name: $FieldName;
axiom $DualAttestation_Credential_human_name == 0;
const $DualAttestation_Credential_base_url: $FieldName;
axiom $DualAttestation_Credential_base_url == 1;
const $DualAttestation_Credential_compliance_public_key: $FieldName;
axiom $DualAttestation_Credential_compliance_public_key == 2;
const $DualAttestation_Credential_expiration_date: $FieldName;
axiom $DualAttestation_Credential_expiration_date == 3;
function $DualAttestation_Credential_type_value(): $TypeValue {
    $StructType($DualAttestation_Credential, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($IntegerType())][1 := $Vector_type_value($IntegerType())][2 := $Vector_type_value($IntegerType())][3 := $IntegerType()], 4))
}
function {:inline} $DualAttestation_Credential_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_human_name)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_human_name),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_human_name),$$0)))
      && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_base_url)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_base_url),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_base_url)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_base_url),$$0)))
      && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_compliance_public_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_compliance_public_key)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key),$$0)))
      && $IsValidU64($SelectField($this, $DualAttestation_Credential_expiration_date))
}
function {:inline} $DualAttestation_Credential_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_human_name)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_human_name),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_human_name)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_human_name),$$0)))
      && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_base_url)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_base_url),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_base_url)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_base_url),$$0)))
      && $Vector_is_well_formed($SelectField($this, $DualAttestation_Credential_compliance_public_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $DualAttestation_Credential_compliance_public_key)) ==> $IsValidU8($select_vector($SelectField($this, $DualAttestation_Credential_compliance_public_key),$$0)))
      && $IsValidU64($SelectField($this, $DualAttestation_Credential_expiration_date))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $DualAttestation_Credential_is_well_formed($ResourceValue(m, $DualAttestation_Credential_type_value(), a))
);

procedure {:inline 1} $DualAttestation_Credential_pack($file_id: int, $byte_index: int, $var_idx: int, human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {$select_vector(base_url,$$0)} $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url,$$0)));
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {$select_vector(compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key,$$0)));
    assume $IsValidU64(expiration_date);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := human_name][1 := base_url][2 := compliance_public_key][3 := expiration_date], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $DualAttestation_Credential_unpack($struct: $Value) returns (human_name: $Value, base_url: $Value, compliance_public_key: $Value, expiration_date: $Value)
{
    assume is#$Vector($struct);
    human_name := $SelectField($struct, $DualAttestation_Credential_human_name);
    assume $Vector_is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
    base_url := $SelectField($struct, $DualAttestation_Credential_base_url);
    assume $Vector_is_well_formed(base_url) && (forall $$0: int :: {$select_vector(base_url,$$0)} $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url,$$0)));
    compliance_public_key := $SelectField($struct, $DualAttestation_Credential_compliance_public_key);
    assume $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {$select_vector(compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key,$$0)));
    expiration_date := $SelectField($struct, $DualAttestation_Credential_expiration_date);
    assume $IsValidU64(expiration_date);
}



// ** functions of module DualAttestation

procedure {:inline 1} $DualAttestation_assert_payment_ok_def($tv0: $TypeValue, payer: $Value, payee: $Value, value_microlibra: $Value, metadata: $Value, metadata_signature: $Value) returns (){
    // declare local variables
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $Vector_type_value($IntegerType())
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 12113, 0, payer); }
    if (true) { assume $DebugTrackLocal(7, 12113, 1, payee); }
    if (true) { assume $DebugTrackLocal(7, 12113, 2, value_microlibra); }
    if (true) { assume $DebugTrackLocal(7, 12113, 3, metadata); }
    if (true) { assume $DebugTrackLocal(7, 12113, 4, metadata_signature); }

    // bytecode translation starts here
    // $t14 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t14 := $tmp;

    // $t15 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t15 := $tmp;

    // $t16 := move(value_microlibra)
    call $tmp := $CopyOrMoveValue(value_microlibra);
    $t16 := $tmp;

    // $t17 := move(metadata)
    call $tmp := $CopyOrMoveValue(metadata);
    $t17 := $tmp;

    // $t18 := move(metadata_signature)
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t18 := $tmp;

    // $t8 := DualAttestation::dual_attestation_required<#0>($t14, $t15, $t16)
    call $t8 := $DualAttestation_dual_attestation_required($tv0, $t14, $t15, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 6860);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // if ($t8) goto L0 else goto L1
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // DualAttestation::assert_signature_is_valid($t14, $t15, $t18, $t17, $t16)
    call $DualAttestation_assert_signature_is_valid($t14, $t15, $t18, $t17, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 9912);
      goto Abort;
    }

    // goto L2
    goto L2;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestation_assert_payment_ok($tv0: $TypeValue, payer: $Value, payee: $Value, value_microlibra: $Value, metadata: $Value, metadata_signature: $Value) returns ()
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $IsValidU64(value_microlibra);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {$select_vector(metadata_signature,$$0)} $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature,$$0)));
{
    call $DualAttestation_assert_payment_ok_def($tv0, payer, payee, value_microlibra, metadata, metadata_signature);
}

procedure {:inline 1} $DualAttestation_assert_signature_is_valid_def(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value) returns (){
    // declare local variables
    var message: $Value; // $Vector_type_value($IntegerType())
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $Vector_type_value($IntegerType())
    var $t23: $Value; // $Vector_type_value($IntegerType())
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $Vector_type_value($IntegerType())
    var $t30: $Value; // $Vector_type_value($IntegerType())
    var $t31: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 9901, 0, payer); }
    if (true) { assume $DebugTrackLocal(7, 9901, 1, payee); }
    if (true) { assume $DebugTrackLocal(7, 9901, 2, metadata_signature); }
    if (true) { assume $DebugTrackLocal(7, 9901, 3, metadata); }
    if (true) { assume $DebugTrackLocal(7, 9901, 4, deposit_value); }

    // bytecode translation starts here
    // $t27 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t27 := $tmp;

    // $t28 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t28 := $tmp;

    // $t29 := move(metadata_signature)
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t29 := $tmp;

    // $t30 := move(metadata)
    call $tmp := $CopyOrMoveValue(metadata);
    $t30 := $tmp;

    // $t31 := move(deposit_value)
    call $tmp := $CopyOrMoveValue(deposit_value);
    $t31 := $tmp;

    // $t10 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t10 := $tmp;

    // $t11 := Vector::length<u8>($t10)
    call $t11 := $Vector_length($IntegerType(), $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10181);
      goto Abort;
    }
    assume $IsValidU64($t11);


    // $t12 := 64
    $tmp := $Integer(64);
    $t12 := $tmp;

    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t6 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 10166, 6, $tmp); }

    // if ($t6) goto L0 else goto L1
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t15 := 4
    $tmp := $Integer(4);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(7, 10166); }
    goto Abort;

    // L0:
L0:

    // $t19 := DualAttestation::dual_attestation_message($t27, $t30, $t31)
    call $t19 := $DualAttestation_dual_attestation_message($t27, $t30, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8667);
      goto Abort;
    }
    assume $Vector_is_well_formed($t19) && (forall $$0: int :: {$select_vector($t19,$$0)} $$0 >= 0 && $$0 < $vlen($t19) ==> $IsValidU8($select_vector($t19,$$0)));


    // message := $t19
    call $tmp := $CopyOrMoveValue($t19);
    message := $tmp;
    if (true) { assume $DebugTrackLocal(7, 10313, 5, $tmp); }

    // $t22 := DualAttestation::compliance_public_key($t28)
    call $t22 := $DualAttestation_compliance_public_key($t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 4702);
      goto Abort;
    }
    assume $Vector_is_well_formed($t22) && (forall $$0: int :: {$select_vector($t22,$$0)} $$0 >= 0 && $$0 < $vlen($t22) ==> $IsValidU8($select_vector($t22,$$0)));


    // $t24 := Signature::ed25519_verify($t29, $t22, message)
    call $t24 := $Signature_ed25519_verify($t29, $t22, message);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 10420);
      goto Abort;
    }
    assume is#$Boolean($t24);


    // $t8 := $t24
    call $tmp := $CopyOrMoveValue($t24);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 10389, 8, $tmp); }

    // if ($t8) goto L2 else goto L3
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t26 := 5
    $tmp := $Integer(5);
    $t26 := $tmp;

    // abort($t26)
    if (true) { assume $DebugTrackAbort(7, 10389); }
    goto Abort;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestation_assert_signature_is_valid(payer: $Value, payee: $Value, metadata_signature: $Value, metadata: $Value, deposit_value: $Value) returns ();
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {$select_vector(metadata_signature,$$0)} $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature,$$0)));
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $IsValidU64(deposit_value);
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $DualAttestation_Credential_type_value(), payee))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestation_signature_is_valid($m, $txn, payer, payee, metadata_signature, metadata, deposit_value))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $DualAttestation_Credential_type_value(), payee))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($DualAttestation_signature_is_valid($m, $txn, payer, payee, metadata_signature, metadata, deposit_value)))))));
procedure {:inline 1} $DualAttestation_base_url_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $DualAttestation_Credential_type_value()
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $Vector_type_value($IntegerType())
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 4443, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<DualAttestation::Credential>($t5)
    call $tmp := $GetGlobal($t5, $DualAttestation_Credential_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 4522);
      goto Abort;
    }
    assume $DualAttestation_Credential_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<DualAttestation::Credential>.base_url($t2)
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_base_url);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(7, 4520, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_base_url(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $DualAttestation_base_url_def(addr);
}

procedure {:inline 1} $DualAttestation_cert_lifetime_def() returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := 31540000000000
    $tmp := $Integer(31540000000000);
    $t0 := $tmp;

    // return $t0
    $ret0 := $t0;
    if (true) { assume $DebugTrackLocal(7, 6427, 1, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_cert_lifetime() returns ($ret0: $Value)
{
    call $ret0 := $DualAttestation_cert_lifetime_def();
}

procedure {:inline 1} $DualAttestation_compliance_public_key_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $DualAttestation_Credential_type_value()
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $Vector_type_value($IntegerType())
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 4691, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<DualAttestation::Credential>($t5)
    call $tmp := $GetGlobal($t5, $DualAttestation_Credential_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 4783);
      goto Abort;
    }
    assume $DualAttestation_Credential_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<DualAttestation::Credential>.compliance_public_key($t2)
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_compliance_public_key);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(7, 4781, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_compliance_public_key(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $DualAttestation_compliance_public_key_def(addr);
}

procedure {:inline 1} $DualAttestation_decertify_def(credential: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Reference; // ReferenceType($DualAttestation_Credential_type_value())
    var $t3: $Reference; // ReferenceType($IntegerType())
    var $t4: $Value; // $DualAttestation_Credential_type_value()
    var $t5: $Reference; // ReferenceType($DualAttestation_Credential_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 6112, 0, credential); }

    // bytecode translation starts here
    // $t4 := move(credential)
    call $tmp := $CopyOrMoveValue(credential);
    $t4 := $tmp;

    // $t5 := borrow_local($t4)
    call $t5 := $BorrowLoc(4, $t4);
    assume $DualAttestation_Credential_is_well_formed($Dereference($t5));

    // UnpackRef($t5)

    // $t1 := 0
    $tmp := $Integer(0);
    $t1 := $tmp;

    // $t2 := move($t5)
    call $t2 := $CopyOrMoveRef($t5);

    // $t3 := borrow_field<DualAttestation::Credential>.expiration_date($t2)
    call $t3 := $BorrowField($t2, $DualAttestation_Credential_expiration_date);
    assume $IsValidU64($Dereference($t3));

    // LocalRoot($t4) <- $t2
    call $t4 := $WritebackToValue($t2, 4, $t4);

    // UnpackRef($t3)

    // write_ref($t3, $t1)
    call $t3 := $WriteRef($t3, $t1);

    // LocalRoot($t4) <- $t3
    call $t4 := $WritebackToValue($t3, 4, $t4);

    // Reference($t2) <- $t3
    call $t2 := $WritebackToReference($t3, $t2);

    // PackRef($t2)

    // PackRef($t3)

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(7, 6243, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_decertify(credential: $Value) returns ($ret0: $Value)
free requires $DualAttestation_Credential_is_well_formed(credential);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $DualAttestation_Credential_expiration_date), $Integer(0)))));
{
    call $ret0 := $DualAttestation_decertify_def(credential);
}

procedure {:inline 1} $DualAttestation_dual_attestation_message_def(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value){
    // declare local variables
    var message: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $Vector_type_value($IntegerType())
    var $t5: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $Vector_type_value($IntegerType())
    var $t8: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $Vector_type_value($IntegerType())
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 8656, 0, payer); }
    if (true) { assume $DebugTrackLocal(7, 8656, 1, metadata); }
    if (true) { assume $DebugTrackLocal(7, 8656, 2, deposit_value); }

    // bytecode translation starts here
    // $t14 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t14 := $tmp;

    // $t15 := move(metadata)
    call $tmp := $CopyOrMoveValue(metadata);
    $t15 := $tmp;

    // $t16 := move(deposit_value)
    call $tmp := $CopyOrMoveValue(deposit_value);
    $t16 := $tmp;

    // message := $t15
    call $tmp := $CopyOrMoveValue($t15);
    message := $tmp;
    if (true) { assume $DebugTrackLocal(7, 8790, 3, $tmp); }

    // $t5 := borrow_local(message)
    call $t5 := $BorrowLoc(3, message);
    assume $Vector_is_well_formed($Dereference($t5)) && (forall $$1: int :: {$select_vector($Dereference($t5),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t5)) ==> $IsValidU8($select_vector($Dereference($t5),$$1)));

    // UnpackRef($t5)

    // $t6 := copy($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;

    // $t7 := LCS::to_bytes<address>($t6)
    call $t7 := $LCS_to_bytes($AddressType(), $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8852);
      goto Abort;
    }
    assume $Vector_is_well_formed($t7) && (forall $$0: int :: {$select_vector($t7,$$0)} $$0 >= 0 && $$0 < $vlen($t7) ==> $IsValidU8($select_vector($t7,$$0)));


    // PackRef($t5)

    // $t17 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t17 := $tmp;

    // $t17 := Vector::append<u8>($t17, $t7)
    call $t17 := $Vector_append($IntegerType(), $t17, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8826);
      goto Abort;
    }
    assume $Vector_is_well_formed($t17) && (forall $$0: int :: {$select_vector($t17,$$0)} $$0 >= 0 && $$0 < $vlen($t17) ==> $IsValidU8($select_vector($t17,$$0)));


    // write_ref($t5, $t17)
    call $t5 := $WriteRef($t5, $t17);

    // LocalRoot(message) <- $t5
    call message := $WritebackToValue($t5, 3, message);

    // UnpackRef($t5)

    // PackRef($t5)

    // $t8 := borrow_local(message)
    call $t8 := $BorrowLoc(3, message);
    assume $Vector_is_well_formed($Dereference($t8)) && (forall $$1: int :: {$select_vector($Dereference($t8),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t8)) ==> $IsValidU8($select_vector($Dereference($t8),$$1)));

    // UnpackRef($t8)

    // $t9 := copy($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;

    // $t10 := LCS::to_bytes<u64>($t9)
    call $t10 := $LCS_to_bytes($IntegerType(), $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8913);
      goto Abort;
    }
    assume $Vector_is_well_formed($t10) && (forall $$0: int :: {$select_vector($t10,$$0)} $$0 >= 0 && $$0 < $vlen($t10) ==> $IsValidU8($select_vector($t10,$$0)));


    // PackRef($t8)

    // $t17 := read_ref($t8)
    call $tmp := $ReadRef($t8);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t17 := $tmp;

    // $t17 := Vector::append<u8>($t17, $t10)
    call $t17 := $Vector_append($IntegerType(), $t17, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8887);
      goto Abort;
    }
    assume $Vector_is_well_formed($t17) && (forall $$0: int :: {$select_vector($t17,$$0)} $$0 >= 0 && $$0 < $vlen($t17) ==> $IsValidU8($select_vector($t17,$$0)));


    // write_ref($t8, $t17)
    call $t8 := $WriteRef($t8, $t17);

    // LocalRoot(message) <- $t8
    call message := $WritebackToValue($t8, 3, message);

    // UnpackRef($t8)

    // PackRef($t8)

    // $t11 := borrow_local(message)
    call $t11 := $BorrowLoc(3, message);
    assume $Vector_is_well_formed($Dereference($t11)) && (forall $$1: int :: {$select_vector($Dereference($t11),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t11)) ==> $IsValidU8($select_vector($Dereference($t11),$$1)));

    // UnpackRef($t11)

    // $t12 := [64, 64, 36, 36, 76, 73, 66, 82, 65, 95, 65, 84, 84, 69, 83, 84, 36, 36, 64, 64]
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := $Integer(64)][1 := $Integer(64)][2 := $Integer(36)][3 := $Integer(36)][4 := $Integer(76)][5 := $Integer(73)][6 := $Integer(66)][7 := $Integer(82)][8 := $Integer(65)][9 := $Integer(95)][10 := $Integer(65)][11 := $Integer(84)][12 := $Integer(84)][13 := $Integer(69)][14 := $Integer(83)][15 := $Integer(84)][16 := $Integer(36)][17 := $Integer(36)][18 := $Integer(64)][19 := $Integer(64)], 20));
    $t12 := $tmp;

    // PackRef($t11)

    // $t17 := read_ref($t11)
    call $tmp := $ReadRef($t11);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t17 := $tmp;

    // $t17 := Vector::append<u8>($t17, $t12)
    call $t17 := $Vector_append($IntegerType(), $t17, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 8956);
      goto Abort;
    }
    assume $Vector_is_well_formed($t17) && (forall $$0: int :: {$select_vector($t17,$$0)} $$0 >= 0 && $$0 < $vlen($t17) ==> $IsValidU8($select_vector($t17,$$0)));


    // write_ref($t11, $t17)
    call $t11 := $WriteRef($t11, $t17);

    // LocalRoot(message) <- $t11
    call message := $WritebackToValue($t11, 3, message);

    // UnpackRef($t11)

    // PackRef($t11)

    // return message
    $ret0 := message;
    if (true) { assume $DebugTrackLocal(7, 9004, 18, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_dual_attestation_message(payer: $Value, metadata: $Value, deposit_value: $Value) returns ($ret0: $Value);
free requires is#$Address(payer);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $IsValidU64(deposit_value);
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_message(payer, metadata, deposit_value)))));
procedure {:inline 1} $DualAttestation_dual_attestation_required_def($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value){
    // declare local variables
    var above_threshold: $Value; // $BooleanType()
    var approx_lbr_microlibra_value: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var travel_rule_limit_microlibra: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $AddressType()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 6849, 0, payer); }
    if (true) { assume $DebugTrackLocal(7, 6849, 1, payee); }
    if (true) { assume $DebugTrackLocal(7, 6849, 2, deposit_value); }

    // bytecode translation starts here
    // $t31 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t31 := $tmp;

    // $t32 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t32 := $tmp;

    // $t33 := move(deposit_value)
    call $tmp := $CopyOrMoveValue(deposit_value);
    $t33 := $tmp;

    // $t9 := DualAttestationLimit::get_cur_microlibra_limit()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraTimestamp_spec_is_genesis($m, $txn)))) ==> b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))));
    call $t9 := $DualAttestationLimit_get_cur_microlibra_limit();
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7093);
      goto Abort;
    }
    assume $IsValidU64($t9);


    // travel_rule_limit_microlibra := $t9
    call $tmp := $CopyOrMoveValue($t9);
    travel_rule_limit_microlibra := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7040, 8, $tmp); }

    // $t11 := Libra::approx_lbr_for_value<#0>($t33)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t11 := $Libra_approx_lbr_for_value($tv0, $t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7170);
      goto Abort;
    }
    assume $IsValidU64($t11);


    // approx_lbr_microlibra_value := $t11
    call $tmp := $CopyOrMoveValue($t11);
    approx_lbr_microlibra_value := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7133, 4, $tmp); }

    // $t14 := >=(approx_lbr_microlibra_value, travel_rule_limit_microlibra)
    call $tmp := $Ge(approx_lbr_microlibra_value, travel_rule_limit_microlibra);
    $t14 := $tmp;

    // above_threshold := $t14
    call $tmp := $CopyOrMoveValue($t14);
    above_threshold := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7226, 3, $tmp); }

    // if (above_threshold) goto L0 else goto L1
    $tmp := above_threshold;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t17 := VASP::is_vasp($t31)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t17 := $VASP_is_vasp($t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7466);
      goto Abort;
    }
    assume is#$Boolean($t17);


    // $t5 := $t17
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7429, 5, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t18 := false
    $tmp := $Boolean(false);
    $t18 := $tmp;

    // $t5 := $t18
    call $tmp := $CopyOrMoveValue($t18);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7429, 5, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // if ($t5) goto L4 else goto L5
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // goto L6
    goto L6;

    // L4:
L4:

    // $t21 := VASP::is_vasp($t32)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t21 := $VASP_is_vasp($t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7490);
      goto Abort;
    }
    assume is#$Boolean($t21);


    // $t6 := $t21
    call $tmp := $CopyOrMoveValue($t21);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7429, 6, $tmp); }

    // goto L7
    goto L7;

    // L6:
L6:

    // $t22 := false
    $tmp := $Boolean(false);
    $t22 := $tmp;

    // $t6 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7429, 6, $tmp); }

    // goto L7
    goto L7;

    // L7:
L7:

    // if ($t6) goto L8 else goto L9
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // goto L10
    goto L10;

    // L8:
L8:

    // $t25 := VASP::parent_address($t31)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t25 := $VASP_parent_address($t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7526);
      goto Abort;
    }
    assume is#$Address($t25);


    // $t27 := VASP::parent_address($t32)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t27 := $VASP_parent_address($t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 7557);
      goto Abort;
    }
    assume is#$Address($t27);


    // $t28 := !=($t25, $t27)
    $tmp := $Boolean(!$IsEqual($t25, $t27));
    $t28 := $tmp;

    // $t7 := $t28
    call $tmp := $CopyOrMoveValue($t28);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7429, 7, $tmp); }

    // goto L11
    goto L11;

    // L10:
L10:

    // $t29 := false
    $tmp := $Boolean(false);
    $t29 := $tmp;

    // $t7 := $t29
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 7429, 7, $tmp); }

    // goto L11
    goto L11;

    // L11:
L11:

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(7, 7429, 34, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_dual_attestation_required($tv0: $TypeValue, payer: $Value, payee: $Value, deposit_value: $Value) returns ($ret0: $Value);
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $IsValidU64(deposit_value);
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $DualAttestation_spec_dual_attestation_required($m, $txn, $tv0, payer, payee, deposit_value)))));
procedure {:inline 1} $DualAttestation_expiration_date_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $DualAttestation_Credential_type_value()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 5176, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<DualAttestation::Credential>($t5)
    call $tmp := $GetGlobal($t5, $DualAttestation_Credential_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5256);
      goto Abort;
    }
    assume $DualAttestation_Credential_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<DualAttestation::Credential>.expiration_date($t2)
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_expiration_date);
    assume $IsValidU64($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(7, 5254, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_expiration_date(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $DualAttestation_expiration_date_def(addr);
}

procedure {:inline 1} $DualAttestation_human_name_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $DualAttestation_Credential_type_value()
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $Vector_type_value($IntegerType())
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 4204, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<DualAttestation::Credential>($t5)
    call $tmp := $GetGlobal($t5, $DualAttestation_Credential_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 4285);
      goto Abort;
    }
    assume $DualAttestation_Credential_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<DualAttestation::Credential>.human_name($t2)
    call $tmp := $GetFieldFromValue($t2, $DualAttestation_Credential_human_name);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(7, 4283, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_human_name(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $DualAttestation_human_name_def(addr);
}

procedure {:inline 1} $DualAttestation_publish_credential_def(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value) returns (){
    // declare local variables
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Value; // $AddressType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $Vector_type_value($IntegerType())
    var $t34: $Value; // $Vector_type_value($IntegerType())
    var $t35: $Value; // $Vector_type_value($IntegerType())
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $DualAttestation_Credential_type_value()
    var $t38: $Value; // $AddressType()
    var $t39: $Value; // $AddressType()
    var $t40: $Value; // $Vector_type_value($IntegerType())
    var $t41: $Value; // $Vector_type_value($IntegerType())
    var $t42: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 2105, 0, created); }
    if (true) { assume $DebugTrackLocal(7, 2105, 1, creator); }
    if (true) { assume $DebugTrackLocal(7, 2105, 2, human_name); }
    if (true) { assume $DebugTrackLocal(7, 2105, 3, base_url); }
    if (true) { assume $DebugTrackLocal(7, 2105, 4, compliance_public_key); }

    // bytecode translation starts here
    // $t38 := move(created)
    call $tmp := $CopyOrMoveValue(created);
    $t38 := $tmp;

    // $t39 := move(creator)
    call $tmp := $CopyOrMoveValue(creator);
    $t39 := $tmp;

    // $t40 := move(human_name)
    call $tmp := $CopyOrMoveValue(human_name);
    $t40 := $tmp;

    // $t41 := move(base_url)
    call $tmp := $CopyOrMoveValue(base_url);
    $t41 := $tmp;

    // $t42 := move(compliance_public_key)
    call $tmp := $CopyOrMoveValue(compliance_public_key);
    $t42 := $tmp;

    // $t12 := copy($t38)
    call $tmp := $CopyOrMoveValue($t38);
    $t12 := $tmp;

    // $t13 := Roles::has_parent_VASP_role($t12)
    call $t13 := $Roles_has_parent_VASP_role($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 2336);
      goto Abort;
    }
    assume is#$Boolean($t13);


    // if ($t13) goto L0 else goto L1
    $tmp := $t13;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t14 := true
    $tmp := $Boolean(true);
    $t14 := $tmp;

    // $t7 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 2329, 7, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t15 := copy($t38)
    call $tmp := $CopyOrMoveValue($t38);
    $t15 := $tmp;

    // $t16 := Roles::has_designated_dealer_role($t15)
    call $t16 := $Roles_has_designated_dealer_role($t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 2376);
      goto Abort;
    }
    assume is#$Boolean($t16);


    // $t7 := $t16
    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 2329, 7, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // $t5 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 2309, 5, $tmp); }

    // if ($t5) goto L4 else goto L5
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t19 := move($t39)
    call $tmp := $CopyOrMoveValue($t39);
    $t19 := $tmp;

    // destroy($t19)

    // $t20 := move($t38)
    call $tmp := $CopyOrMoveValue($t38);
    $t20 := $tmp;

    // destroy($t20)

    // $t21 := 0
    $tmp := $Integer(0);
    $t21 := $tmp;

    // abort($t21)
    if (true) { assume $DebugTrackAbort(7, 2309); }
    goto Abort;

    // L4:
L4:

    // $t22 := move($t39)
    call $tmp := $CopyOrMoveValue($t39);
    $t22 := $tmp;

    // $t23 := Roles::has_libra_root_role($t22)
    call $t23 := $Roles_has_libra_root_role($t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 2481);
      goto Abort;
    }
    assume is#$Boolean($t23);


    // $t8 := $t23
    call $tmp := $CopyOrMoveValue($t23);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 2467, 8, $tmp); }

    // if ($t8) goto L6 else goto L7
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // $t25 := move($t38)
    call $tmp := $CopyOrMoveValue($t38);
    $t25 := $tmp;

    // destroy($t25)

    // $t26 := 1
    $tmp := $Integer(1);
    $t26 := $tmp;

    // abort($t26)
    if (true) { assume $DebugTrackAbort(7, 2467); }
    goto Abort;

    // L6:
L6:

    // $t28 := Signature::ed25519_validate_pubkey($t42)
    call $t28 := $Signature_ed25519_validate_pubkey($t42);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 2555);
      goto Abort;
    }
    assume is#$Boolean($t28);


    // $t10 := $t28
    call $tmp := $CopyOrMoveValue($t28);
    $t10 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 2537, 10, $tmp); }

    // if ($t10) goto L8 else goto L9
    $tmp := $t10;
    if (b#$Boolean($tmp)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // $t30 := move($t38)
    call $tmp := $CopyOrMoveValue($t38);
    $t30 := $tmp;

    // destroy($t30)

    // $t31 := 2
    $tmp := $Integer(2);
    $t31 := $tmp;

    // abort($t31)
    if (true) { assume $DebugTrackAbort(7, 2537); }
    goto Abort;

    // L8:
L8:

    // $t32 := move($t38)
    call $tmp := $CopyOrMoveValue($t38);
    $t32 := $tmp;

    // $t36 := 18446744073709551615
    $tmp := $Integer(18446744073709551615);
    $t36 := $tmp;

    // $t37 := pack DualAttestation::Credential($t40, $t41, $t42, $t36)
    call $tmp := $DualAttestation_Credential_pack(0, 0, 0, $t40, $t41, $t42, $t36);
    $t37 := $tmp;

    // move_to<DualAttestation::Credential>($t37, $t32)
    call $MoveTo($DualAttestation_Credential_type_value(), $t37, $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 2638);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestation_publish_credential(created: $Value, creator: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value) returns ()
free requires is#$Address(created);
free requires is#$Address(creator);
free requires $Vector_is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
free requires $Vector_is_well_formed(base_url) && (forall $$0: int :: {$select_vector(base_url,$$0)} $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url,$$0)));
free requires $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {$select_vector(compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key,$$0)));
{
    call $DualAttestation_publish_credential_def(created, creator, human_name, base_url, compliance_public_key);
}

procedure {:inline 1} $DualAttestation_recertify_def(credential: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $IntegerType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Reference; // ReferenceType($DualAttestation_Credential_type_value())
    var $t5: $Reference; // ReferenceType($IntegerType())
    var $t6: $Value; // $DualAttestation_Credential_type_value()
    var $t7: $Reference; // ReferenceType($DualAttestation_Credential_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 5556, 0, credential); }

    // bytecode translation starts here
    // $t6 := move(credential)
    call $tmp := $CopyOrMoveValue(credential);
    $t6 := $tmp;

    // $t7 := borrow_local($t6)
    call $t7 := $BorrowLoc(6, $t6);
    assume $DualAttestation_Credential_is_well_formed($Dereference($t7));

    // UnpackRef($t7)

    // $t1 := LibraTimestamp::now_microseconds()
    call $t1 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5661);
      goto Abort;
    }
    assume $IsValidU64($t1);


    // $t2 := DualAttestation::cert_lifetime()
    call $t2 := $DualAttestation_cert_lifetime();
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 6396);
      goto Abort;
    }
    assume $IsValidU64($t2);


    // $t3 := +($t1, $t2)
    call $tmp := $AddU64($t1, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 5680);
      goto Abort;
    }
    $t3 := $tmp;

    // $t4 := move($t7)
    call $t4 := $CopyOrMoveRef($t7);

    // $t5 := borrow_field<DualAttestation::Credential>.expiration_date($t4)
    call $t5 := $BorrowField($t4, $DualAttestation_Credential_expiration_date);
    assume $IsValidU64($Dereference($t5));

    // LocalRoot($t6) <- $t4
    call $t6 := $WritebackToValue($t4, 6, $t6);

    // UnpackRef($t5)

    // write_ref($t5, $t3)
    call $t5 := $WriteRef($t5, $t3);

    // LocalRoot($t6) <- $t5
    call $t6 := $WritebackToValue($t5, 6, $t6);

    // Reference($t4) <- $t5
    call $t4 := $WritebackToReference($t5, $t4);

    // PackRef($t4)

    // PackRef($t5)

    // return $t6
    $ret0 := $t6;
    if (true) { assume $DebugTrackLocal(7, 5697, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $DualAttestation_recertify(credential: $Value) returns ($ret0: $Value)
free requires $DualAttestation_Credential_is_well_formed(credential);
free ensures b#$Boolean(old($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)) + i#$Integer($DualAttestation_spec_cert_lifetime()))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($LibraTimestamp_root_ctm_initialized($m, $txn))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)) + i#$Integer($DualAttestation_spec_cert_lifetime()))) > i#$Integer($Integer($MAX_U64)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ret0, $DualAttestation_Credential_expiration_date), $Integer(i#$Integer($LibraTimestamp_spec_now_microseconds($m, $txn)) + i#$Integer($DualAttestation_spec_cert_lifetime()))))));
{
    call $ret0 := $DualAttestation_recertify_def(credential);
}

procedure {:inline 1} $DualAttestation_rotate_base_url_def(account: $Value, new_url: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Reference; // ReferenceType($DualAttestation_Credential_type_value())
    var $t6: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 2945, 0, account); }
    if (true) { assume $DebugTrackLocal(7, 2945, 1, new_url); }

    // bytecode translation starts here
    // $t7 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t7 := $tmp;

    // $t8 := move(new_url)
    call $tmp := $CopyOrMoveValue(new_url);
    $t8 := $tmp;

    // $t3 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3079);
      goto Abort;
    }
    assume is#$Address($t4);


    // $t5 := borrow_global<DualAttestation::Credential>($t4)
    call $t5 := $BorrowGlobal($t4, $DualAttestation_Credential_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3041);
      goto Abort;
    }
    assume $DualAttestation_Credential_is_well_formed($Dereference($t5));

    // UnpackRef($t5)

    // $t6 := borrow_field<DualAttestation::Credential>.base_url($t5)
    call $t6 := $BorrowField($t5, $DualAttestation_Credential_base_url);
    assume $Vector_is_well_formed($Dereference($t6)) && (forall $$1: int :: {$select_vector($Dereference($t6),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t6)) ==> $IsValidU8($select_vector($Dereference($t6),$$1)));

    // DualAttestation::Credential <- $t5
    call $WritebackToGlobal($t5);

    // UnpackRef($t6)

    // write_ref($t6, $t8)
    call $t6 := $WriteRef($t6, $t8);

    // DualAttestation::Credential <- $t6
    call $WritebackToGlobal($t6);

    // Reference($t5) <- $t6
    call $t5 := $WritebackToReference($t6, $t5);

    // PackRef($t5)

    // PackRef($t6)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestation_rotate_base_url(account: $Value, new_url: $Value) returns ()
free requires is#$Address(account);
free requires $Vector_is_well_formed(new_url) && (forall $$0: int :: {$select_vector(new_url,$$0)} $$0 >= 0 && $$0 < $vlen(new_url) ==> $IsValidU8($select_vector(new_url,$$0)));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $DualAttestation_Credential_type_value(), $Signer_spec_address_of($m, $txn, account)))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $DualAttestation_Credential_type_value(), $Signer_spec_address_of($m, $txn, account))))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($m, $DualAttestation_Credential_type_value(), $Signer_spec_address_of($m, $txn, account)), $DualAttestation_Credential_base_url), new_url))));
{
    call $DualAttestation_rotate_base_url_def(account, new_url);
}

procedure {:inline 1} $DualAttestation_rotate_compliance_public_key_def(account: $Value, new_key: $Value) returns (){
    // declare local variables
    var parent_addr: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $Vector_type_value($IntegerType())
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $AddressType()
    var $t14: $Reference; // ReferenceType($DualAttestation_Credential_type_value())
    var $t15: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(7, 3411, 0, account); }
    if (true) { assume $DebugTrackLocal(7, 3411, 1, new_key); }

    // bytecode translation starts here
    // $t16 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t16 := $tmp;

    // $t17 := move(new_key)
    call $tmp := $CopyOrMoveValue(new_key);
    $t17 := $tmp;

    // $t6 := Signature::ed25519_validate_pubkey($t17)
    call $t6 := $Signature_ed25519_validate_pubkey($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3561);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(7, 3543, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 2
    $tmp := $Integer(2);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(7, 3543); }
    goto Abort;

    // L0:
L0:

    // $t10 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3656);
      goto Abort;
    }
    assume is#$Address($t11);


    // parent_addr := $t11
    call $tmp := $CopyOrMoveValue($t11);
    parent_addr := $tmp;
    if (true) { assume $DebugTrackLocal(7, 3634, 2, $tmp); }

    // $t14 := borrow_global<DualAttestation::Credential>(parent_addr)
    call $t14 := $BorrowGlobal(parent_addr, $DualAttestation_Credential_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(7, 3685);
      goto Abort;
    }
    assume $DualAttestation_Credential_is_well_formed($Dereference($t14));

    // UnpackRef($t14)

    // $t15 := borrow_field<DualAttestation::Credential>.compliance_public_key($t14)
    call $t15 := $BorrowField($t14, $DualAttestation_Credential_compliance_public_key);
    assume $Vector_is_well_formed($Dereference($t15)) && (forall $$1: int :: {$select_vector($Dereference($t15),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t15)) ==> $IsValidU8($select_vector($Dereference($t15),$$1)));

    // DualAttestation::Credential <- $t14
    call $WritebackToGlobal($t14);

    // UnpackRef($t15)

    // write_ref($t15, $t17)
    call $t15 := $WriteRef($t15, $t17);

    // DualAttestation::Credential <- $t15
    call $WritebackToGlobal($t15);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // PackRef($t14)

    // PackRef($t15)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $DualAttestation_rotate_compliance_public_key(account: $Value, new_key: $Value) returns ()
free requires is#$Address(account);
free requires $Vector_is_well_formed(new_key) && (forall $$0: int :: {$select_vector(new_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_key) ==> $IsValidU8($select_vector(new_key,$$0)));
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $DualAttestation_Credential_type_value(), $Signer_spec_address_of($m, $txn, account)))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Signature_spec_ed25519_validate_pubkey($m, $txn, new_key))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $DualAttestation_Credential_type_value(), $Signer_spec_address_of($m, $txn, account)))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Signature_spec_ed25519_validate_pubkey($m, $txn, new_key)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($ResourceValue($m, $DualAttestation_Credential_type_value(), $Signer_spec_address_of($m, $txn, account)), $DualAttestation_Credential_compliance_public_key), new_key))));
{
    call $DualAttestation_rotate_compliance_public_key_def(account, new_key);
}



// ** spec vars of module Option



// ** spec funs of module Option

function {:inline} $Option_spec_is_none($tv0: $TypeValue, t: $Value): $Value {
    $Boolean($IsEqual($vlen_value($SelectField(t, $Option_Option_vec)), $Integer(0)))
}

function {:inline} $Option_spec_is_some($tv0: $TypeValue, t: $Value): $Value {
    $Boolean(!b#$Boolean($Option_spec_is_none($tv0, t)))
}

function {:inline} $Option_spec_value_inside($tv0: $TypeValue, t: $Value): $Value {
    $select_vector_by_value($SelectField(t, $Option_Option_vec), $Integer(0))
}



// ** structs of module Option

const unique $Option_Option: $TypeName;
const $Option_Option_vec: $FieldName;
axiom $Option_Option_vec == 0;
function $Option_Option_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($Option_Option, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($tv0)], 1))
}
function {:inline} $Option_Option_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_is_well_formed($SelectField($this, $Option_Option_vec))
}
function {:inline} $Option_Option_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Vector_is_well_formed($SelectField($this, $Option_Option_vec))
      && b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($this, $Option_Option_vec))) <= i#$Integer($Integer(1))))
}

procedure {:inline 1} $Option_Option_before_update_inv($tv0: $TypeValue, $before: $Value) {
    assume b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($before, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}

procedure {:inline 1} $Option_Option_after_update_inv($tv0: $TypeValue, $after: $Value) {
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($after, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}

procedure {:inline 1} $Option_Option_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, vec: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(vec);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := vec], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
    assert b#$Boolean($Boolean(i#$Integer($vlen_value($SelectField($struct, $Option_Option_vec))) <= i#$Integer($Integer(1))));
}

procedure {:inline 1} $Option_Option_unpack($tv0: $TypeValue, $struct: $Value) returns (vec: $Value)
{
    assume is#$Vector($struct);
    vec := $SelectField($struct, $Option_Option_vec);
    assume $Vector_is_well_formed(vec);
}



// ** functions of module Option

procedure {:inline 1} $Option_borrow_def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $Option_Option_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $tv0
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 1334, 0, t); }

    // bytecode translation starts here
    // $t5 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;

    // $t1 := move($t5)
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;

    // $t2 := get_field<Option::Option<#0>>.vec($t1)
    call $tmp := $GetFieldFromValue($t1, $Option_Option_vec);
    assume $Vector_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := 0
    $tmp := $Integer(0);
    $t3 := $tmp;

    // $t4 := Vector::borrow<#0>($t2, $t3)
    call $t4 := $Vector_borrow($tv0, $t2, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1410);
      goto Abort;
    }


    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(19, 1402, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_borrow($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_none($tv0, t)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, t)))));
{
    call $ret0 := $Option_borrow_def($tv0, t);
}

procedure {:inline 1} $Option_borrow_mut_def($tv0: $TypeValue, t: $Value) returns ($ret0: $Reference, $ret1: $Value){
    // declare local variables
    var $t1: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t2: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t3: $Value; // $IntegerType()
    var $t4: $Reference; // ReferenceType($tv0)
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $t6: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t7: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 2803, 0, t); }

    // bytecode translation starts here
    // $t5 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;

    // $t6 := borrow_local($t5)
    call $t6 := $BorrowLoc(5, $t5);
    assume $Option_Option_is_well_formed($Dereference($t6));

    // $t1 := move($t6)
    call $t1 := $CopyOrMoveRef($t6);

    // $t2 := borrow_field<Option::Option<#0>>.vec($t1)
    call $t2 := $BorrowField($t1, $Option_Option_vec);
    assume $Vector_is_well_formed($Dereference($t2));

    // LocalRoot($t5) <- $t1
    call $t5 := $WritebackToValue($t1, 5, $t5);

    // UnpackRef($t2)

    // $t3 := 0
    $tmp := $Integer(0);
    $t3 := $tmp;

    // $t7 := read_ref($t2)
    call $tmp := $ReadRef($t2);
    assume $Vector_is_well_formed($tmp);
    $t7 := $tmp;

    // ($t4, $t7) := Vector::borrow_mut<#0>($t7, $t3)
    call $t4, $t7 := $Vector_borrow_mut($tv0, $t7, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2891);
      goto Abort;
    }

    assume $Vector_is_well_formed($t7);


    // write_ref($t2, $t7)
    call $t2 := $WriteRef($t2, $t7);

    // $t4 ~- [0 -> $t2]
    call $t4 := $Splice1(0, $t2, $t4);

    // LocalRoot($t5) <- $t2
    call $t5 := $WritebackToValue($t2, 5, $t5);

    // Reference($t1) <- $t2
    call $t1 := $WritebackToReference($t2, $t1);

    // return ($t4, $t5)
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(19, 2883, 8, $Dereference($ret0)); }
    $ret1 := $t5;
    if (true) { assume $DebugTrackLocal(19, 2883, 9, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultReference;
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Option_borrow_mut($tv0: $TypeValue, t: $Value) returns ($ret0: $Reference, $ret1: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_none($tv0, t)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Dereference($ret0), $Option_spec_value_inside($tv0, $ret1)))));
{
    call $ret0, $ret1 := $Option_borrow_mut_def($tv0, t);
}

procedure {:inline 1} $Option_contains_def($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $Option_Option_type_value($tv0)
    var $t3: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $tv0
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $Option_Option_type_value($tv0)
    var $t7: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 1104, 0, t); }
    if (true) { assume $DebugTrackLocal(19, 1104, 1, e_ref); }

    // bytecode translation starts here
    // $t6 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t6 := $tmp;

    // $t7 := move(e_ref)
    call $tmp := $CopyOrMoveValue(e_ref);
    $t7 := $tmp;

    // $t2 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;

    // $t3 := get_field<Option::Option<#0>>.vec($t2)
    call $tmp := $GetFieldFromValue($t2, $Option_Option_vec);
    assume $Vector_is_well_formed($tmp);
    $t3 := $tmp;

    // $t4 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t4 := $tmp;

    // $t5 := Vector::contains<#0>($t3, $t4)
    call $t5 := $Vector_contains($tv0, $t3, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1195);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // return $t5
    $ret0 := $t5;
    if (true) { assume $DebugTrackLocal(19, 1187, 8, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_contains($tv0: $TypeValue, t: $Value, e_ref: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) && b#$Boolean($Boolean($IsEqual($Option_spec_value_inside($tv0, t), e_ref))))))));
{
    call $ret0 := $Option_contains_def($tv0, t, e_ref);
}

procedure {:inline 1} $Option_swap_def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var old_value: $Value; // $tv0
    var vec_ref: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t4: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t5: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t6: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t7: $Value; // $tv0
    var $t8: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t9: $Value; // $tv0
    var $t10: $Value; // $tv0
    var $t11: $Value; // $Option_Option_type_value($tv0)
    var $t12: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t13: $Value; // $tv0
    var $t14: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 3042, 0, t); }
    if (true) { assume $DebugTrackLocal(19, 3042, 1, e); }

    // bytecode translation starts here
    // $t11 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t11 := $tmp;

    // $t13 := move(e)
    call $tmp := $CopyOrMoveValue(e);
    $t13 := $tmp;

    // $t12 := borrow_local($t11)
    call $t12 := $BorrowLoc(11, $t11);
    assume $Option_Option_is_well_formed($Dereference($t12));

    // UnpackRef($t12)
    call $Option_Option_before_update_inv($tv0, $Dereference($t12));

    // $t4 := move($t12)
    call $t4 := $CopyOrMoveRef($t12);

    // $t5 := borrow_field<Option::Option<#0>>.vec($t4)
    call $t5 := $BorrowField($t4, $Option_Option_vec);
    assume $Vector_is_well_formed($Dereference($t5));

    // LocalRoot($t11) <- $t4
    call $t11 := $WritebackToValue($t4, 11, $t11);

    // UnpackRef($t5)

    // vec_ref := $t5
    call vec_ref := $CopyOrMoveRef($t5);
    if (true) { assume $DebugTrackLocal(19, 3127, 3, $Dereference(vec_ref)); }

    // $t6 := copy(vec_ref)
    call $t6 := $CopyOrMoveRef(vec_ref);

    // PackRef($t6)

    // $t14 := read_ref($t6)
    call $tmp := $ReadRef($t6);
    assume $Vector_is_well_formed($tmp);
    $t14 := $tmp;

    // ($t7, $t14) := Vector::pop_back<#0>($t14)
    call $t7, $t14 := $Vector_pop_back($tv0, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3181);
      goto Abort;
    }

    assume $Vector_is_well_formed($t14);


    // write_ref($t6, $t14)
    call $t6 := $WriteRef($t6, $t14);
    if (true) { assume $DebugTrackLocal(19, 3042, 3, $Dereference(vec_ref)); }

    // Reference(vec_ref) <- $t6
    call vec_ref := $WritebackToReference($t6, vec_ref);

    // UnpackRef($t6)

    // old_value := $t7
    call $tmp := $CopyOrMoveValue($t7);
    old_value := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3161, 2, $tmp); }

    // $t8 := move(vec_ref)
    call $t8 := $CopyOrMoveRef(vec_ref);

    // PackRef($t8)

    // $t14 := read_ref($t8)
    call $tmp := $ReadRef($t8);
    assume $Vector_is_well_formed($tmp);
    $t14 := $tmp;

    // $t14 := Vector::push_back<#0>($t14, $t13)
    call $t14 := $Vector_push_back($tv0, $t14, $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3216);
      goto Abort;
    }
    assume $Vector_is_well_formed($t14);


    // write_ref($t8, $t14)
    call $t8 := $WriteRef($t8, $t14);
    if (true) { assume $DebugTrackLocal(19, 3042, 3, $Dereference(vec_ref)); }

    // LocalRoot($t11) <- $t8
    call $t11 := $WritebackToValue($t8, 11, $t11);

    // Reference($t4) <- $t8
    call $t4 := $WritebackToReference($t8, $t4);

    // UnpackRef($t8)

    // PackRef($t4)
    call $Option_Option_after_update_inv($tv0, $Dereference($t4));

    // PackRef($t8)

    // return (old_value, $t11)
    $ret0 := old_value;
    if (true) { assume $DebugTrackLocal(19, 3247, 15, $ret0); }
    $ret1 := $t11;
    if (true) { assume $DebugTrackLocal(19, 3247, 16, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Option_swap($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_none($tv0, t)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, old(t))))));
free ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret1)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_value_inside($tv0, $ret1), e))));
{
    call $ret0, $ret1 := $Option_swap_def($tv0, t, e);
}

procedure {:inline 1} $Option_borrow_with_default_def($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $tv0
    var vec_ref: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $Vector_type_value($tv0)
    var $t6: $Value; // $Vector_type_value($tv0)
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $Vector_type_value($tv0)
    var $t9: $Value; // $tv0
    var $t10: $Value; // $tv0
    var $t11: $Value; // $Vector_type_value($tv0)
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $tv0
    var $t14: $Value; // $tv0
    var $t15: $Value; // $Option_Option_type_value($tv0)
    var $t16: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 1562, 0, t); }
    if (true) { assume $DebugTrackLocal(19, 1562, 1, default_ref); }

    // bytecode translation starts here
    // $t15 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t15 := $tmp;

    // $t16 := move(default_ref)
    call $tmp := $CopyOrMoveValue(default_ref);
    $t16 := $tmp;

    // $t4 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t4 := $tmp;

    // $t5 := get_field<Option::Option<#0>>.vec($t4)
    call $tmp := $GetFieldFromValue($t4, $Option_Option_vec);
    assume $Vector_is_well_formed($tmp);
    $t5 := $tmp;

    // vec_ref := $t5
    call $tmp := $CopyOrMoveValue($t5);
    vec_ref := $tmp;
    if (true) { assume $DebugTrackLocal(19, 1670, 3, $tmp); }

    // $t6 := copy(vec_ref)
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t6 := $tmp;

    // $t7 := Vector::is_empty<#0>($t6)
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1708);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t8 := move(vec_ref)
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;

    // $t2 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(19, 1696, 2, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t10 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := move(vec_ref)
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t11 := $tmp;

    // $t12 := 0
    $tmp := $Integer(0);
    $t12 := $tmp;

    // $t13 := Vector::borrow<#0>($t11, $t12)
    call $t13 := $Vector_borrow($tv0, $t11, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 1760);
      goto Abort;
    }


    // $t2 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(19, 1696, 2, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // $t14 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t14 := $tmp;

    // return $t14
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(19, 1696, 17, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_borrow_with_default($tv0: $TypeValue, t: $Value, default_ref: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default_ref))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, t)))))));
{
    call $ret0 := $Option_borrow_with_default_def($tv0, t, default_ref);
}

procedure {:inline 1} $Option_destroy_none_def($tv0: $TypeValue, t: $Value) returns (){
    // declare local variables
    var vec: $Value; // $Vector_type_value($tv0)
    var $t2: $Value; // $Option_Option_type_value($tv0)
    var $t3: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Vector_type_value($tv0)
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 3922, 0, t); }

    // bytecode translation starts here
    // $t5 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;

    // $t3 := unpack Option::Option<#0>($t5)
    call $t3 := $Option_Option_unpack($tv0, $t5);
    $t3 := $t3;

    // vec := $t3
    call $tmp := $CopyOrMoveValue($t3);
    vec := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3998, 1, $tmp); }

    // Vector::destroy_empty<#0>(vec)
    call $Vector_destroy_empty($tv0, vec);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 4025);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $Option_destroy_none($tv0: $TypeValue, t: $Value) returns ()
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_some($tv0, t)))));
{
    call $Option_destroy_none_def($tv0, t);
}

procedure {:inline 1} $Option_destroy_some_def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value){
    // declare local variables
    var elem: $Value; // $tv0
    var vec: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $Option_Option_type_value($tv0)
    var $t4: $Value; // $Vector_type_value($tv0)
    var $t5: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t6: $Value; // $tv0
    var $t7: $Value; // $Vector_type_value($tv0)
    var $t8: $Value; // $tv0
    var $t9: $Value; // $Option_Option_type_value($tv0)
    var $t10: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 3666, 0, t); }

    // bytecode translation starts here
    // $t9 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t9 := $tmp;

    // $t4 := unpack Option::Option<#0>($t9)
    call $t4 := $Option_Option_unpack($tv0, $t9);
    $t4 := $t4;

    // vec := $t4
    call $tmp := $CopyOrMoveValue($t4);
    vec := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3751, 2, $tmp); }

    // $t5 := borrow_local(vec)
    call $t5 := $BorrowLoc(2, vec);
    assume $Vector_is_well_formed($Dereference($t5));

    // UnpackRef($t5)

    // PackRef($t5)

    // $t10 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $Vector_is_well_formed($tmp);
    $t10 := $tmp;

    // ($t6, $t10) := Vector::pop_back<#0>($t10)
    call $t6, $t10 := $Vector_pop_back($tv0, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3789);
      goto Abort;
    }

    assume $Vector_is_well_formed($t10);


    // write_ref($t5, $t10)
    call $t5 := $WriteRef($t5, $t10);

    // LocalRoot(vec) <- $t5
    call vec := $WritebackToValue($t5, 2, vec);

    // UnpackRef($t5)

    // PackRef($t5)

    // elem := $t6
    call $tmp := $CopyOrMoveValue($t6);
    elem := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3774, 1, $tmp); }

    // Vector::destroy_empty<#0>(vec)
    call $Vector_destroy_empty($tv0, vec);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3825);
      goto Abort;
    }

    // return elem
    $ret0 := elem;
    if (true) { assume $DebugTrackLocal(19, 3853, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_destroy_some($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_none($tv0, t)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, old(t))))));
{
    call $ret0 := $Option_destroy_some_def($tv0, t);
}

procedure {:inline 1} $Option_destroy_with_default_def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $tv0
    var vec: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $Vector_type_value($tv0)
    var $t6: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t7: $Value; // $Vector_type_value($tv0)
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $tv0
    var $t10: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t11: $Value; // $tv0
    var $t12: $Value; // $tv0
    var $t13: $Value; // $Option_Option_type_value($tv0)
    var $t14: $Value; // $tv0
    var $t15: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 3350, 0, t); }
    if (true) { assume $DebugTrackLocal(19, 3350, 1, default); }

    // bytecode translation starts here
    // $t13 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t13 := $tmp;

    // $t14 := move(default)
    call $tmp := $CopyOrMoveValue(default);
    $t14 := $tmp;

    // $t5 := unpack Option::Option<#0>($t13)
    call $t5 := $Option_Option_unpack($tv0, $t13);
    $t5 := $t5;

    // vec := $t5
    call $tmp := $CopyOrMoveValue($t5);
    vec := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3471, 3, $tmp); }

    // $t6 := borrow_local(vec)
    call $t6 := $BorrowLoc(3, vec);
    assume $Vector_is_well_formed($Dereference($t6));

    // UnpackRef($t6)

    // $t7 := read_ref($t6)
    call $tmp := $ReadRef($t6);
    assume $Vector_is_well_formed($tmp);
    $t7 := $tmp;

    // LocalRoot(vec) <- $t6
    call vec := $WritebackToValue($t6, 3, vec);

    // PackRef($t6)

    // $t8 := Vector::is_empty<#0>($t7)
    call $t8 := $Vector_is_empty($tv0, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3502);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // if ($t8) goto L0 else goto L1
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t2 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3490, 2, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t10 := borrow_local(vec)
    call $t10 := $BorrowLoc(3, vec);
    assume $Vector_is_well_formed($Dereference($t10));

    // UnpackRef($t10)

    // PackRef($t10)

    // $t15 := read_ref($t10)
    call $tmp := $ReadRef($t10);
    assume $Vector_is_well_formed($tmp);
    $t15 := $tmp;

    // ($t11, $t15) := Vector::pop_back<#0>($t15)
    call $t11, $t15 := $Vector_pop_back($tv0, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 3551);
      goto Abort;
    }

    assume $Vector_is_well_formed($t15);


    // write_ref($t10, $t15)
    call $t10 := $WriteRef($t10, $t15);

    // LocalRoot(vec) <- $t10
    call vec := $WritebackToValue($t10, 3, vec);

    // UnpackRef($t10)

    // PackRef($t10)

    // $t2 := $t11
    call $tmp := $CopyOrMoveValue($t11);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(19, 3490, 2, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(19, 3490, 16, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_destroy_with_default($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, default))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, old(t))) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, old(t))))))));
{
    call $ret0 := $Option_destroy_with_default_def($tv0, t, default);
}

procedure {:inline 1} $Option_extract_def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var $t1: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t2: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t3: $Value; // $tv0
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t6: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 2590, 0, t); }

    // bytecode translation starts here
    // $t4 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t4 := $tmp;

    // $t5 := borrow_local($t4)
    call $t5 := $BorrowLoc(4, $t4);
    assume $Option_Option_is_well_formed($Dereference($t5));

    // UnpackRef($t5)
    call $Option_Option_before_update_inv($tv0, $Dereference($t5));

    // $t1 := move($t5)
    call $t1 := $CopyOrMoveRef($t5);

    // $t2 := borrow_field<Option::Option<#0>>.vec($t1)
    call $t2 := $BorrowField($t1, $Option_Option_vec);
    assume $Vector_is_well_formed($Dereference($t2));

    // LocalRoot($t4) <- $t1
    call $t4 := $WritebackToValue($t1, 4, $t4);

    // UnpackRef($t2)

    // PackRef($t2)

    // $t6 := read_ref($t2)
    call $tmp := $ReadRef($t2);
    assume $Vector_is_well_formed($tmp);
    $t6 := $tmp;

    // ($t3, $t6) := Vector::pop_back<#0>($t6)
    call $t3, $t6 := $Vector_pop_back($tv0, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2670);
      goto Abort;
    }

    assume $Vector_is_well_formed($t6);


    // write_ref($t2, $t6)
    call $t2 := $WriteRef($t2, $t6);

    // LocalRoot($t4) <- $t2
    call $t4 := $WritebackToValue($t2, 4, $t4);

    // Reference($t1) <- $t2
    call $t1 := $WritebackToReference($t2, $t1);

    // UnpackRef($t2)

    // PackRef($t1)
    call $Option_Option_after_update_inv($tv0, $Dereference($t1));

    // PackRef($t2)

    // return ($t3, $t4)
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(19, 2662, 7, $ret0); }
    $ret1 := $t4;
    if (true) { assume $DebugTrackLocal(19, 2662, 8, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $Option_extract($tv0: $TypeValue, t: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_none($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_none($tv0, t)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, old(t))))));
free ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_none($tv0, $ret1)));
{
    call $ret0, $ret1 := $Option_extract_def($tv0, t);
}

procedure {:inline 1} $Option_fill_def($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value){
    // declare local variables
    var vec_ref: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t3: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t4: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t5: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t6: $Value; // $Vector_type_value($tv0)
    var $t7: $Value; // $BooleanType()
    var $t8: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t9: $Value; // $IntegerType()
    var $t10: $Reference; // ReferenceType($Vector_type_value($tv0))
    var $t11: $Value; // $tv0
    var $t12: $Value; // $Option_Option_type_value($tv0)
    var $t13: $Reference; // ReferenceType($Option_Option_type_value($tv0))
    var $t14: $Value; // $tv0
    var $t15: $Value; // $Vector_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 2230, 0, t); }
    if (true) { assume $DebugTrackLocal(19, 2230, 1, e); }

    // bytecode translation starts here
    // $t12 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t12 := $tmp;

    // $t14 := move(e)
    call $tmp := $CopyOrMoveValue(e);
    $t14 := $tmp;

    // $t13 := borrow_local($t12)
    call $t13 := $BorrowLoc(12, $t12);
    assume $Option_Option_is_well_formed($Dereference($t13));

    // UnpackRef($t13)
    call $Option_Option_before_update_inv($tv0, $Dereference($t13));

    // $t3 := move($t13)
    call $t3 := $CopyOrMoveRef($t13);

    // $t4 := borrow_field<Option::Option<#0>>.vec($t3)
    call $t4 := $BorrowField($t3, $Option_Option_vec);
    assume $Vector_is_well_formed($Dereference($t4));

    // LocalRoot($t12) <- $t3
    call $t12 := $WritebackToValue($t3, 12, $t12);

    // UnpackRef($t4)

    // vec_ref := $t4
    call vec_ref := $CopyOrMoveRef($t4);
    if (true) { assume $DebugTrackLocal(19, 2306, 2, $Dereference(vec_ref)); }

    // $t5 := copy(vec_ref)
    call $t5 := $CopyOrMoveRef(vec_ref);

    // $t6 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $Vector_is_well_formed($tmp);
    $t6 := $tmp;

    // Reference(vec_ref) <- $t5
    call vec_ref := $WritebackToReference($t5, vec_ref);

    // $t7 := Vector::is_empty<#0>($t6)
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2348);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move(vec_ref)
    call $t8 := $CopyOrMoveRef(vec_ref);

    // destroy($t8)

    // LocalRoot($t12) <- $t8
    call $t12 := $WritebackToValue($t8, 12, $t12);

    // Reference($t3) <- $t8
    call $t3 := $WritebackToReference($t8, $t3);

    // PackRef($t3)
    call $Option_Option_after_update_inv($tv0, $Dereference($t3));

    // PackRef($t8)

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(19, 2410); }
    goto Abort;

    // L0:
L0:

    // $t10 := move(vec_ref)
    call $t10 := $CopyOrMoveRef(vec_ref);

    // PackRef($t10)

    // $t15 := read_ref($t10)
    call $tmp := $ReadRef($t10);
    assume $Vector_is_well_formed($tmp);
    $t15 := $tmp;

    // $t15 := Vector::push_back<#0>($t15, $t14)
    call $t15 := $Vector_push_back($tv0, $t15, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2375);
      goto Abort;
    }
    assume $Vector_is_well_formed($t15);


    // write_ref($t10, $t15)
    call $t10 := $WriteRef($t10, $t15);
    if (true) { assume $DebugTrackLocal(19, 2230, 2, $Dereference(vec_ref)); }

    // LocalRoot($t12) <- $t10
    call $t12 := $WritebackToValue($t10, 12, $t12);

    // Reference($t3) <- $t10
    call $t3 := $WritebackToReference($t10, $t3);

    // UnpackRef($t10)

    // PackRef($t3)
    call $Option_Option_after_update_inv($tv0, $Dereference($t3));

    // PackRef($t10)

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(19, 2336, 16, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_fill($tv0: $TypeValue, t: $Value, e: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Option_spec_is_some($tv0, t))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Option_spec_is_some($tv0, t)))));
free ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret0)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_value_inside($tv0, $ret0), e))));
{
    call $ret0 := $Option_fill_def($tv0, t, e);
}

procedure {:inline 1} $Option_get_with_default_def($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t2: $Value; // $tv0
    var vec_ref: $Value; // $Vector_type_value($tv0)
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $t5: $Value; // $Vector_type_value($tv0)
    var $t6: $Value; // $Vector_type_value($tv0)
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $Vector_type_value($tv0)
    var $t9: $Value; // $tv0
    var $t10: $Value; // $Vector_type_value($tv0)
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $tv0
    var $t13: $Value; // $tv0
    var $t14: $Value; // $tv0
    var $t15: $Value; // $Option_Option_type_value($tv0)
    var $t16: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 1894, 0, t); }
    if (true) { assume $DebugTrackLocal(19, 1894, 1, default); }

    // bytecode translation starts here
    // $t15 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t15 := $tmp;

    // $t16 := move(default)
    call $tmp := $CopyOrMoveValue(default);
    $t16 := $tmp;

    // $t4 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t4 := $tmp;

    // $t5 := get_field<Option::Option<#0>>.vec($t4)
    call $tmp := $GetFieldFromValue($t4, $Option_Option_vec);
    assume $Vector_is_well_formed($tmp);
    $t5 := $tmp;

    // vec_ref := $t5
    call $tmp := $CopyOrMoveValue($t5);
    vec_ref := $tmp;
    if (true) { assume $DebugTrackLocal(19, 2003, 3, $tmp); }

    // $t6 := copy(vec_ref)
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t6 := $tmp;

    // $t7 := Vector::is_empty<#0>($t6)
    call $t7 := $Vector_is_empty($tv0, $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2041);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // if ($t7) goto L0 else goto L1
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t8 := move(vec_ref)
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t8 := $tmp;

    // destroy($t8)

    // $t2 := $t16
    call $tmp := $CopyOrMoveValue($t16);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(19, 2029, 2, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t10 := move(vec_ref)
    call $tmp := $CopyOrMoveValue(vec_ref);
    $t10 := $tmp;

    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // $t12 := Vector::borrow<#0>($t10, $t11)
    call $t12 := $Vector_borrow($tv0, $t10, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 2090);
      goto Abort;
    }


    // $t13 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t13 := $tmp;

    // $t2 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(19, 2029, 2, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(19, 2029, 17, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_get_with_default($tv0: $TypeValue, t: $Value, default: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Option_spec_is_none($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, default))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean(b#$Boolean($Option_spec_is_some($tv0, t)) ==> b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_value_inside($tv0, t)))))));
{
    call $ret0 := $Option_get_with_default_def($tv0, t, default);
}

procedure {:inline 1} $Option_is_none_def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $Option_Option_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $Option_Option_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 743, 0, t); }

    // bytecode translation starts here
    // $t4 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := get_field<Option::Option<#0>>.vec($t1)
    call $tmp := $GetFieldFromValue($t1, $Option_Option_vec);
    assume $Vector_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := Vector::is_empty<#0>($t2)
    call $t3 := $Vector_is_empty($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 816);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(19, 808, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_is_none($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_none($tv0, t)))));
{
    call $ret0 := $Option_is_none_def($tv0, t);
}

procedure {:inline 1} $Option_is_some_def($tv0: $TypeValue, t: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $Option_Option_type_value($tv0)
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $Option_Option_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 884, 0, t); }

    // bytecode translation starts here
    // $t5 := move(t)
    call $tmp := $CopyOrMoveValue(t);
    $t5 := $tmp;

    // $t1 := move($t5)
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;

    // $t2 := get_field<Option::Option<#0>>.vec($t1)
    call $tmp := $GetFieldFromValue($t1, $Option_Option_vec);
    assume $Vector_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := Vector::is_empty<#0>($t2)
    call $t3 := $Vector_is_empty($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 958);
      goto Abort;
    }
    assume is#$Boolean($t3);


    // $t4 := !($t3)
    call $tmp := $Not($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(19, 949, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_is_some($tv0: $TypeValue, t: $Value) returns ($ret0: $Value)
free requires $Option_Option_is_well_formed(t);
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $Option_spec_is_some($tv0, t)))));
{
    call $ret0 := $Option_is_some_def($tv0, t);
}

procedure {:inline 1} $Option_none_def($tv0: $TypeValue) returns ($ret0: $Value){
    // declare local variables
    var $t0: $Value; // $Vector_type_value($tv0)
    var $t1: $Value; // $Option_Option_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time

    // bytecode translation starts here
    // $t0 := Vector::empty<#0>()
    call $t0 := $Vector_empty($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 521);
      goto Abort;
    }
    assume $Vector_is_well_formed($t0);


    // $t1 := pack Option::Option<#0>($t0)
    call $tmp := $Option_Option_pack(0, 0, 0, $tv0, $t0);
    $t1 := $tmp;

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(19, 499, 2, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_none($tv0: $TypeValue) returns ($ret0: $Value)
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_none($tv0, $ret0)));
{
    call $ret0 := $Option_none_def($tv0);
}

procedure {:inline 1} $Option_some_def($tv0: $TypeValue, e: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $tv0
    var $t2: $Value; // $Vector_type_value($tv0)
    var $t3: $Value; // $Option_Option_type_value($tv0)
    var $t4: $Value; // $tv0
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(19, 583, 0, e); }

    // bytecode translation starts here
    // $t4 := move(e)
    call $tmp := $CopyOrMoveValue(e);
    $t4 := $tmp;

    // $t2 := Vector::singleton<#0>($t4)
    call $t2 := $Vector_singleton($tv0, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(19, 669);
      goto Abort;
    }
    assume $Vector_is_well_formed($t2);


    // $t3 := pack Option::Option<#0>($t2)
    call $tmp := $Option_Option_pack(0, 0, 0, $tv0, $t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(19, 647, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $Option_some($tv0: $TypeValue, e: $Value) returns ($ret0: $Value)
free ensures b#$Boolean(old($Boolean(false))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(false)))));
free ensures !$abort_flag ==> (b#$Boolean($Option_spec_is_some($tv0, $ret0)));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($Option_spec_value_inside($tv0, $ret0), e))));
{
    call $ret0 := $Option_some_def($tv0, e);
}



// ** spec vars of module ValidatorConfig



// ** spec funs of module ValidatorConfig

function {:inline} $ValidatorConfig_spec_get_config($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $Option_spec_value_inside($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($m, $ValidatorConfig_ValidatorConfig_type_value(), addr), $ValidatorConfig_ValidatorConfig_config))
}

function {:inline} $ValidatorConfig_spec_is_valid($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $Boolean(b#$Boolean($ResourceExists($m, $ValidatorConfig_ValidatorConfig_type_value(), addr)) && b#$Boolean($Option_spec_is_some($ValidatorConfig_Config_type_value(), $SelectField($ResourceValue($m, $ValidatorConfig_ValidatorConfig_type_value(), addr), $ValidatorConfig_ValidatorConfig_config))))
}



// ** structs of module ValidatorConfig

const unique $ValidatorConfig_Config: $TypeName;
const $ValidatorConfig_Config_consensus_pubkey: $FieldName;
axiom $ValidatorConfig_Config_consensus_pubkey == 0;
const $ValidatorConfig_Config_validator_network_identity_pubkey: $FieldName;
axiom $ValidatorConfig_Config_validator_network_identity_pubkey == 1;
const $ValidatorConfig_Config_validator_network_address: $FieldName;
axiom $ValidatorConfig_Config_validator_network_address == 2;
const $ValidatorConfig_Config_full_node_network_identity_pubkey: $FieldName;
axiom $ValidatorConfig_Config_full_node_network_identity_pubkey == 3;
const $ValidatorConfig_Config_full_node_network_address: $FieldName;
axiom $ValidatorConfig_Config_full_node_network_address == 4;
function $ValidatorConfig_Config_type_value(): $TypeValue {
    $StructType($ValidatorConfig_Config, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($IntegerType())][1 := $Vector_type_value($IntegerType())][2 := $Vector_type_value($IntegerType())][3 := $Vector_type_value($IntegerType())][4 := $Vector_type_value($IntegerType())], 5))
}
function {:inline} $ValidatorConfig_Config_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 5
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_address)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address),$$0)))
}
function {:inline} $ValidatorConfig_Config_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 5
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_consensus_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_consensus_pubkey),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_identity_pubkey),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_validator_network_address)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_validator_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_validator_network_address),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_identity_pubkey),$$0)))
      && $Vector_is_well_formed($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) && (forall $$0: int :: {$select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $ValidatorConfig_Config_full_node_network_address)) ==> $IsValidU8($select_vector($SelectField($this, $ValidatorConfig_Config_full_node_network_address),$$0)))
}

procedure {:inline 1} $ValidatorConfig_Config_pack($file_id: int, $byte_index: int, $var_idx: int, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {$select_vector(consensus_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey,$$0)));
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {$select_vector(validator_network_identity_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey,$$0)));
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {$select_vector(validator_network_address,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address,$$0)));
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {$select_vector(full_node_network_identity_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey,$$0)));
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {$select_vector(full_node_network_address,$$0)} $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := consensus_pubkey][1 := validator_network_identity_pubkey][2 := validator_network_address][3 := full_node_network_identity_pubkey][4 := full_node_network_address], 5));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ValidatorConfig_Config_unpack($struct: $Value) returns (consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value)
{
    assume is#$Vector($struct);
    consensus_pubkey := $SelectField($struct, $ValidatorConfig_Config_consensus_pubkey);
    assume $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {$select_vector(consensus_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey,$$0)));
    validator_network_identity_pubkey := $SelectField($struct, $ValidatorConfig_Config_validator_network_identity_pubkey);
    assume $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {$select_vector(validator_network_identity_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey,$$0)));
    validator_network_address := $SelectField($struct, $ValidatorConfig_Config_validator_network_address);
    assume $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {$select_vector(validator_network_address,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address,$$0)));
    full_node_network_identity_pubkey := $SelectField($struct, $ValidatorConfig_Config_full_node_network_identity_pubkey);
    assume $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {$select_vector(full_node_network_identity_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey,$$0)));
    full_node_network_address := $SelectField($struct, $ValidatorConfig_Config_full_node_network_address);
    assume $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {$select_vector(full_node_network_address,$$0)} $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address,$$0)));
}

const unique $ValidatorConfig_ValidatorConfig: $TypeName;
const $ValidatorConfig_ValidatorConfig_config: $FieldName;
axiom $ValidatorConfig_ValidatorConfig_config == 0;
const $ValidatorConfig_ValidatorConfig_operator_account: $FieldName;
axiom $ValidatorConfig_ValidatorConfig_operator_account == 1;
function $ValidatorConfig_ValidatorConfig_type_value(): $TypeValue {
    $StructType($ValidatorConfig_ValidatorConfig, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Option_Option_type_value($ValidatorConfig_Config_type_value())][1 := $Option_Option_type_value($AddressType())], 2))
}
function {:inline} $ValidatorConfig_ValidatorConfig_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $Option_Option_is_well_formed_types($SelectField($this, $ValidatorConfig_ValidatorConfig_config))
      && $Option_Option_is_well_formed_types($SelectField($this, $ValidatorConfig_ValidatorConfig_operator_account))
}
function {:inline} $ValidatorConfig_ValidatorConfig_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $Option_Option_is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_config))
      && $Option_Option_is_well_formed($SelectField($this, $ValidatorConfig_ValidatorConfig_operator_account))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $ValidatorConfig_ValidatorConfig_is_well_formed($ResourceValue(m, $ValidatorConfig_ValidatorConfig_type_value(), a))
);

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_before_update_inv($before: $Value) {
    call $Option_Option_before_update_inv($ValidatorConfig_Config_type_value(), $SelectField($before, $ValidatorConfig_ValidatorConfig_config));
    call $Option_Option_before_update_inv($AddressType(), $SelectField($before, $ValidatorConfig_ValidatorConfig_operator_account));
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_after_update_inv($after: $Value) {
    call $Option_Option_after_update_inv($ValidatorConfig_Config_type_value(), $SelectField($after, $ValidatorConfig_ValidatorConfig_config));
    call $Option_Option_after_update_inv($AddressType(), $SelectField($after, $ValidatorConfig_ValidatorConfig_operator_account));
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, config: $Value, operator_account: $Value) returns ($struct: $Value)
{
    assume $Option_Option_is_well_formed(config);
    assume $Option_Option_is_well_formed(operator_account);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := config][1 := operator_account], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ValidatorConfig_ValidatorConfig_unpack($struct: $Value) returns (config: $Value, operator_account: $Value)
{
    assume is#$Vector($struct);
    config := $SelectField($struct, $ValidatorConfig_ValidatorConfig_config);
    assume $Option_Option_is_well_formed(config);
    operator_account := $SelectField($struct, $ValidatorConfig_ValidatorConfig_operator_account);
    assume $Option_Option_is_well_formed(operator_account);
}

const unique $ValidatorConfig_UpdateValidatorConfig: $TypeName;
const $ValidatorConfig_UpdateValidatorConfig_dummy_field: $FieldName;
axiom $ValidatorConfig_UpdateValidatorConfig_dummy_field == 0;
function $ValidatorConfig_UpdateValidatorConfig_type_value(): $TypeValue {
    $StructType($ValidatorConfig_UpdateValidatorConfig, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $ValidatorConfig_UpdateValidatorConfig_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $ValidatorConfig_UpdateValidatorConfig_dummy_field))
}
function {:inline} $ValidatorConfig_UpdateValidatorConfig_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $ValidatorConfig_UpdateValidatorConfig_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $ValidatorConfig_UpdateValidatorConfig_is_well_formed($ResourceValue(m, $ValidatorConfig_UpdateValidatorConfig_type_value(), a))
);

procedure {:inline 1} $ValidatorConfig_UpdateValidatorConfig_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $ValidatorConfig_UpdateValidatorConfig_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $ValidatorConfig_UpdateValidatorConfig_dummy_field);
    assume is#$Boolean(dummy_field);
}



// ** functions of module ValidatorConfig

procedure {:inline 1} $ValidatorConfig_get_config_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var config: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t10: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t11: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t12: $Value; // $ValidatorConfig_Config_type_value()
    var $t13: $Value; // $ValidatorConfig_Config_type_value()
    var $t14: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 4576, 0, addr); }

    // bytecode translation starts here
    // $t14 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t14 := $tmp;

    // $t5 := exists<ValidatorConfig::ValidatorConfig>($t14)
    call $tmp := $Exists($t14, $ValidatorConfig_ValidatorConfig_type_value());
    $t5 := $tmp;

    // $t2 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 4656, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := 2
    $tmp := $Integer(2);
    $t7 := $tmp;

    // abort($t7)
    if (true) { assume $DebugTrackAbort(27, 4656); }
    goto Abort;

    // L0:
L0:

    // $t9 := get_global<ValidatorConfig::ValidatorConfig>($t14)
    call $tmp := $GetGlobal($t14, $ValidatorConfig_ValidatorConfig_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 4753);
      goto Abort;
    }
    assume $ValidatorConfig_ValidatorConfig_is_well_formed($tmp);
    $t9 := $tmp;

    // $t10 := get_field<ValidatorConfig::ValidatorConfig>.config($t9)
    call $tmp := $GetFieldFromValue($t9, $ValidatorConfig_ValidatorConfig_config);
    assume $Option_Option_is_well_formed($tmp);
    $t10 := $tmp;

    // config := $t10
    call $tmp := $CopyOrMoveValue($t10);
    config := $tmp;
    if (true) { assume $DebugTrackLocal(27, 4743, 1, $tmp); }

    // $t11 := move(config)
    call $tmp := $CopyOrMoveValue(config);
    $t11 := $tmp;

    // $t12 := Option::borrow<ValidatorConfig::Config>($t11)
    call $t12 := $Option_borrow($ValidatorConfig_Config_type_value(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 4815);
      goto Abort;
    }
    assume $ValidatorConfig_Config_is_well_formed($t12);


    // $t13 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t13 := $tmp;

    // return $t13
    $ret0 := $t13;
    if (true) { assume $DebugTrackLocal(27, 4806, 15, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $ValidatorConfig_get_config(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $ValidatorConfig_get_config_def(addr);
}

procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey_def(config_ref: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $ValidatorConfig_Config_type_value()
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $ValidatorConfig_Config_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 5341, 0, config_ref); }

    // bytecode translation starts here
    // $t3 := move(config_ref)
    call $tmp := $CopyOrMoveValue(config_ref);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := get_field<ValidatorConfig::Config>.consensus_pubkey($t1)
    call $tmp := $GetFieldFromValue($t1, $ValidatorConfig_Config_consensus_pubkey);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(27, 5417, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $ValidatorConfig_get_consensus_pubkey(config_ref: $Value) returns ($ret0: $Value)
free requires $ValidatorConfig_Config_is_well_formed(config_ref);
{
    call $ret0 := $ValidatorConfig_get_consensus_pubkey_def(config_ref);
}

procedure {:inline 1} $ValidatorConfig_get_operator_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var t_ref: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t10: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t11: $Value; // $Option_Option_type_value($AddressType())
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 4985, 0, addr); }

    // bytecode translation starts here
    // $t15 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t15 := $tmp;

    // $t5 := exists<ValidatorConfig::ValidatorConfig>($t15)
    call $tmp := $Exists($t15, $ValidatorConfig_ValidatorConfig_type_value());
    $t5 := $tmp;

    // $t2 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 5068, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := 2
    $tmp := $Integer(2);
    $t7 := $tmp;

    // abort($t7)
    if (true) { assume $DebugTrackAbort(27, 5068); }
    goto Abort;

    // L0:
L0:

    // $t9 := get_global<ValidatorConfig::ValidatorConfig>($t15)
    call $tmp := $GetGlobal($t15, $ValidatorConfig_ValidatorConfig_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5163);
      goto Abort;
    }
    assume $ValidatorConfig_ValidatorConfig_is_well_formed($tmp);
    $t9 := $tmp;

    // t_ref := $t9
    call $tmp := $CopyOrMoveValue($t9);
    t_ref := $tmp;
    if (true) { assume $DebugTrackLocal(27, 5155, 1, $tmp); }

    // $t10 := move(t_ref)
    call $tmp := $CopyOrMoveValue(t_ref);
    $t10 := $tmp;

    // $t11 := get_field<ValidatorConfig::ValidatorConfig>.operator_account($t10)
    call $tmp := $GetFieldFromValue($t10, $ValidatorConfig_ValidatorConfig_operator_account);
    assume $Option_Option_is_well_formed($tmp);
    $t11 := $tmp;

    // $t12 := copy($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t12 := $tmp;

    // $t13 := Option::borrow_with_default<address>($t11, $t12)
    call $t13 := $Option_borrow_with_default($AddressType(), $t11, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 5218);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t14 := $tmp;

    // return $t14
    $ret0 := $t14;
    if (true) { assume $DebugTrackLocal(27, 5209, 16, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $ValidatorConfig_get_operator(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $ValidatorConfig_get_operator_def(addr);
}

procedure {:inline 1} $ValidatorConfig_get_validator_network_address_def(config_ref: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $ValidatorConfig_Config_type_value()
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $ValidatorConfig_Config_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 5757, 0, config_ref); }

    // bytecode translation starts here
    // $t3 := move(config_ref)
    call $tmp := $CopyOrMoveValue(config_ref);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := get_field<ValidatorConfig::Config>.validator_network_address($t1)
    call $tmp := $GetFieldFromValue($t1, $ValidatorConfig_Config_validator_network_address);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(27, 5842, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $ValidatorConfig_get_validator_network_address(config_ref: $Value) returns ($ret0: $Value)
free requires $ValidatorConfig_Config_is_well_formed(config_ref);
{
    call $ret0 := $ValidatorConfig_get_validator_network_address_def(config_ref);
}

procedure {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey_def(config_ref: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $ValidatorConfig_Config_type_value()
    var $t2: $Value; // $Vector_type_value($IntegerType())
    var $t3: $Value; // $ValidatorConfig_Config_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 5536, 0, config_ref); }

    // bytecode translation starts here
    // $t3 := move(config_ref)
    call $tmp := $CopyOrMoveValue(config_ref);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := get_field<ValidatorConfig::Config>.validator_network_identity_pubkey($t1)
    call $tmp := $GetFieldFromValue($t1, $ValidatorConfig_Config_validator_network_identity_pubkey);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(27, 5629, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $ValidatorConfig_get_validator_network_identity_pubkey(config_ref: $Value) returns ($ret0: $Value)
free requires $ValidatorConfig_Config_is_well_formed(config_ref);
{
    call $ret0 := $ValidatorConfig_get_validator_network_identity_pubkey_def(config_ref);
}

procedure {:inline 1} $ValidatorConfig_is_valid_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t6: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 4296, 0, addr); }

    // bytecode translation starts here
    // $t10 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t10 := $tmp;

    // $t3 := exists<ValidatorConfig::ValidatorConfig>($t10)
    call $tmp := $Exists($t10, $ValidatorConfig_ValidatorConfig_type_value());
    $t3 := $tmp;

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t5 := get_global<ValidatorConfig::ValidatorConfig>($t10)
    call $tmp := $GetGlobal($t10, $ValidatorConfig_ValidatorConfig_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 4422);
      goto Abort;
    }
    assume $ValidatorConfig_ValidatorConfig_is_well_formed($tmp);
    $t5 := $tmp;

    // $t6 := get_field<ValidatorConfig::ValidatorConfig>.config($t5)
    call $tmp := $GetFieldFromValue($t5, $ValidatorConfig_ValidatorConfig_config);
    assume $Option_Option_is_well_formed($tmp);
    $t6 := $tmp;

    // $t7 := Option::is_some<ValidatorConfig::Config>($t6)
    call $t7 := $Option_is_some($ValidatorConfig_Config_type_value(), $t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 4413);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t1 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 4372, 1, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t8 := false
    $tmp := $Boolean(false);
    $t8 := $tmp;

    // $t1 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 4372, 1, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // return $t1
    $ret0 := $t1;
    if (true) { assume $DebugTrackLocal(27, 4372, 11, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $ValidatorConfig_is_valid(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $ValidatorConfig_is_valid_def(addr);
}

procedure {:inline 1} $ValidatorConfig_publish_def(account: $Value, lr_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t11: $Value; // $Option_Option_type_value($AddressType())
    var $t12: $Value; // $ValidatorConfig_ValidatorConfig_type_value()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 1204, 0, account); }
    if (true) { assume $DebugTrackLocal(27, 1204, 1, lr_account); }

    // bytecode translation starts here
    // $t13 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t13 := $tmp;

    // $t14 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;

    // $t4 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t4 := $tmp;

    // $t5 := Roles::has_libra_root_role($t4)
    call $t5 := $Roles_has_libra_root_role($t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1313);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // $t2 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 1299, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t7 := $tmp;

    // destroy($t7)

    // $t8 := 0
    $tmp := $Integer(0);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(27, 1299); }
    goto Abort;

    // L0:
L0:

    // $t9 := move($t13)
    call $tmp := $CopyOrMoveValue($t13);
    $t9 := $tmp;

    // $t10 := Option::none<ValidatorConfig::Config>()
    call $t10 := $Option_none($ValidatorConfig_Config_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1435);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t10);


    // $t11 := Option::none<address>()
    call $t11 := $Option_none($AddressType());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1481);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t11);


    // $t12 := pack ValidatorConfig::ValidatorConfig($t10, $t11)
    call $tmp := $ValidatorConfig_ValidatorConfig_pack(0, 0, 0, $t10, $t11);
    $t12 := $tmp;

    // move_to<ValidatorConfig::ValidatorConfig>($t12, $t9)
    call $MoveTo($ValidatorConfig_ValidatorConfig_type_value(), $t12, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1372);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $ValidatorConfig_publish(account: $Value, lr_account: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(lr_account);
{
    call $ValidatorConfig_publish_def(account, lr_account);
}

procedure {:inline 1} $ValidatorConfig_remove_operator_def(account: $Value) returns (){
    // declare local variables
    var sender: $Value; // $AddressType()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $Option_Option_type_value($AddressType())
    var $t5: $Value; // $AddressType()
    var $t6: $Reference; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t7: $Reference; // ReferenceType($Option_Option_type_value($AddressType()))
    var $t8: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 2174, 0, account); }

    // bytecode translation starts here
    // $t8 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t8 := $tmp;

    // $t2 := move($t8)
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;

    // $t3 := Signer::address_of($t2)
    call $t3 := $Signer_address_of($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2275);
      goto Abort;
    }
    assume is#$Address($t3);


    // sender := $t3
    call $tmp := $CopyOrMoveValue($t3);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(27, 2258, 1, $tmp); }

    // $t4 := Option::none<address>()
    call $t4 := $Option_none($AddressType());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2412);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t4);


    // $t6 := borrow_global<ValidatorConfig::ValidatorConfig>(sender)
    call $t6 := $BorrowGlobal(sender, $ValidatorConfig_ValidatorConfig_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2341);
      goto Abort;
    }
    assume $ValidatorConfig_ValidatorConfig_is_well_formed($Dereference($t6));

    // UnpackRef($t6)
    call $ValidatorConfig_ValidatorConfig_before_update_inv($Dereference($t6));

    // $t7 := borrow_field<ValidatorConfig::ValidatorConfig>.operator_account($t6)
    call $t7 := $BorrowField($t6, $ValidatorConfig_ValidatorConfig_operator_account);
    assume $Option_Option_is_well_formed_types($Dereference($t7));

    // ValidatorConfig::ValidatorConfig <- $t6
    call $WritebackToGlobal($t6);

    // UnpackRef($t7)
    call $Option_Option_before_update_inv($AddressType(), $Dereference($t7));

    // write_ref($t7, $t4)
    call $t7 := $WriteRef($t7, $t4);

    // ValidatorConfig::ValidatorConfig <- $t7
    call $WritebackToGlobal($t7);

    // Reference($t6) <- $t7
    call $t6 := $WritebackToReference($t7, $t6);

    // PackRef($t6)
    call $ValidatorConfig_ValidatorConfig_after_update_inv($Dereference($t6));

    // PackRef($t7)
    call $Option_Option_after_update_inv($AddressType(), $Dereference($t7));

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $ValidatorConfig_remove_operator(account: $Value) returns ()
free requires is#$Address(account);
{
    call $ValidatorConfig_remove_operator_def(account);
}

procedure {:inline 1} $ValidatorConfig_set_config_def(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value) returns (){
    // declare local variables
    var t_ref: $Reference; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $AddressType()
    var $t24: $Reference; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t25: $Value; // $Vector_type_value($IntegerType())
    var $t26: $Value; // $Vector_type_value($IntegerType())
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $Vector_type_value($IntegerType())
    var $t29: $Value; // $Vector_type_value($IntegerType())
    var $t30: $Value; // $ValidatorConfig_Config_type_value()
    var $t31: $Value; // $Option_Option_type_value($ValidatorConfig_Config_type_value())
    var $t32: $Reference; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t33: $Reference; // ReferenceType($Option_Option_type_value($ValidatorConfig_Config_type_value()))
    var $t34: $Value; // $AddressType()
    var $t35: $Value; // $AddressType()
    var $t36: $Value; // $Vector_type_value($IntegerType())
    var $t37: $Value; // $Vector_type_value($IntegerType())
    var $t38: $Value; // $Vector_type_value($IntegerType())
    var $t39: $Value; // $Vector_type_value($IntegerType())
    var $t40: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 2844, 0, signer); }
    if (true) { assume $DebugTrackLocal(27, 2844, 1, validator_account); }
    if (true) { assume $DebugTrackLocal(27, 2844, 2, consensus_pubkey); }
    if (true) { assume $DebugTrackLocal(27, 2844, 3, validator_network_identity_pubkey); }
    if (true) { assume $DebugTrackLocal(27, 2844, 4, validator_network_address); }
    if (true) { assume $DebugTrackLocal(27, 2844, 5, full_node_network_identity_pubkey); }
    if (true) { assume $DebugTrackLocal(27, 2844, 6, full_node_network_address); }

    // bytecode translation starts here
    // $t34 := move(signer)
    call $tmp := $CopyOrMoveValue(signer);
    $t34 := $tmp;

    // $t35 := move(validator_account)
    call $tmp := $CopyOrMoveValue(validator_account);
    $t35 := $tmp;

    // $t36 := move(consensus_pubkey)
    call $tmp := $CopyOrMoveValue(consensus_pubkey);
    $t36 := $tmp;

    // $t37 := move(validator_network_identity_pubkey)
    call $tmp := $CopyOrMoveValue(validator_network_identity_pubkey);
    $t37 := $tmp;

    // $t38 := move(validator_network_address)
    call $tmp := $CopyOrMoveValue(validator_network_address);
    $t38 := $tmp;

    // $t39 := move(full_node_network_identity_pubkey)
    call $tmp := $CopyOrMoveValue(full_node_network_identity_pubkey);
    $t39 := $tmp;

    // $t40 := move(full_node_network_address)
    call $tmp := $CopyOrMoveValue(full_node_network_address);
    $t40 := $tmp;

    // $t12 := move($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t12 := $tmp;

    // $t13 := Signer::address_of($t12)
    call $t13 := $Signer_address_of($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3239);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t15 := ValidatorConfig::get_operator($t35)
    call $t15 := $ValidatorConfig_get_operator($t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 4996);
      goto Abort;
    }
    assume is#$Address($t15);


    // $t16 := ==($t13, $t15)
    $tmp := $Boolean($IsEqual($t13, $t15));
    $t16 := $tmp;

    // $t8 := $t16
    call $tmp := $CopyOrMoveValue($t16);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 3211, 8, $tmp); }

    // if ($t8) goto L0 else goto L1
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t18 := 1
    $tmp := $Integer(1);
    $t18 := $tmp;

    // abort($t18)
    if (true) { assume $DebugTrackAbort(27, 3211); }
    goto Abort;

    // L0:
L0:

    // $t20 := Signature::ed25519_validate_pubkey($t36)
    call $t20 := $Signature_ed25519_validate_pubkey($t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3371);
      goto Abort;
    }
    assume is#$Boolean($t20);


    // $t10 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;
    if (true) { assume $DebugTrackLocal(27, 3353, 10, $tmp); }

    // if ($t10) goto L2 else goto L3
    $tmp := $t10;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t22 := 3
    $tmp := $Integer(3);
    $t22 := $tmp;

    // abort($t22)
    if (true) { assume $DebugTrackAbort(27, 3353); }
    goto Abort;

    // L2:
L2:

    // $t24 := borrow_global<ValidatorConfig::ValidatorConfig>($t35)
    call $t24 := $BorrowGlobal($t35, $ValidatorConfig_ValidatorConfig_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3542);
      goto Abort;
    }
    assume $ValidatorConfig_ValidatorConfig_is_well_formed($Dereference($t24));

    // UnpackRef($t24)
    call $ValidatorConfig_ValidatorConfig_before_update_inv($Dereference($t24));

    // t_ref := $t24
    call t_ref := $CopyOrMoveRef($t24);
    if (true) { assume $DebugTrackLocal(27, 3534, 7, $Dereference(t_ref)); }

    // $t30 := pack ValidatorConfig::Config($t36, $t37, $t38, $t39, $t40)
    call $tmp := $ValidatorConfig_Config_pack(0, 0, 0, $t36, $t37, $t38, $t39, $t40);
    $t30 := $tmp;

    // $t31 := Option::some<ValidatorConfig::Config>($t30)
    call $t31 := $Option_some($ValidatorConfig_Config_type_value(), $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 3628);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t31);


    // $t32 := move(t_ref)
    call $t32 := $CopyOrMoveRef(t_ref);

    // $t33 := borrow_field<ValidatorConfig::ValidatorConfig>.config($t32)
    call $t33 := $BorrowField($t32, $ValidatorConfig_ValidatorConfig_config);
    assume $Option_Option_is_well_formed_types($Dereference($t33));

    // ValidatorConfig::ValidatorConfig <- $t32
    call $WritebackToGlobal($t32);

    // UnpackRef($t33)
    call $Option_Option_before_update_inv($ValidatorConfig_Config_type_value(), $Dereference($t33));

    // write_ref($t33, $t31)
    call $t33 := $WriteRef($t33, $t31);
    if (true) { assume $DebugTrackLocal(27, 3605, 7, $Dereference(t_ref)); }

    // ValidatorConfig::ValidatorConfig <- $t33
    call $WritebackToGlobal($t33);

    // Reference($t32) <- $t33
    call $t32 := $WritebackToReference($t33, $t32);

    // PackRef($t32)
    call $ValidatorConfig_ValidatorConfig_after_update_inv($Dereference($t32));

    // PackRef($t33)
    call $Option_Option_after_update_inv($ValidatorConfig_Config_type_value(), $Dereference($t33));

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $ValidatorConfig_set_config(signer: $Value, validator_account: $Value, consensus_pubkey: $Value, validator_network_identity_pubkey: $Value, validator_network_address: $Value, full_node_network_identity_pubkey: $Value, full_node_network_address: $Value) returns ()
free requires is#$Address(signer);
free requires is#$Address(validator_account);
free requires $Vector_is_well_formed(consensus_pubkey) && (forall $$0: int :: {$select_vector(consensus_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(consensus_pubkey) ==> $IsValidU8($select_vector(consensus_pubkey,$$0)));
free requires $Vector_is_well_formed(validator_network_identity_pubkey) && (forall $$0: int :: {$select_vector(validator_network_identity_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_identity_pubkey) ==> $IsValidU8($select_vector(validator_network_identity_pubkey,$$0)));
free requires $Vector_is_well_formed(validator_network_address) && (forall $$0: int :: {$select_vector(validator_network_address,$$0)} $$0 >= 0 && $$0 < $vlen(validator_network_address) ==> $IsValidU8($select_vector(validator_network_address,$$0)));
free requires $Vector_is_well_formed(full_node_network_identity_pubkey) && (forall $$0: int :: {$select_vector(full_node_network_identity_pubkey,$$0)} $$0 >= 0 && $$0 < $vlen(full_node_network_identity_pubkey) ==> $IsValidU8($select_vector(full_node_network_identity_pubkey,$$0)));
free requires $Vector_is_well_formed(full_node_network_address) && (forall $$0: int :: {$select_vector(full_node_network_address,$$0)} $$0 >= 0 && $$0 < $vlen(full_node_network_address) ==> $IsValidU8($select_vector(full_node_network_address,$$0)));
{
    call $ValidatorConfig_set_config_def(signer, validator_account, consensus_pubkey, validator_network_identity_pubkey, validator_network_address, full_node_network_identity_pubkey, full_node_network_address);
}

procedure {:inline 1} $ValidatorConfig_set_operator_def(account: $Value, operator_account: $Value) returns (){
    // declare local variables
    var sender: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $Option_Option_type_value($AddressType())
    var $t7: $Value; // $AddressType()
    var $t8: $Reference; // ReferenceType($ValidatorConfig_ValidatorConfig_type_value())
    var $t9: $Reference; // ReferenceType($Option_Option_type_value($AddressType()))
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(27, 1794, 0, account); }
    if (true) { assume $DebugTrackLocal(27, 1794, 1, operator_account); }

    // bytecode translation starts here
    // $t10 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t10 := $tmp;

    // $t11 := move(operator_account)
    call $tmp := $CopyOrMoveValue(operator_account);
    $t11 := $tmp;

    // $t3 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1919);
      goto Abort;
    }
    assume is#$Address($t4);


    // sender := $t4
    call $tmp := $CopyOrMoveValue($t4);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(27, 1902, 2, $tmp); }

    // $t6 := Option::some<address>($t11)
    call $t6 := $Option_some($AddressType(), $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 2020);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t6);


    // $t8 := borrow_global<ValidatorConfig::ValidatorConfig>(sender)
    call $t8 := $BorrowGlobal(sender, $ValidatorConfig_ValidatorConfig_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(27, 1949);
      goto Abort;
    }
    assume $ValidatorConfig_ValidatorConfig_is_well_formed($Dereference($t8));

    // UnpackRef($t8)
    call $ValidatorConfig_ValidatorConfig_before_update_inv($Dereference($t8));

    // $t9 := borrow_field<ValidatorConfig::ValidatorConfig>.operator_account($t8)
    call $t9 := $BorrowField($t8, $ValidatorConfig_ValidatorConfig_operator_account);
    assume $Option_Option_is_well_formed_types($Dereference($t9));

    // ValidatorConfig::ValidatorConfig <- $t8
    call $WritebackToGlobal($t8);

    // UnpackRef($t9)
    call $Option_Option_before_update_inv($AddressType(), $Dereference($t9));

    // write_ref($t9, $t6)
    call $t9 := $WriteRef($t9, $t6);

    // ValidatorConfig::ValidatorConfig <- $t9
    call $WritebackToGlobal($t9);

    // Reference($t8) <- $t9
    call $t8 := $WritebackToReference($t9, $t8);

    // PackRef($t8)
    call $ValidatorConfig_ValidatorConfig_after_update_inv($Dereference($t8));

    // PackRef($t9)
    call $Option_Option_after_update_inv($AddressType(), $Dereference($t9));

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $ValidatorConfig_set_operator(account: $Value, operator_account: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(operator_account);
{
    call $ValidatorConfig_set_operator_def(account, operator_account);
}



// ** spec vars of module TransactionFee



// ** spec funs of module TransactionFee



// ** structs of module TransactionFee

const unique $TransactionFee_TransactionFee: $TypeName;
const $TransactionFee_TransactionFee_balance: $FieldName;
axiom $TransactionFee_TransactionFee_balance == 0;
const $TransactionFee_TransactionFee_preburn: $FieldName;
axiom $TransactionFee_TransactionFee_preburn == 1;
function $TransactionFee_TransactionFee_type_value($tv0: $TypeValue): $TypeValue {
    $StructType($TransactionFee_TransactionFee, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Libra_Libra_type_value($tv0)][1 := $Libra_Preburn_type_value($tv0)], 2))
}
function {:inline} $TransactionFee_TransactionFee_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $Libra_Libra_is_well_formed_types($SelectField($this, $TransactionFee_TransactionFee_balance))
      && $Libra_Preburn_is_well_formed_types($SelectField($this, $TransactionFee_TransactionFee_preburn))
}
function {:inline} $TransactionFee_TransactionFee_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $Libra_Libra_is_well_formed($SelectField($this, $TransactionFee_TransactionFee_balance))
      && $Libra_Preburn_is_well_formed($SelectField($this, $TransactionFee_TransactionFee_preburn))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $TransactionFee_TransactionFee_is_well_formed($ResourceValue(m, $TransactionFee_TransactionFee_type_value($tv0), a))
);

procedure {:inline 1} $TransactionFee_TransactionFee_before_update_inv($tv0: $TypeValue, $before: $Value) {
    call $Libra_Libra_before_update_inv($tv0, $SelectField($before, $TransactionFee_TransactionFee_balance));
}

procedure {:inline 1} $TransactionFee_TransactionFee_after_update_inv($tv0: $TypeValue, $after: $Value) {
    call $Libra_Libra_after_update_inv($tv0, $SelectField($after, $TransactionFee_TransactionFee_balance));
}

procedure {:inline 1} $TransactionFee_TransactionFee_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, balance: $Value, preburn: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_is_well_formed(balance);
    assume $Libra_Preburn_is_well_formed(preburn);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := balance][1 := preburn], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $TransactionFee_TransactionFee_unpack($tv0: $TypeValue, $struct: $Value) returns (balance: $Value, preburn: $Value)
{
    assume is#$Vector($struct);
    balance := $SelectField($struct, $TransactionFee_TransactionFee_balance);
    assume $Libra_Libra_is_well_formed(balance);
    preburn := $SelectField($struct, $TransactionFee_TransactionFee_preburn);
    assume $Libra_Preburn_is_well_formed(preburn);
}



// ** functions of module TransactionFee

procedure {:inline 1} $TransactionFee_initialize_def(assoc_account: $Value, tc_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $BooleanType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $t31: $Value; // $AddressType()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $AddressType()
    var $t34: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 841, 0, assoc_account); }
    if (true) { assume $DebugTrackLocal(25, 841, 1, tc_account); }

    // bytecode translation starts here
    // $t33 := move(assoc_account)
    call $tmp := $CopyOrMoveValue(assoc_account);
    $t33 := $tmp;

    // $t34 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t34 := $tmp;

    // $t8 := LibraTimestamp::is_genesis()
    call $t8 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 964);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t2 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(25, 941, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t11 := $tmp;

    // destroy($t11)

    // $t12 := 0
    $tmp := $Integer(0);
    $t12 := $tmp;

    // abort($t12)
    if (true) { assume $DebugTrackAbort(25, 941); }
    goto Abort;

    // L0:
L0:

    // $t13 := copy($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t13 := $tmp;

    // $t14 := Signer::address_of($t13)
    call $t14 := $Signer_address_of($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1029);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t15 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1073);
      goto Abort;
    }
    assume is#$Address($t15);


    // $t16 := ==($t14, $t15)
    $tmp := $Boolean($IsEqual($t14, $t15));
    $t16 := $tmp;

    // $t4 := $t16
    call $tmp := $CopyOrMoveValue($t16);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(25, 1001, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t18 := move($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t18 := $tmp;

    // destroy($t18)

    // $t19 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t19 := $tmp;

    // destroy($t19)

    // $t20 := 2
    $tmp := $Integer(2);
    $t20 := $tmp;

    // abort($t20)
    if (true) { assume $DebugTrackAbort(25, 1001); }
    goto Abort;

    // L2:
L2:

    // $t21 := copy($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t21 := $tmp;

    // $t22 := Roles::has_treasury_compliance_role($t21)
    call $t22 := $Roles_has_treasury_compliance_role($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1167);
      goto Abort;
    }
    assume is#$Boolean($t22);


    // $t6 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(25, 1153, 6, $tmp); }

    // if ($t6) goto L4 else goto L5
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t24 := move($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t24 := $tmp;

    // destroy($t24)

    // $t25 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t25 := $tmp;

    // destroy($t25)

    // $t26 := 1
    $tmp := $Integer(1);
    $t26 := $tmp;

    // abort($t26)
    if (true) { assume $DebugTrackAbort(25, 1153); }
    goto Abort;

    // L4:
L4:

    // $t27 := copy($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t27 := $tmp;

    // $t28 := copy($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t28 := $tmp;

    // TransactionFee::add_txn_fee_currency<Coin1::Coin1>($t27, $t28)
    call $TransactionFee_add_txn_fee_currency($Coin1_Coin1_type_value(), $t27, $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1719);
      goto Abort;
    }

    // $t29 := copy($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t29 := $tmp;

    // $t30 := copy($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t30 := $tmp;

    // TransactionFee::add_txn_fee_currency<Coin2::Coin2>($t29, $t30)
    call $TransactionFee_add_txn_fee_currency($Coin2_Coin2_type_value(), $t29, $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1719);
      goto Abort;
    }

    // $t31 := move($t33)
    call $tmp := $CopyOrMoveValue($t33);
    $t31 := $tmp;

    // $t32 := move($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t32 := $tmp;

    // TransactionFee::add_txn_fee_currency<LBR::LBR>($t31, $t32)
    call $TransactionFee_add_txn_fee_currency($LBR_LBR_type_value(), $t31, $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1719);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $TransactionFee_initialize(assoc_account: $Value, tc_account: $Value) returns ()
free requires is#$Address(assoc_account);
free requires is#$Address(tc_account);
{
    call $TransactionFee_initialize_def(assoc_account, tc_account);
}

procedure {:inline 1} $TransactionFee_add_txn_fee_currency_def($tv0: $TypeValue, assoc_account: $Value, tc_account: $Value) returns (){
    // declare local variables
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $Libra_Libra_type_value($tv0)
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_Preburn_type_value($tv0)
    var $t6: $Value; // $TransactionFee_TransactionFee_type_value($tv0)
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 1715, 0, assoc_account); }
    if (true) { assume $DebugTrackLocal(25, 1715, 1, tc_account); }

    // bytecode translation starts here
    // $t7 := move(assoc_account)
    call $tmp := $CopyOrMoveValue(assoc_account);
    $t7 := $tmp;

    // $t8 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t8 := $tmp;

    // $t2 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t2 := $tmp;

    // $t3 := Libra::zero<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t3 := $Libra_zero($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1935);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t3);


    // $t4 := move($t8)
    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;

    // $t5 := Libra::create_preburn<#0>($t4)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t5 := $Libra_create_preburn($tv0, $t4);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1975);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t5);


    // $t6 := pack TransactionFee::TransactionFee<#0>($t3, $t5)
    call $tmp := $TransactionFee_TransactionFee_pack(0, 0, 0, $tv0, $t3, $t5);
    $t6 := $tmp;

    // move_to<TransactionFee::TransactionFee<#0>>($t6, $t2)
    call $MoveTo($TransactionFee_TransactionFee_type_value($tv0), $t6, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 1828);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $TransactionFee_add_txn_fee_currency($tv0: $TypeValue, assoc_account: $Value, tc_account: $Value) returns ()
free requires is#$Address(assoc_account);
free requires is#$Address(tc_account);
{
    call $TransactionFee_add_txn_fee_currency_def($tv0, assoc_account, tc_account);
}

procedure {:inline 1} $TransactionFee_burn_fees_def($tv0: $TypeValue, tc_account: $Value) returns (){
    // declare local variables
    var burn_cap: $Value; // $Libra_BurnCapability_type_value($tv0)
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var coin1: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var coin1_burn_cap: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var coin2: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var coin2_burn_cap: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var coins: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var fee_address: $Value; // $AddressType()
    var fees: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($LBR_LBR_type_value()))
    var fees#1624: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $AddressType()
    var $t14: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($LBR_LBR_type_value()))
    var $t15: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($LBR_LBR_type_value()))
    var $t16: $Reference; // ReferenceType($Libra_Libra_type_value($LBR_LBR_type_value()))
    var $t17: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t18: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t19: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t20: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var $t25: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var $t26: $Value; // $AddressType()
    var $t27: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($Coin1_Coin1_type_value()))
    var $t28: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t29: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var $t30: $Value; // $AddressType()
    var $t31: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($Coin2_Coin2_type_value()))
    var $t32: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t33: $Value; // $AddressType()
    var $t34: $Value; // $Libra_BurnCapability_type_value($Coin1_Coin1_type_value())
    var $t35: $Value; // $AddressType()
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $Libra_BurnCapability_type_value($Coin2_Coin2_type_value())
    var $t38: $Value; // $AddressType()
    var $t39: $Value; // $AddressType()
    var $t40: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t41: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t42: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t43: $Value; // $Libra_Libra_type_value($tv0)
    var $t44: $Value; // $AddressType()
    var $t45: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t46: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t47: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t48: $Value; // $Libra_Libra_type_value($tv0)
    var $t49: $Value; // $AddressType()
    var $t50: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t51: $Value; // $AddressType()
    var $t52: $Value; // $AddressType()
    var $t53: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t54: $Value; // $Libra_Libra_type_value($tv0)
    var $t55: $Value; // $TransactionFee_TransactionFee_type_value($Coin2_Coin2_type_value())
    var $t56: $Value; // $TransactionFee_TransactionFee_type_value($Coin1_Coin1_type_value())
    var $t57: $Value; // $TransactionFee_TransactionFee_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 2525, 0, tc_account); }

    // bytecode translation starts here
    // $t52 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t52 := $tmp;

    // $t11 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2660);
      goto Abort;
    }
    assume is#$Address($t11);


    // fee_address := $t11
    call $tmp := $CopyOrMoveValue($t11);
    fee_address := $tmp;
    if (true) { assume $DebugTrackLocal(25, 2630, 8, $tmp); }

    // $t12 := LBR::is_lbr<#0>()
    call $t12 := $LBR_is_lbr($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2699);
      goto Abort;
    }
    assume is#$Boolean($t12);


    // if ($t12) goto L0 else goto L1
    $tmp := $t12;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t14 := borrow_global<TransactionFee::TransactionFee<LBR::LBR>>(fee_address)
    call $t14 := $BorrowGlobal(fee_address, $TransactionFee_TransactionFee_type_value($LBR_LBR_type_value()));
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2772);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($Dereference($t14));

    // UnpackRef($t14)
    call $TransactionFee_TransactionFee_before_update_inv($LBR_LBR_type_value(), $Dereference($t14));

    // fees := $t14
    call fees := $CopyOrMoveRef($t14);
    if (true) { assume $DebugTrackLocal(25, 2765, 9, $Dereference(fees)); }

    // $t15 := move(fees)
    call $t15 := $CopyOrMoveRef(fees);

    // $t16 := borrow_field<TransactionFee::TransactionFee<LBR::LBR>>.balance($t15)
    call $t16 := $BorrowField($t15, $TransactionFee_TransactionFee_balance);
    assume $Libra_Libra_is_well_formed_types($Dereference($t16));

    // TransactionFee::TransactionFee <- $t15
    call $WritebackToGlobal($t15);

    // UnpackRef($t16)
    call $Libra_Libra_before_update_inv($LBR_LBR_type_value(), $Dereference($t16));

    // PackRef($t16)
    call $Libra_Libra_after_update_inv($LBR_LBR_type_value(), $Dereference($t16));

    // $t53 := read_ref($t16)
    call $tmp := $ReadRef($t16);
    assume $Libra_Libra_is_well_formed($tmp);
    $t53 := $tmp;

    // ($t17, $t53) := Libra::withdraw_all<LBR::LBR>($t53)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $LBR_LBR_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$LBR_LBR_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($LBR_LBR_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t17, $t53 := $Libra_withdraw_all($LBR_LBR_type_value(), $t53);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2856);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t17);

    assume $Libra_Libra_is_well_formed($t53);


    // write_ref($t16, $t53)
    call $t16 := $WriteRef($t16, $t53);
    if (true) { assume $DebugTrackLocal(25, 3981, 9, $Dereference(fees)); }
    if (true) { assume $DebugTrackLocal(25, 3981, 10, $Dereference(fees#1624)); }

    // TransactionFee::TransactionFee <- $t16
    call $WritebackToGlobal($t16);

    // Reference($t15) <- $t16
    call $t15 := $WritebackToReference($t16, $t15);

    // UnpackRef($t16)
    call $Libra_Libra_before_update_inv($LBR_LBR_type_value(), $Dereference($t16));

    // PackRef($t15)
    call $TransactionFee_TransactionFee_after_update_inv($LBR_LBR_type_value(), $Dereference($t15));

    // PackRef($t16)
    call $Libra_Libra_after_update_inv($LBR_LBR_type_value(), $Dereference($t16));

    // coins := $t17
    call $tmp := $CopyOrMoveValue($t17);
    coins := $tmp;
    if (true) { assume $DebugTrackLocal(25, 2841, 7, $tmp); }

    // ($t19, $t20) := LBR::unpack(coins)
    call $t19, $t20 := $LBR_unpack(coins);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2932);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t19);

    assume $Libra_Libra_is_well_formed($t20);


    // coin2 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(25, 2918, 5, $tmp); }

    // coin1 := $t19
    call $tmp := $CopyOrMoveValue($t19);
    coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(25, 2911, 3, $tmp); }

    // $t21 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t21 := $tmp;

    // $t22 := Libra::remove_burn_capability<Coin1::Coin1>($t21)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t22 := $Libra_remove_burn_capability($Coin1_Coin1_type_value(), $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3007);
      goto Abort;
    }
    assume $Libra_BurnCapability_is_well_formed($t22);


    // coin1_burn_cap := $t22
    call $tmp := $CopyOrMoveValue($t22);
    coin1_burn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(25, 2983, 4, $tmp); }

    // $t23 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t23 := $tmp;

    // $t24 := Libra::remove_burn_capability<Coin2::Coin2>($t23)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t24 := $Libra_remove_burn_capability($Coin2_Coin2_type_value(), $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3090);
      goto Abort;
    }
    assume $Libra_BurnCapability_is_well_formed($t24);


    // coin2_burn_cap := $t24
    call $tmp := $CopyOrMoveValue($t24);
    coin2_burn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(25, 3066, 6, $tmp); }

    // $t25 := copy(coin1_burn_cap)
    call $tmp := $CopyOrMoveValue(coin1_burn_cap);
    $t25 := $tmp;

    // $t27 := borrow_global<TransactionFee::TransactionFee<Coin1::Coin1>>(fee_address)
    call $t27 := $BorrowGlobal(fee_address, $TransactionFee_TransactionFee_type_value($Coin1_Coin1_type_value()));
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3213);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($Dereference($t27));

    // UnpackRef($t27)
    call $TransactionFee_TransactionFee_before_update_inv($Coin1_Coin1_type_value(), $Dereference($t27));

    // $t56 := read_ref($t27)
    call $tmp := $ReadRef($t27);
    assume $TransactionFee_TransactionFee_is_well_formed($tmp);
    $t56 := $tmp;

    // $t56 := TransactionFee::preburn_burn_fees<Coin1::Coin1>($t25, $t56, coin1)
    call $t56 := $TransactionFee_preburn_burn_fees($Coin1_Coin1_type_value(), $t25, $t56, coin1);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4191);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($t56);


    // write_ref($t27, $t56)
    call $t27 := $WriteRef($t27, $t56);
    if (true) { assume $DebugTrackLocal(25, 4031, 9, $Dereference(fees)); }
    if (true) { assume $DebugTrackLocal(25, 4031, 10, $Dereference(fees#1624)); }

    // TransactionFee::TransactionFee <- $t27
    call $WritebackToGlobal($t27);

    // PackRef($t27)
    call $TransactionFee_TransactionFee_after_update_inv($Coin1_Coin1_type_value(), $Dereference($t27));

    // $t29 := copy(coin2_burn_cap)
    call $tmp := $CopyOrMoveValue(coin2_burn_cap);
    $t29 := $tmp;

    // $t31 := borrow_global<TransactionFee::TransactionFee<Coin2::Coin2>>(fee_address)
    call $t31 := $BorrowGlobal(fee_address, $TransactionFee_TransactionFee_type_value($Coin2_Coin2_type_value()));
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3385);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($Dereference($t31));

    // UnpackRef($t31)
    call $TransactionFee_TransactionFee_before_update_inv($Coin2_Coin2_type_value(), $Dereference($t31));

    // $t55 := read_ref($t31)
    call $tmp := $ReadRef($t31);
    assume $TransactionFee_TransactionFee_is_well_formed($tmp);
    $t55 := $tmp;

    // $t55 := TransactionFee::preburn_burn_fees<Coin2::Coin2>($t29, $t55, coin2)
    call $t55 := $TransactionFee_preburn_burn_fees($Coin2_Coin2_type_value(), $t29, $t55, coin2);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4191);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($t55);


    // write_ref($t31, $t55)
    call $t31 := $WriteRef($t31, $t55);
    if (true) { assume $DebugTrackLocal(25, 4053, 9, $Dereference(fees)); }
    if (true) { assume $DebugTrackLocal(25, 4053, 10, $Dereference(fees#1624)); }

    // TransactionFee::TransactionFee <- $t31
    call $WritebackToGlobal($t31);

    // PackRef($t31)
    call $TransactionFee_TransactionFee_after_update_inv($Coin2_Coin2_type_value(), $Dereference($t31));

    // $t33 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t33 := $tmp;

    // $t35 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t35 := $tmp;

    // Libra::publish_burn_capability<Coin1::Coin1>($t33, coin1_burn_cap, $t35)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin1_Coin1_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin1_Coin1_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin1_Coin1_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_burn_capability($Coin1_Coin1_type_value(), $t33, coin1_burn_cap, $t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3496);
      goto Abort;
    }

    // $t36 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t36 := $tmp;

    // $t38 := move($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t38 := $tmp;

    // Libra::publish_burn_capability<Coin2::Coin2>($t36, coin2_burn_cap, $t38)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $Coin2_Coin2_type_value())) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$Coin2_Coin2_type_value()], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($Coin2_Coin2_type_value()), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_burn_capability($Coin2_Coin2_type_value(), $t36, coin2_burn_cap, $t38);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3580);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t40 := borrow_global<TransactionFee::TransactionFee<#0>>(fee_address)
    call $t40 := $BorrowGlobal(fee_address, $TransactionFee_TransactionFee_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3713);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($Dereference($t40));

    // UnpackRef($t40)
    call $TransactionFee_TransactionFee_before_update_inv($tv0, $Dereference($t40));

    // fees#1624 := $t40
    call fees#1624 := $CopyOrMoveRef($t40);
    if (true) { assume $DebugTrackLocal(25, 3706, 10, $Dereference(fees#1624)); }

    // $t41 := copy(fees#1624)
    call $t41 := $CopyOrMoveRef(fees#1624);

    // $t42 := borrow_field<TransactionFee::TransactionFee<#0>>.balance($t41)
    call $t42 := $BorrowField($t41, $TransactionFee_TransactionFee_balance);
    assume $Libra_Libra_is_well_formed_types($Dereference($t42));

    // Reference(fees#1624) <- $t41
    call fees#1624 := $WritebackToReference($t41, fees#1624);

    // UnpackRef($t42)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t42));

    // PackRef($t42)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t42));

    // $t54 := read_ref($t42)
    call $tmp := $ReadRef($t42);
    assume $Libra_Libra_is_well_formed($tmp);
    $t54 := $tmp;

    // ($t43, $t54) := Libra::withdraw_all<#0>($t54)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t43, $t54 := $Libra_withdraw_all($tv0, $t54);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3801);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t43);

    assume $Libra_Libra_is_well_formed($t54);


    // write_ref($t42, $t54)
    call $t42 := $WriteRef($t42, $t54);
    if (true) { assume $DebugTrackLocal(25, 2690, 9, $Dereference(fees)); }
    if (true) { assume $DebugTrackLocal(25, 2690, 10, $Dereference(fees#1624)); }

    // Reference(fees#1624) <- $t42
    call fees#1624 := $WritebackToReference($t42, fees#1624);

    // Reference($t41) <- $t42
    call $t41 := $WritebackToReference($t42, $t41);

    // UnpackRef($t42)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t42));

    // PackRef($t42)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t42));

    // coin := $t43
    call $tmp := $CopyOrMoveValue($t43);
    coin := $tmp;
    if (true) { assume $DebugTrackLocal(25, 3787, 2, $tmp); }

    // $t44 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t44 := $tmp;

    // $t45 := Libra::remove_burn_capability<#0>($t44)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t45 := $Libra_remove_burn_capability($tv0, $t44);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 3888);
      goto Abort;
    }
    assume $Libra_BurnCapability_is_well_formed($t45);


    // burn_cap := $t45
    call $tmp := $CopyOrMoveValue($t45);
    burn_cap := $tmp;
    if (true) { assume $DebugTrackLocal(25, 3870, 1, $tmp); }

    // $t46 := copy(burn_cap)
    call $tmp := $CopyOrMoveValue(burn_cap);
    $t46 := $tmp;

    // $t47 := move(fees#1624)
    call $t47 := $CopyOrMoveRef(fees#1624);

    // $t57 := read_ref($t47)
    call $tmp := $ReadRef($t47);
    assume $TransactionFee_TransactionFee_is_well_formed($tmp);
    $t57 := $tmp;

    // $t57 := TransactionFee::preburn_burn_fees<#0>($t46, $t57, coin)
    call $t57 := $TransactionFee_preburn_burn_fees($tv0, $t46, $t57, coin);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4191);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($t57);


    // write_ref($t47, $t57)
    call $t47 := $WriteRef($t47, $t57);
    if (true) { assume $DebugTrackLocal(25, 2525, 9, $Dereference(fees)); }
    if (true) { assume $DebugTrackLocal(25, 2525, 10, $Dereference(fees#1624)); }

    // TransactionFee::TransactionFee <- $t47
    call $WritebackToGlobal($t47);

    // PackRef($t47)
    call $TransactionFee_TransactionFee_after_update_inv($tv0, $Dereference($t47));

    // $t49 := copy($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t49 := $tmp;

    // $t51 := move($t52)
    call $tmp := $CopyOrMoveValue($t52);
    $t51 := $tmp;

    // Libra::publish_burn_capability<#0>($t49, burn_cap, $t51)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_burn_capability($tv0, $t49, burn_cap, $t51);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4007);
      goto Abort;
    }

    // goto L3
    goto L3;

    // L3:
L3:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $TransactionFee_burn_fees($tv0: $TypeValue, tc_account: $Value) returns ()
free requires is#$Address(tc_account);
{
    call $TransactionFee_burn_fees_def($tv0, tc_account);
}

procedure {:inline 1} $TransactionFee_pay_fee_def($tv0: $TypeValue, coin: $Value) returns (){
    // declare local variables
    var fees: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t2: $Value; // $AddressType()
    var $t3: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t4: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t5: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t6: $Value; // $Libra_Libra_type_value($tv0)
    var $t7: $Value; // $Libra_Libra_type_value($tv0)
    var $t8: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 2093, 0, coin); }

    // bytecode translation starts here
    // $t7 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t7 := $tmp;

    // $t2 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t2 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2262);
      goto Abort;
    }
    assume is#$Address($t2);


    // $t3 := borrow_global<TransactionFee::TransactionFee<#0>>($t2)
    call $t3 := $BorrowGlobal($t2, $TransactionFee_TransactionFee_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2190);
      goto Abort;
    }
    assume $TransactionFee_TransactionFee_is_well_formed($Dereference($t3));

    // UnpackRef($t3)
    call $TransactionFee_TransactionFee_before_update_inv($tv0, $Dereference($t3));

    // fees := $t3
    call fees := $CopyOrMoveRef($t3);
    if (true) { assume $DebugTrackLocal(25, 2183, 1, $Dereference(fees)); }

    // $t4 := move(fees)
    call $t4 := $CopyOrMoveRef(fees);

    // $t5 := borrow_field<TransactionFee::TransactionFee<#0>>.balance($t4)
    call $t5 := $BorrowField($t4, $TransactionFee_TransactionFee_balance);
    assume $Libra_Libra_is_well_formed_types($Dereference($t5));

    // TransactionFee::TransactionFee <- $t4
    call $WritebackToGlobal($t4);

    // UnpackRef($t5)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t5));

    // PackRef($t5)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t5));

    // $t8 := read_ref($t5)
    call $tmp := $ReadRef($t5);
    assume $Libra_Libra_is_well_formed($tmp);
    $t8 := $tmp;

    // $t8 := Libra::deposit<#0>($t8, $t7)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t8 := $Libra_deposit($tv0, $t8, $t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 2309);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t8);


    // write_ref($t5, $t8)
    call $t5 := $WriteRef($t5, $t8);
    if (true) { assume $DebugTrackLocal(25, 2093, 1, $Dereference(fees)); }

    // TransactionFee::TransactionFee <- $t5
    call $WritebackToGlobal($t5);

    // Reference($t4) <- $t5
    call $t4 := $WritebackToReference($t5, $t4);

    // UnpackRef($t5)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t5));

    // PackRef($t4)
    call $TransactionFee_TransactionFee_after_update_inv($tv0, $Dereference($t4));

    // PackRef($t5)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t5));

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $TransactionFee_pay_fee($tv0: $TypeValue, coin: $Value) returns ()
free requires $Libra_Libra_is_well_formed(coin);
{
    call $TransactionFee_pay_fee_def($tv0, coin);
}

procedure {:inline 1} $TransactionFee_preburn_burn_fees_def($tv0: $TypeValue, burn_cap: $Value, fees: $Value, coin: $Value) returns ($ret0: $Value){
    // declare local variables
    var preburn: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var tc_address: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t7: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t8: $Value; // $Libra_Libra_type_value($tv0)
    var $t9: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t10: $Value; // $AddressType()
    var $t11: $Reference; // ReferenceType($Libra_Preburn_type_value($tv0))
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t14: $Value; // $Libra_BurnCapability_type_value($tv0)
    var $t15: $Value; // $TransactionFee_TransactionFee_type_value($tv0)
    var $t16: $Reference; // ReferenceType($TransactionFee_TransactionFee_type_value($tv0))
    var $t17: $Value; // $Libra_Libra_type_value($tv0)
    var $t18: $Value; // $Libra_Preburn_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(25, 4187, 0, burn_cap); }
    if (true) { assume $DebugTrackLocal(25, 4187, 1, fees); }
    if (true) { assume $DebugTrackLocal(25, 4187, 2, coin); }

    // bytecode translation starts here
    // $t14 := move(burn_cap)
    call $tmp := $CopyOrMoveValue(burn_cap);
    $t14 := $tmp;

    // $t15 := move(fees)
    call $tmp := $CopyOrMoveValue(fees);
    $t15 := $tmp;

    // $t17 := move(coin)
    call $tmp := $CopyOrMoveValue(coin);
    $t17 := $tmp;

    // $t16 := borrow_local($t15)
    call $t16 := $BorrowLoc(15, $t15);
    assume $TransactionFee_TransactionFee_is_well_formed($Dereference($t16));

    // $t5 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t5 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4388);
      goto Abort;
    }
    assume is#$Address($t5);


    // tc_address := $t5
    call $tmp := $CopyOrMoveValue($t5);
    tc_address := $tmp;
    if (true) { assume $DebugTrackLocal(25, 4360, 4, $tmp); }

    // $t6 := move($t16)
    call $t6 := $CopyOrMoveRef($t16);

    // $t7 := borrow_field<TransactionFee::TransactionFee<#0>>.preburn($t6)
    call $t7 := $BorrowField($t6, $TransactionFee_TransactionFee_preburn);
    assume $Libra_Preburn_is_well_formed_types($Dereference($t7));

    // LocalRoot($t15) <- $t6
    call $t15 := $WritebackToValue($t6, 15, $t15);

    // UnpackRef($t7)

    // preburn := $t7
    call preburn := $CopyOrMoveRef($t7);
    if (true) { assume $DebugTrackLocal(25, 4431, 3, $Dereference(preburn)); }

    // $t9 := copy(preburn)
    call $t9 := $CopyOrMoveRef(preburn);

    // PackRef($t9)

    // $t18 := read_ref($t9)
    call $tmp := $ReadRef($t9);
    assume $Libra_Preburn_is_well_formed($tmp);
    $t18 := $tmp;

    // $t18 := Libra::preburn_with_resource<#0>($t17, $t18, tc_address)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t18 := $Libra_preburn_with_resource($tv0, $t17, $t18, tc_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4475);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t18);


    // write_ref($t9, $t18)
    call $t9 := $WriteRef($t9, $t18);
    if (true) { assume $DebugTrackLocal(25, 4187, 3, $Dereference(preburn)); }

    // Reference(preburn) <- $t9
    call preburn := $WritebackToReference($t9, preburn);

    // UnpackRef($t9)

    // $t11 := move(preburn)
    call $t11 := $CopyOrMoveRef(preburn);

    // $t13 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t13 := $tmp;

    // PackRef($t11)

    // $t18 := read_ref($t11)
    call $tmp := $ReadRef($t11);
    assume $Libra_Preburn_is_well_formed($tmp);
    $t18 := $tmp;

    // $t18 := Libra::burn_with_resource_cap<#0>($t18, tc_address, $t13)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t18 := $Libra_burn_with_resource_cap($tv0, $t18, tc_address, $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(25, 4540);
      goto Abort;
    }
    assume $Libra_Preburn_is_well_formed($t18);


    // write_ref($t11, $t18)
    call $t11 := $WriteRef($t11, $t18);
    if (true) { assume $DebugTrackLocal(25, 4187, 3, $Dereference(preburn)); }

    // LocalRoot($t15) <- $t11
    call $t15 := $WritebackToValue($t11, 15, $t15);

    // Reference($t6) <- $t11
    call $t6 := $WritebackToReference($t11, $t6);

    // UnpackRef($t11)

    // PackRef($t11)

    // return $t15
    $ret0 := $t15;
    if (true) { assume $DebugTrackLocal(25, 4533, 19, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $TransactionFee_preburn_burn_fees($tv0: $TypeValue, burn_cap: $Value, fees: $Value, coin: $Value) returns ($ret0: $Value)
free requires $Libra_BurnCapability_is_well_formed(burn_cap);
free requires $TransactionFee_TransactionFee_is_well_formed(fees);
free requires $Libra_Libra_is_well_formed(coin);
{
    call $ret0 := $TransactionFee_preburn_burn_fees_def($tv0, burn_cap, fees, coin);
}



// ** spec vars of module SlidingNonce



// ** spec funs of module SlidingNonce



// ** structs of module SlidingNonce

const unique $SlidingNonce_SlidingNonce: $TypeName;
const $SlidingNonce_SlidingNonce_min_nonce: $FieldName;
axiom $SlidingNonce_SlidingNonce_min_nonce == 0;
const $SlidingNonce_SlidingNonce_nonce_mask: $FieldName;
axiom $SlidingNonce_SlidingNonce_nonce_mask == 1;
function $SlidingNonce_SlidingNonce_type_value(): $TypeValue {
    $StructType($SlidingNonce_SlidingNonce, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $IntegerType()], 2))
}
function {:inline} $SlidingNonce_SlidingNonce_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $SlidingNonce_SlidingNonce_min_nonce))
      && $IsValidU128($SelectField($this, $SlidingNonce_SlidingNonce_nonce_mask))
}
function {:inline} $SlidingNonce_SlidingNonce_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && $IsValidU64($SelectField($this, $SlidingNonce_SlidingNonce_min_nonce))
      && $IsValidU128($SelectField($this, $SlidingNonce_SlidingNonce_nonce_mask))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $SlidingNonce_SlidingNonce_is_well_formed($ResourceValue(m, $SlidingNonce_SlidingNonce_type_value(), a))
);

procedure {:inline 1} $SlidingNonce_SlidingNonce_pack($file_id: int, $byte_index: int, $var_idx: int, min_nonce: $Value, nonce_mask: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(min_nonce);
    assume $IsValidU128(nonce_mask);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := min_nonce][1 := nonce_mask], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $SlidingNonce_SlidingNonce_unpack($struct: $Value) returns (min_nonce: $Value, nonce_mask: $Value)
{
    assume is#$Vector($struct);
    min_nonce := $SelectField($struct, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64(min_nonce);
    nonce_mask := $SelectField($struct, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128(nonce_mask);
}



// ** functions of module SlidingNonce

procedure {:inline 1} $SlidingNonce_publish_def(account: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $SlidingNonce_SlidingNonce_type_value()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(24, 2987, 0, account); }

    // bytecode translation starts here
    // $t5 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t5 := $tmp;

    // $t1 := move($t5)
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;

    // $t2 := 0
    $tmp := $Integer(0);
    $t2 := $tmp;

    // $t3 := 0
    $tmp := $Integer(0);
    $t3 := $tmp;

    // $t4 := pack SlidingNonce::SlidingNonce($t2, $t3)
    call $tmp := $SlidingNonce_SlidingNonce_pack(0, 0, 0, $t2, $t3);
    $t4 := $tmp;

    // move_to<SlidingNonce::SlidingNonce>($t4, $t1)
    call $MoveTo($SlidingNonce_SlidingNonce_type_value(), $t4, $t1);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 3034);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $SlidingNonce_publish(account: $Value) returns ()
free requires is#$Address(account);
{
    call $SlidingNonce_publish_def(account);
}

procedure {:inline 1} $SlidingNonce_publish_nonce_resource_def(lr_account: $Value, account: $Value) returns (){
    // declare local variables
    var new_resource: $Value; // $SlidingNonce_SlidingNonce_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $SlidingNonce_SlidingNonce_type_value()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(24, 3337, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(24, 3337, 1, account); }

    // bytecode translation starts here
    // $t14 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;

    // $t15 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t15 := $tmp;

    // $t5 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;

    // $t6 := Roles::has_libra_root_role($t5)
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 3456);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(24, 3442, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 4
    $tmp := $Integer(4);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(24, 3442); }
    goto Abort;

    // L0:
L0:

    // $t10 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t10 := $tmp;

    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // $t12 := 0
    $tmp := $Integer(0);
    $t12 := $tmp;

    // $t13 := pack SlidingNonce::SlidingNonce($t11, $t12)
    call $tmp := $SlidingNonce_SlidingNonce_pack(0, 0, 0, $t11, $t12);
    $t13 := $tmp;

    // move_to<SlidingNonce::SlidingNonce>($t13, $t10)
    call $MoveTo($SlidingNonce_SlidingNonce_type_value(), $t13, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 3621);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $SlidingNonce_publish_nonce_resource(lr_account: $Value, account: $Value) returns ()
free requires is#$Address(lr_account);
free requires is#$Address(account);
{
    call $SlidingNonce_publish_nonce_resource_def(lr_account, account);
}

procedure {:inline 1} $SlidingNonce_record_nonce_or_abort_def(account: $Value, seq_nonce: $Value) returns (){
    // declare local variables
    var code: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(24, 1335, 0, account); }
    if (true) { assume $DebugTrackLocal(24, 1335, 1, seq_nonce); }

    // bytecode translation starts here
    // $t14 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t14 := $tmp;

    // $t15 := move(seq_nonce)
    call $tmp := $CopyOrMoveValue(seq_nonce);
    $t15 := $tmp;

    // $t5 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;

    // $t7 := SlidingNonce::try_record_nonce($t5, $t15)
    call $t7 := $SlidingNonce_try_record_nonce($t5, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 1651);
      goto Abort;
    }
    assume $IsValidU64($t7);


    // code := $t7
    call $tmp := $CopyOrMoveValue($t7);
    code := $tmp;
    if (true) { assume $DebugTrackLocal(24, 1438, 2, $tmp); }

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // $t10 := ==(code, $t9)
    $tmp := $Boolean($IsEqual(code, $t9));
    $t10 := $tmp;

    // $t4 := code
    call $tmp := $CopyOrMoveValue(code);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(24, 1491, 4, $tmp); }

    // $t3 := $t10
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(24, 1491, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // abort($t4)
    if (true) { assume $DebugTrackAbort(24, 1491); }
    goto Abort;

    // L0:
L0:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $SlidingNonce_record_nonce_or_abort(account: $Value, seq_nonce: $Value) returns ()
free requires is#$Address(account);
free requires $IsValidU64(seq_nonce);
{
    call $SlidingNonce_record_nonce_or_abort_def(account, seq_nonce);
}

procedure {:inline 1} $SlidingNonce_try_record_nonce_def(account: $Value, seq_nonce: $Value) returns ($ret0: $Value){
    // declare local variables
    var bit_pos: $Value; // $IntegerType()
    var bit_pos#1623: $Value; // $IntegerType()
    var jump_limit: $Value; // $IntegerType()
    var set: $Value; // $IntegerType()
    var shift: $Value; // $IntegerType()
    var t: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t16: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t22: $Value; // $IntegerType()
    var $t23: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $IntegerType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $BooleanType()
    var $t30: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $IntegerType()
    var $t33: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $t37: $Value; // $IntegerType()
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $BooleanType()
    var $t40: $Value; // $IntegerType()
    var $t41: $Value; // $IntegerType()
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $IntegerType()
    var $t44: $Value; // $IntegerType()
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $IntegerType()
    var $t47: $Value; // $BooleanType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t50: $Reference; // ReferenceType($IntegerType())
    var $t51: $Value; // $IntegerType()
    var $t52: $Value; // $IntegerType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Value; // $IntegerType()
    var $t55: $Value; // $IntegerType()
    var $t56: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t57: $Reference; // ReferenceType($IntegerType())
    var $t58: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t59: $Value; // $IntegerType()
    var $t60: $Value; // $IntegerType()
    var $t61: $Value; // $IntegerType()
    var $t62: $Value; // $IntegerType()
    var $t63: $Value; // $IntegerType()
    var $t64: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t65: $Reference; // ReferenceType($IntegerType())
    var $t66: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t67: $Value; // $IntegerType()
    var $t68: $Value; // $IntegerType()
    var $t69: $Value; // $IntegerType()
    var $t70: $Value; // $IntegerType()
    var $t71: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t72: $Reference; // ReferenceType($IntegerType())
    var $t73: $Value; // $IntegerType()
    var $t74: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t75: $Value; // $IntegerType()
    var $t76: $Value; // $IntegerType()
    var $t77: $Value; // $IntegerType()
    var $t78: $Value; // $IntegerType()
    var $t79: $Value; // $IntegerType()
    var $t80: $Value; // $IntegerType()
    var $t81: $Value; // $IntegerType()
    var $t82: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t83: $Value; // $IntegerType()
    var $t84: $Value; // $IntegerType()
    var $t85: $Value; // $IntegerType()
    var $t86: $Value; // $IntegerType()
    var $t87: $Value; // $IntegerType()
    var $t88: $Value; // $BooleanType()
    var $t89: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t90: $Value; // $IntegerType()
    var $t91: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t92: $Value; // $IntegerType()
    var $t93: $Value; // $IntegerType()
    var $t94: $Value; // $IntegerType()
    var $t95: $Value; // $IntegerType()
    var $t96: $Reference; // ReferenceType($SlidingNonce_SlidingNonce_type_value())
    var $t97: $Reference; // ReferenceType($IntegerType())
    var $t98: $Value; // $IntegerType()
    var $t99: $Value; // $AddressType()
    var $t100: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(24, 1640, 0, account); }
    if (true) { assume $DebugTrackLocal(24, 1640, 1, seq_nonce); }

    // bytecode translation starts here
    // $t99 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t99 := $tmp;

    // $t100 := move(seq_nonce)
    call $tmp := $CopyOrMoveValue(seq_nonce);
    $t100 := $tmp;

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // $t10 := ==($t100, $t9)
    $tmp := $Boolean($IsEqual($t100, $t9));
    $t10 := $tmp;

    // if ($t10) goto L0 else goto L1
    $tmp := $t10;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t11 := move($t99)
    call $tmp := $CopyOrMoveValue($t99);
    $t11 := $tmp;

    // destroy($t11)

    // $t12 := 0
    $tmp := $Integer(0);
    $t12 := $tmp;

    // return $t12
    $ret0 := $t12;
    if (true) { assume $DebugTrackLocal(24, 1773, 101, $ret0); }
    return;

    // L2:
L2:

    // $t13 := move($t99)
    call $tmp := $CopyOrMoveValue($t99);
    $t13 := $tmp;

    // $t14 := Signer::address_of($t13)
    call $t14 := $Signer_address_of($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 1849);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := borrow_global<SlidingNonce::SlidingNonce>($t14)
    call $t15 := $BorrowGlobal($t14, $SlidingNonce_SlidingNonce_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 1809);
      goto Abort;
    }
    assume $SlidingNonce_SlidingNonce_is_well_formed($Dereference($t15));

    // UnpackRef($t15)

    // t := $t15
    call t := $CopyOrMoveRef($t15);
    if (true) { assume $DebugTrackLocal(24, 1805, 7, $Dereference(t)); }

    // $t16 := copy(t)
    call $t16 := $CopyOrMoveRef(t);

    // $t17 := get_field<SlidingNonce::SlidingNonce>.min_nonce($t16)
    call $tmp := $GetFieldFromReference($t16, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($tmp);
    $t17 := $tmp;

    // Reference(t) <- $t16
    call t := $WritebackToReference($t16, t);

    // $t18 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;

    // $t20 := >($t18, $t100)
    call $tmp := $Gt($t18, $t100);
    $t20 := $tmp;

    // if ($t20) goto L3 else goto L4
    $tmp := $t20;
    if (b#$Boolean($tmp)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // $t21 := move(t)
    call $t21 := $CopyOrMoveRef(t);

    // destroy($t21)

    // SlidingNonce::SlidingNonce <- $t21
    call $WritebackToGlobal($t21);

    // PackRef($t21)

    // $t22 := 1
    $tmp := $Integer(1);
    $t22 := $tmp;

    // return $t22
    $ret0 := $t22;
    if (true) { assume $DebugTrackLocal(24, 1922, 101, $ret0); }
    return;

    // L5:
L5:

    // $t23 := copy(t)
    call $t23 := $CopyOrMoveRef(t);

    // $t24 := get_field<SlidingNonce::SlidingNonce>.min_nonce($t23)
    call $tmp := $GetFieldFromReference($t23, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($tmp);
    $t24 := $tmp;

    // Reference(t) <- $t23
    call t := $WritebackToReference($t23, t);

    // $t25 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t25 := $tmp;

    // $t26 := 10000
    $tmp := $Integer(10000);
    $t26 := $tmp;

    // $t27 := +($t25, $t26)
    call $tmp := $AddU64($t25, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2083);
      goto Abort;
    }
    $t27 := $tmp;

    // $t29 := <=($t27, $t100)
    call $tmp := $Le($t27, $t100);
    $t29 := $tmp;

    // if ($t29) goto L6 else goto L7
    $tmp := $t29;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t30 := move(t)
    call $t30 := $CopyOrMoveRef(t);

    // destroy($t30)

    // SlidingNonce::SlidingNonce <- $t30
    call $WritebackToGlobal($t30);

    // PackRef($t30)

    // $t31 := 2
    $tmp := $Integer(2);
    $t31 := $tmp;

    // return $t31
    $ret0 := $t31;
    if (true) { assume $DebugTrackLocal(24, 2124, 101, $ret0); }
    return;

    // L8:
L8:

    // $t33 := copy(t)
    call $t33 := $CopyOrMoveRef(t);

    // $t34 := get_field<SlidingNonce::SlidingNonce>.min_nonce($t33)
    call $tmp := $GetFieldFromReference($t33, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($tmp);
    $t34 := $tmp;

    // Reference(t) <- $t33
    call t := $WritebackToReference($t33, t);

    // $t35 := move($t34)
    call $tmp := $CopyOrMoveValue($t34);
    $t35 := $tmp;

    // $t36 := -($t100, $t35)
    call $tmp := $Sub($t100, $t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2189);
      goto Abort;
    }
    $t36 := $tmp;

    // bit_pos := $t36
    call $tmp := $CopyOrMoveValue($t36);
    bit_pos := $tmp;
    if (true) { assume $DebugTrackLocal(24, 2169, 2, $tmp); }

    // $t38 := 128
    $tmp := $Integer(128);
    $t38 := $tmp;

    // $t39 := >=(bit_pos, $t38)
    call $tmp := $Ge(bit_pos, $t38);
    $t39 := $tmp;

    // if ($t39) goto L9 else goto L10
    $tmp := $t39;
    if (b#$Boolean($tmp)) { goto L9; } else { goto L10; }

    // L10:
L10:

    // goto L11
    goto L11;

    // L9:
L9:

    // $t41 := 128
    $tmp := $Integer(128);
    $t41 := $tmp;

    // $t42 := -(bit_pos, $t41)
    call $tmp := $Sub(bit_pos, $t41);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2279);
      goto Abort;
    }
    $t42 := $tmp;

    // $t43 := 1
    $tmp := $Integer(1);
    $t43 := $tmp;

    // $t44 := +($t42, $t43)
    call $tmp := $AddU64($t42, $t43);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2297);
      goto Abort;
    }
    $t44 := $tmp;

    // shift := $t44
    call $tmp := $CopyOrMoveValue($t44);
    shift := $tmp;
    if (true) { assume $DebugTrackLocal(24, 2262, 6, $tmp); }

    // $t46 := 128
    $tmp := $Integer(128);
    $t46 := $tmp;

    // $t47 := >=(shift, $t46)
    call $tmp := $Ge(shift, $t46);
    $t47 := $tmp;

    // if ($t47) goto L12 else goto L13
    $tmp := $t47;
    if (b#$Boolean($tmp)) { goto L12; } else { goto L13; }

    // L13:
L13:

    // goto L14
    goto L14;

    // L12:
L12:

    // $t48 := 0
    $tmp := $Integer(0);
    $t48 := $tmp;

    // $t49 := copy(t)
    call $t49 := $CopyOrMoveRef(t);

    // $t50 := borrow_field<SlidingNonce::SlidingNonce>.nonce_mask($t49)
    call $t50 := $BorrowField($t49, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128($Dereference($t50));

    // Reference(t) <- $t49
    call t := $WritebackToReference($t49, t);

    // UnpackRef($t50)

    // write_ref($t50, $t48)
    call $t50 := $WriteRef($t50, $t48);
    if (true) { assume $DebugTrackLocal(24, 2362, 7, $Dereference(t)); }

    // Reference(t) <- $t50
    call t := $WritebackToReference($t50, t);

    // Reference($t49) <- $t50
    call $t49 := $WritebackToReference($t50, $t49);

    // PackRef($t50)

    // $t52 := 1
    $tmp := $Integer(1);
    $t52 := $tmp;

    // $t53 := +($t100, $t52)
    call $tmp := $AddU64($t100, $t52);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2420);
      goto Abort;
    }
    $t53 := $tmp;

    // $t54 := 128
    $tmp := $Integer(128);
    $t54 := $tmp;

    // $t55 := -($t53, $t54)
    call $tmp := $Sub($t53, $t54);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2424);
      goto Abort;
    }
    $t55 := $tmp;

    // $t56 := copy(t)
    call $t56 := $CopyOrMoveRef(t);

    // $t57 := borrow_field<SlidingNonce::SlidingNonce>.min_nonce($t56)
    call $t57 := $BorrowField($t56, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($Dereference($t57));

    // Reference(t) <- $t56
    call t := $WritebackToReference($t56, t);

    // UnpackRef($t57)

    // write_ref($t57, $t55)
    call $t57 := $WriteRef($t57, $t55);
    if (true) { assume $DebugTrackLocal(24, 2396, 7, $Dereference(t)); }

    // Reference(t) <- $t57
    call t := $WritebackToReference($t57, t);

    // Reference($t56) <- $t57
    call $t56 := $WritebackToReference($t57, $t56);

    // PackRef($t57)

    // goto L11
    goto L11;

    // L14:
L14:

    // $t58 := copy(t)
    call $t58 := $CopyOrMoveRef(t);

    // $t59 := get_field<SlidingNonce::SlidingNonce>.nonce_mask($t58)
    call $tmp := $GetFieldFromReference($t58, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128($tmp);
    $t59 := $tmp;

    // Reference(t) <- $t58
    call t := $WritebackToReference($t58, t);

    // $t60 := move($t59)
    call $tmp := $CopyOrMoveValue($t59);
    $t60 := $tmp;

    // $t62 := (u8)(shift)
    call $tmp := $CastU8(shift);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2511);
      goto Abort;
    }
    $t62 := $tmp;

    // $t63 := <<($t60, $t62)
    call $tmp := $Shr($t60, $t62);
    $t63 := $tmp;

    // $t64 := copy(t)
    call $t64 := $CopyOrMoveRef(t);

    // $t65 := borrow_field<SlidingNonce::SlidingNonce>.nonce_mask($t64)
    call $t65 := $BorrowField($t64, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128($Dereference($t65));

    // Reference(t) <- $t64
    call t := $WritebackToReference($t64, t);

    // UnpackRef($t65)

    // write_ref($t65, $t63)
    call $t65 := $WriteRef($t65, $t63);
    if (true) { assume $DebugTrackLocal(24, 2480, 7, $Dereference(t)); }

    // Reference(t) <- $t65
    call t := $WritebackToReference($t65, t);

    // Reference($t64) <- $t65
    call $t64 := $WritebackToReference($t65, $t64);

    // PackRef($t65)

    // $t66 := copy(t)
    call $t66 := $CopyOrMoveRef(t);

    // $t67 := get_field<SlidingNonce::SlidingNonce>.min_nonce($t66)
    call $tmp := $GetFieldFromReference($t66, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($tmp);
    $t67 := $tmp;

    // Reference(t) <- $t66
    call t := $WritebackToReference($t66, t);

    // $t68 := move($t67)
    call $tmp := $CopyOrMoveValue($t67);
    $t68 := $tmp;

    // $t70 := +($t68, shift)
    call $tmp := $AddU64($t68, shift);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2568);
      goto Abort;
    }
    $t70 := $tmp;

    // $t71 := copy(t)
    call $t71 := $CopyOrMoveRef(t);

    // $t72 := borrow_field<SlidingNonce::SlidingNonce>.min_nonce($t71)
    call $t72 := $BorrowField($t71, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($Dereference($t72));

    // Reference(t) <- $t71
    call t := $WritebackToReference($t71, t);

    // UnpackRef($t72)

    // write_ref($t72, $t70)
    call $t72 := $WriteRef($t72, $t70);
    if (true) { assume $DebugTrackLocal(24, 2542, 7, $Dereference(t)); }

    // Reference(t) <- $t72
    call t := $WritebackToReference($t72, t);

    // Reference($t71) <- $t72
    call $t71 := $WritebackToReference($t72, $t71);

    // PackRef($t72)

    // goto L11
    goto L11;

    // L11:
L11:

    // $t74 := copy(t)
    call $t74 := $CopyOrMoveRef(t);

    // $t75 := get_field<SlidingNonce::SlidingNonce>.min_nonce($t74)
    call $tmp := $GetFieldFromReference($t74, $SlidingNonce_SlidingNonce_min_nonce);
    assume $IsValidU64($tmp);
    $t75 := $tmp;

    // Reference(t) <- $t74
    call t := $WritebackToReference($t74, t);

    // $t76 := move($t75)
    call $tmp := $CopyOrMoveValue($t75);
    $t76 := $tmp;

    // $t77 := -($t100, $t76)
    call $tmp := $Sub($t100, $t76);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2634);
      goto Abort;
    }
    $t77 := $tmp;

    // bit_pos#1623 := $t77
    call $tmp := $CopyOrMoveValue($t77);
    bit_pos#1623 := $tmp;
    if (true) { assume $DebugTrackLocal(24, 2614, 3, $tmp); }

    // $t78 := 1
    $tmp := $Integer(1);
    $t78 := $tmp;

    // $t80 := (u8)(bit_pos#1623)
    call $tmp := $CastU8(bit_pos#1623);
    if ($abort_flag) {
      assume $DebugTrackAbort(24, 2676);
      goto Abort;
    }
    $t80 := $tmp;

    // $t81 := <<($t78, $t80)
    call $tmp := $Shl($t78, $t80);
    $t81 := $tmp;

    // set := $t81
    call $tmp := $CopyOrMoveValue($t81);
    set := $tmp;
    if (true) { assume $DebugTrackLocal(24, 2661, 5, $tmp); }

    // $t82 := copy(t)
    call $t82 := $CopyOrMoveRef(t);

    // $t83 := get_field<SlidingNonce::SlidingNonce>.nonce_mask($t82)
    call $tmp := $GetFieldFromReference($t82, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128($tmp);
    $t83 := $tmp;

    // Reference(t) <- $t82
    call t := $WritebackToReference($t82, t);

    // $t84 := move($t83)
    call $tmp := $CopyOrMoveValue($t83);
    $t84 := $tmp;

    // $t86 := &($t84, set)
    // bit operation not supported: Call(AttrId(119), [86], BitAnd, [84, 5])
    assert false;

    // $t87 := 0
    $tmp := $Integer(0);
    $t87 := $tmp;

    // $t88 := !=($t86, $t87)
    $tmp := $Boolean(!$IsEqual($t86, $t87));
    $t88 := $tmp;

    // if ($t88) goto L15 else goto L16
    $tmp := $t88;
    if (b#$Boolean($tmp)) { goto L15; } else { goto L16; }

    // L16:
L16:

    // goto L17
    goto L17;

    // L15:
L15:

    // $t89 := move(t)
    call $t89 := $CopyOrMoveRef(t);

    // destroy($t89)

    // SlidingNonce::SlidingNonce <- $t89
    call $WritebackToGlobal($t89);

    // PackRef($t89)

    // $t90 := 3
    $tmp := $Integer(3);
    $t90 := $tmp;

    // return $t90
    $ret0 := $t90;
    if (true) { assume $DebugTrackLocal(24, 2744, 101, $ret0); }
    return;

    // L17:
L17:

    // $t91 := copy(t)
    call $t91 := $CopyOrMoveRef(t);

    // $t92 := get_field<SlidingNonce::SlidingNonce>.nonce_mask($t91)
    call $tmp := $GetFieldFromReference($t91, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128($tmp);
    $t92 := $tmp;

    // Reference(t) <- $t91
    call t := $WritebackToReference($t91, t);

    // $t93 := move($t92)
    call $tmp := $CopyOrMoveValue($t92);
    $t93 := $tmp;

    // $t95 := |($t93, set)
    // bit operation not supported: Call(AttrId(135), [95], BitOr, [93, 5])
    assert false;

    // $t96 := move(t)
    call $t96 := $CopyOrMoveRef(t);

    // $t97 := borrow_field<SlidingNonce::SlidingNonce>.nonce_mask($t96)
    call $t97 := $BorrowField($t96, $SlidingNonce_SlidingNonce_nonce_mask);
    assume $IsValidU128($Dereference($t97));

    // SlidingNonce::SlidingNonce <- $t96
    call $WritebackToGlobal($t96);

    // UnpackRef($t97)

    // write_ref($t97, $t95)
    call $t97 := $WriteRef($t97, $t95);
    if (true) { assume $DebugTrackLocal(24, 2794, 7, $Dereference(t)); }

    // SlidingNonce::SlidingNonce <- $t97
    call $WritebackToGlobal($t97);

    // Reference($t96) <- $t97
    call $t96 := $WritebackToReference($t97, $t96);

    // PackRef($t96)

    // PackRef($t97)

    // $t98 := 0
    $tmp := $Integer(0);
    $t98 := $tmp;

    // return $t98
    $ret0 := $t98;
    if (true) { assume $DebugTrackLocal(24, 2837, 101, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $SlidingNonce_try_record_nonce(account: $Value, seq_nonce: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
free requires $IsValidU64(seq_nonce);
{
    call $ret0 := $SlidingNonce_try_record_nonce_def(account, seq_nonce);
}



// ** spec vars of module LibraTransactionTimeout



// ** spec funs of module LibraTransactionTimeout



// ** structs of module LibraTransactionTimeout

const unique $LibraTransactionTimeout_TTL: $TypeName;
const $LibraTransactionTimeout_TTL_duration_microseconds: $FieldName;
axiom $LibraTransactionTimeout_TTL_duration_microseconds == 0;
function $LibraTransactionTimeout_TTL_type_value(): $TypeValue {
    $StructType($LibraTransactionTimeout_TTL, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()], 1))
}
function {:inline} $LibraTransactionTimeout_TTL_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraTransactionTimeout_TTL_duration_microseconds))
}
function {:inline} $LibraTransactionTimeout_TTL_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $IsValidU64($SelectField($this, $LibraTransactionTimeout_TTL_duration_microseconds))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraTransactionTimeout_TTL_is_well_formed($ResourceValue(m, $LibraTransactionTimeout_TTL_type_value(), a))
);

procedure {:inline 1} $LibraTransactionTimeout_TTL_pack($file_id: int, $byte_index: int, $var_idx: int, duration_microseconds: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(duration_microseconds);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := duration_microseconds], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraTransactionTimeout_TTL_unpack($struct: $Value) returns (duration_microseconds: $Value)
{
    assume is#$Vector($struct);
    duration_microseconds := $SelectField($struct, $LibraTransactionTimeout_TTL_duration_microseconds);
    assume $IsValidU64(duration_microseconds);
}



// ** functions of module LibraTransactionTimeout

procedure {:inline 1} $LibraTransactionTimeout_initialize_def(association: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $LibraTransactionTimeout_TTL_type_value()
    var $t19: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 606, 0, association); }

    // bytecode translation starts here
    // $t19 := move(association)
    call $tmp := $CopyOrMoveValue(association);
    $t19 := $tmp;

    // $t5 := LibraTimestamp::is_genesis()
    call $t5 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 679);
      goto Abort;
    }
    assume is#$Boolean($t5);


    // $t1 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(17, 656, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t7 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t7 := $tmp;

    // destroy($t7)

    // $t8 := 0
    $tmp := $Integer(0);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(17, 656); }
    goto Abort;

    // L0:
L0:

    // $t9 := copy($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t9 := $tmp;

    // $t10 := Signer::address_of($t9)
    call $t10 := $Signer_address_of($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 799);
      goto Abort;
    }
    assume is#$Address($t10);


    // $t11 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 841);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := ==($t10, $t11)
    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;

    // $t3 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(17, 784, 3, $tmp); }

    // if ($t3) goto L2 else goto L3
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t14 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t14 := $tmp;

    // destroy($t14)

    // $t15 := 1
    $tmp := $Integer(1);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(17, 784); }
    goto Abort;

    // L2:
L2:

    // $t16 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t16 := $tmp;

    // $t17 := 86400000000
    $tmp := $Integer(86400000000);
    $t17 := $tmp;

    // $t18 := pack LibraTransactionTimeout::TTL($t17)
    call $tmp := $LibraTransactionTimeout_TTL_pack(0, 0, 0, $t17);
    $t18 := $tmp;

    // move_to<LibraTransactionTimeout::TTL>($t18, $t16)
    call $MoveTo($LibraTransactionTimeout_TTL_type_value(), $t18, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 926);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraTransactionTimeout_initialize(association: $Value) returns ()
free requires is#$Address(association);
{
    call $LibraTransactionTimeout_initialize_def(association);
}

procedure {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp_def(timestamp: $Value) returns ($ret0: $Value){
    // declare local variables
    var current_block_time: $Value; // $IntegerType()
    var timeout: $Value; // $IntegerType()
    var txn_time_microseconds: $Value; // $IntegerType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $LibraTransactionTimeout_TTL_type_value()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 1339, 0, timestamp); }

    // bytecode translation starts here
    // $t22 := move(timestamp)
    call $tmp := $CopyOrMoveValue(timestamp);
    $t22 := $tmp;

    // $t5 := 18446744073709
    $tmp := $Integer(18446744073709);
    $t5 := $tmp;

    // $t6 := >($t22, $t5)
    call $tmp := $Gt($t22, $t5);
    $t6 := $tmp;

    // if ($t6) goto L0 else goto L1
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t7 := false
    $tmp := $Boolean(false);
    $t7 := $tmp;

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(17, 1518, 23, $ret0); }
    return;

    // L2:
L2:

    // $t8 := LibraTimestamp::now_microseconds()
    call $t8 := $LibraTimestamp_now_microseconds();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1584);
      goto Abort;
    }
    assume $IsValidU64($t8);


    // current_block_time := $t8
    call $tmp := $CopyOrMoveValue($t8);
    current_block_time := $tmp;
    if (true) { assume $DebugTrackLocal(17, 1547, 1, $tmp); }

    // $t9 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1656);
      goto Abort;
    }
    assume is#$Address($t9);


    // $t10 := get_global<LibraTransactionTimeout::TTL>($t9)
    call $tmp := $GetGlobal($t9, $LibraTransactionTimeout_TTL_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1622);
      goto Abort;
    }
    assume $LibraTransactionTimeout_TTL_is_well_formed($tmp);
    $t10 := $tmp;

    // $t11 := get_field<LibraTransactionTimeout::TTL>.duration_microseconds($t10)
    call $tmp := $GetFieldFromValue($t10, $LibraTransactionTimeout_TTL_duration_microseconds);
    assume $IsValidU64($tmp);
    $t11 := $tmp;

    // $t12 := move($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t12 := $tmp;

    // timeout := $t12
    call $tmp := $CopyOrMoveValue($t12);
    timeout := $tmp;
    if (true) { assume $DebugTrackLocal(17, 1612, 2, $tmp); }

    // $t15 := +(current_block_time, timeout)
    call $tmp := $AddU64(current_block_time, timeout);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1744);
      goto Abort;
    }
    $t15 := $tmp;

    // destroy($t15)

    // $t17 := 1000000
    $tmp := $Integer(1000000);
    $t17 := $tmp;

    // $t18 := *($t22, $t17)
    call $tmp := $MulU64($t22, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1798);
      goto Abort;
    }
    $t18 := $tmp;

    // txn_time_microseconds := $t18
    call $tmp := $CopyOrMoveValue($t18);
    txn_time_microseconds := $tmp;
    if (true) { assume $DebugTrackLocal(17, 1764, 3, $tmp); }

    // $t21 := <(current_block_time, txn_time_microseconds)
    call $tmp := $Lt(current_block_time, txn_time_microseconds);
    $t21 := $tmp;

    // return $t21
    $ret0 := $t21;
    if (true) { assume $DebugTrackLocal(17, 2164, 23, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraTransactionTimeout_is_valid_transaction_timestamp(timestamp: $Value) returns ($ret0: $Value)
free requires $IsValidU64(timestamp);
{
    call $ret0 := $LibraTransactionTimeout_is_valid_transaction_timestamp_def(timestamp);
}

procedure {:inline 1} $LibraTransactionTimeout_set_timeout_def(lr_account: $Value, new_duration: $Value) returns (){
    // declare local variables
    var timeout: $Reference; // ReferenceType($LibraTransactionTimeout_TTL_type_value())
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Reference; // ReferenceType($LibraTransactionTimeout_TTL_type_value())
    var $t11: $Value; // $IntegerType()
    var $t12: $Reference; // ReferenceType($LibraTransactionTimeout_TTL_type_value())
    var $t13: $Reference; // ReferenceType($IntegerType())
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(17, 1041, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(17, 1041, 1, new_duration); }

    // bytecode translation starts here
    // $t14 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t14 := $tmp;

    // $t15 := move(new_duration)
    call $tmp := $CopyOrMoveValue(new_duration);
    $t15 := $tmp;

    // $t5 := move($t14)
    call $tmp := $CopyOrMoveValue($t14);
    $t5 := $tmp;

    // $t6 := Roles::has_libra_root_role($t5)
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1152);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(17, 1138, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := 2
    $tmp := $Integer(2);
    $t8 := $tmp;

    // abort($t8)
    if (true) { assume $DebugTrackAbort(17, 1138); }
    goto Abort;

    // L0:
L0:

    // $t9 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t9 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1259);
      goto Abort;
    }
    assume is#$Address($t9);


    // $t10 := borrow_global<LibraTransactionTimeout::TTL>($t9)
    call $t10 := $BorrowGlobal($t9, $LibraTransactionTimeout_TTL_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(17, 1221);
      goto Abort;
    }
    assume $LibraTransactionTimeout_TTL_is_well_formed($Dereference($t10));

    // UnpackRef($t10)

    // timeout := $t10
    call timeout := $CopyOrMoveRef($t10);
    if (true) { assume $DebugTrackLocal(17, 1211, 2, $Dereference(timeout)); }

    // $t12 := move(timeout)
    call $t12 := $CopyOrMoveRef(timeout);

    // $t13 := borrow_field<LibraTransactionTimeout::TTL>.duration_microseconds($t12)
    call $t13 := $BorrowField($t12, $LibraTransactionTimeout_TTL_duration_microseconds);
    assume $IsValidU64($Dereference($t13));

    // LibraTransactionTimeout::TTL <- $t12
    call $WritebackToGlobal($t12);

    // UnpackRef($t13)

    // write_ref($t13, $t15)
    call $t13 := $WriteRef($t13, $t15);
    if (true) { assume $DebugTrackLocal(17, 1286, 2, $Dereference(timeout)); }

    // LibraTransactionTimeout::TTL <- $t13
    call $WritebackToGlobal($t13);

    // Reference($t12) <- $t13
    call $t12 := $WritebackToReference($t13, $t12);

    // PackRef($t12)

    // PackRef($t13)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraTransactionTimeout_set_timeout(lr_account: $Value, new_duration: $Value) returns ()
free requires is#$Address(lr_account);
free requires $IsValidU64(new_duration);
{
    call $LibraTransactionTimeout_set_timeout_def(lr_account, new_duration);
}



// ** spec vars of module Hash



// ** spec funs of module Hash



// ** structs of module Hash



// ** functions of module Hash



// ** spec vars of module LibraAccount



// ** spec funs of module LibraAccount

function {:inline} $LibraAccount_spec_should_track_limits_for_account($m: $Memory, $txn: $Transaction, payer: $Value, payee: $Value, is_withdrawal: $Value): $Value {
    if (b#$Boolean(is_withdrawal)) then ($Boolean(b#$Boolean($VASP_spec_is_vasp($m, $txn, payer)) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, payee)))) || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_same_vasp($m, $txn, payer, payee)))))))) else ($Boolean(b#$Boolean($VASP_spec_is_vasp($m, $txn, payee)) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_vasp($m, $txn, payee)))) || b#$Boolean($Boolean(!b#$Boolean($VASP_spec_is_same_vasp($m, $txn, payer, payee))))))))
}

function {:inline} $LibraAccount_spec_get_key_rotation_cap($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $SelectField($ResourceValue($m, $LibraAccount_LibraAccount_type_value(), addr), $LibraAccount_LibraAccount_key_rotation_capability)
}

function {:inline} $LibraAccount_spec_holds_own_key_rotation_cap($m: $Memory, $txn: $Transaction, addr: $Value): $Value {
    $Boolean(b#$Boolean($Option_spec_is_some($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap($m, $txn, addr))) && b#$Boolean($Boolean($IsEqual(addr, $SelectField($Option_spec_value_inside($LibraAccount_KeyRotationCapability_type_value(), $LibraAccount_spec_get_key_rotation_cap($m, $txn, addr)), $LibraAccount_KeyRotationCapability_account_address)))))
}

function {:inline} $LibraAccount_spec_has_account_operations_cap($m: $Memory, $txn: $Transaction): $Value {
    $ResourceExists($m, $LibraAccount_AccountOperationsCapability_type_value(), $CoreAddresses_SPEC_LIBRA_ROOT_ADDRESS())
}



// ** structs of module LibraAccount

const unique $LibraAccount_LibraAccount: $TypeName;
const $LibraAccount_LibraAccount_authentication_key: $FieldName;
axiom $LibraAccount_LibraAccount_authentication_key == 0;
const $LibraAccount_LibraAccount_withdrawal_capability: $FieldName;
axiom $LibraAccount_LibraAccount_withdrawal_capability == 1;
const $LibraAccount_LibraAccount_key_rotation_capability: $FieldName;
axiom $LibraAccount_LibraAccount_key_rotation_capability == 2;
const $LibraAccount_LibraAccount_received_events: $FieldName;
axiom $LibraAccount_LibraAccount_received_events == 3;
const $LibraAccount_LibraAccount_sent_events: $FieldName;
axiom $LibraAccount_LibraAccount_sent_events == 4;
const $LibraAccount_LibraAccount_sequence_number: $FieldName;
axiom $LibraAccount_LibraAccount_sequence_number == 5;
const $LibraAccount_LibraAccount_is_frozen: $FieldName;
axiom $LibraAccount_LibraAccount_is_frozen == 6;
function $LibraAccount_LibraAccount_type_value(): $TypeValue {
    $StructType($LibraAccount_LibraAccount, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Vector_type_value($IntegerType())][1 := $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())][2 := $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())][3 := $Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value())][4 := $Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value())][5 := $IntegerType()][6 := $BooleanType()], 7))
}
function {:inline} $LibraAccount_LibraAccount_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 7
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key),$$0)))
      && $Option_Option_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_withdrawal_capability))
      && $Option_Option_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_key_rotation_capability))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_received_events))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraAccount_LibraAccount_sent_events))
      && $IsValidU64($SelectField($this, $LibraAccount_LibraAccount_sequence_number))
      && is#$Boolean($SelectField($this, $LibraAccount_LibraAccount_is_frozen))
}
function {:inline} $LibraAccount_LibraAccount_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 7
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_LibraAccount_authentication_key)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_LibraAccount_authentication_key),$$0)))
      && $Option_Option_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_withdrawal_capability))
      && $Option_Option_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_key_rotation_capability))
      && $Event_EventHandle_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_received_events))
      && $Event_EventHandle_is_well_formed($SelectField($this, $LibraAccount_LibraAccount_sent_events))
      && $IsValidU64($SelectField($this, $LibraAccount_LibraAccount_sequence_number))
      && is#$Boolean($SelectField($this, $LibraAccount_LibraAccount_is_frozen))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraAccount_LibraAccount_is_well_formed($ResourceValue(m, $LibraAccount_LibraAccount_type_value(), a))
);

procedure {:inline 1} $LibraAccount_LibraAccount_before_update_inv($before: $Value) {
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $SelectField($before, $LibraAccount_LibraAccount_withdrawal_capability));
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $SelectField($before, $LibraAccount_LibraAccount_key_rotation_capability));
}

procedure {:inline 1} $LibraAccount_LibraAccount_after_update_inv($after: $Value) {
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $SelectField($after, $LibraAccount_LibraAccount_withdrawal_capability));
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $SelectField($after, $LibraAccount_LibraAccount_key_rotation_capability));
}

procedure {:inline 1} $LibraAccount_LibraAccount_pack($file_id: int, $byte_index: int, $var_idx: int, authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value, is_frozen: $Value) returns ($struct: $Value)
{
    assume $Vector_is_well_formed(authentication_key) && (forall $$0: int :: {$select_vector(authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(authentication_key) ==> $IsValidU8($select_vector(authentication_key,$$0)));
    assume $Option_Option_is_well_formed(withdrawal_capability);
    assume $Option_Option_is_well_formed(key_rotation_capability);
    assume $Event_EventHandle_is_well_formed(received_events);
    assume $Event_EventHandle_is_well_formed(sent_events);
    assume $IsValidU64(sequence_number);
    assume is#$Boolean(is_frozen);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := authentication_key][1 := withdrawal_capability][2 := key_rotation_capability][3 := received_events][4 := sent_events][5 := sequence_number][6 := is_frozen], 7));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_LibraAccount_unpack($struct: $Value) returns (authentication_key: $Value, withdrawal_capability: $Value, key_rotation_capability: $Value, received_events: $Value, sent_events: $Value, sequence_number: $Value, is_frozen: $Value)
{
    assume is#$Vector($struct);
    authentication_key := $SelectField($struct, $LibraAccount_LibraAccount_authentication_key);
    assume $Vector_is_well_formed(authentication_key) && (forall $$0: int :: {$select_vector(authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(authentication_key) ==> $IsValidU8($select_vector(authentication_key,$$0)));
    withdrawal_capability := $SelectField($struct, $LibraAccount_LibraAccount_withdrawal_capability);
    assume $Option_Option_is_well_formed(withdrawal_capability);
    key_rotation_capability := $SelectField($struct, $LibraAccount_LibraAccount_key_rotation_capability);
    assume $Option_Option_is_well_formed(key_rotation_capability);
    received_events := $SelectField($struct, $LibraAccount_LibraAccount_received_events);
    assume $Event_EventHandle_is_well_formed(received_events);
    sent_events := $SelectField($struct, $LibraAccount_LibraAccount_sent_events);
    assume $Event_EventHandle_is_well_formed(sent_events);
    sequence_number := $SelectField($struct, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64(sequence_number);
    is_frozen := $SelectField($struct, $LibraAccount_LibraAccount_is_frozen);
    assume is#$Boolean(is_frozen);
}

const unique $LibraAccount_AccountOperationsCapability: $TypeName;
const $LibraAccount_AccountOperationsCapability_limits_cap: $FieldName;
axiom $LibraAccount_AccountOperationsCapability_limits_cap == 0;
const $LibraAccount_AccountOperationsCapability_freeze_event_handle: $FieldName;
axiom $LibraAccount_AccountOperationsCapability_freeze_event_handle == 1;
const $LibraAccount_AccountOperationsCapability_unfreeze_event_handle: $FieldName;
axiom $LibraAccount_AccountOperationsCapability_unfreeze_event_handle == 2;
function $LibraAccount_AccountOperationsCapability_type_value(): $TypeValue {
    $StructType($LibraAccount_AccountOperationsCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AccountLimits_CallingCapability_type_value()][1 := $Event_EventHandle_type_value($LibraAccount_FreezeAccountEvent_type_value())][2 := $Event_EventHandle_type_value($LibraAccount_UnfreezeAccountEvent_type_value())], 3))
}
function {:inline} $LibraAccount_AccountOperationsCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $AccountLimits_CallingCapability_is_well_formed_types($SelectField($this, $LibraAccount_AccountOperationsCapability_limits_cap))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraAccount_AccountOperationsCapability_freeze_event_handle))
      && $Event_EventHandle_is_well_formed_types($SelectField($this, $LibraAccount_AccountOperationsCapability_unfreeze_event_handle))
}
function {:inline} $LibraAccount_AccountOperationsCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 3
      && $AccountLimits_CallingCapability_is_well_formed($SelectField($this, $LibraAccount_AccountOperationsCapability_limits_cap))
      && $Event_EventHandle_is_well_formed($SelectField($this, $LibraAccount_AccountOperationsCapability_freeze_event_handle))
      && $Event_EventHandle_is_well_formed($SelectField($this, $LibraAccount_AccountOperationsCapability_unfreeze_event_handle))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraAccount_AccountOperationsCapability_is_well_formed($ResourceValue(m, $LibraAccount_AccountOperationsCapability_type_value(), a))
);

procedure {:inline 1} $LibraAccount_AccountOperationsCapability_pack($file_id: int, $byte_index: int, $var_idx: int, limits_cap: $Value, freeze_event_handle: $Value, unfreeze_event_handle: $Value) returns ($struct: $Value)
{
    assume $AccountLimits_CallingCapability_is_well_formed(limits_cap);
    assume $Event_EventHandle_is_well_formed(freeze_event_handle);
    assume $Event_EventHandle_is_well_formed(unfreeze_event_handle);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := limits_cap][1 := freeze_event_handle][2 := unfreeze_event_handle], 3));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_AccountOperationsCapability_unpack($struct: $Value) returns (limits_cap: $Value, freeze_event_handle: $Value, unfreeze_event_handle: $Value)
{
    assume is#$Vector($struct);
    limits_cap := $SelectField($struct, $LibraAccount_AccountOperationsCapability_limits_cap);
    assume $AccountLimits_CallingCapability_is_well_formed(limits_cap);
    freeze_event_handle := $SelectField($struct, $LibraAccount_AccountOperationsCapability_freeze_event_handle);
    assume $Event_EventHandle_is_well_formed(freeze_event_handle);
    unfreeze_event_handle := $SelectField($struct, $LibraAccount_AccountOperationsCapability_unfreeze_event_handle);
    assume $Event_EventHandle_is_well_formed(unfreeze_event_handle);
}

const unique $LibraAccount_Balance: $TypeName;
const $LibraAccount_Balance_coin: $FieldName;
axiom $LibraAccount_Balance_coin == 0;
axiom (forall $tv0: $TypeValue :: $LibraAccount_Balance_type_value($tv0) == $StructType($LibraAccount_Balance, $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $tv0], 1), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $Libra_Libra_type_value($tv0)], 1)));
function {:inline} $LibraAccount_Balance_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Libra_Libra_is_well_formed_types($SelectField($this, $LibraAccount_Balance_coin))
}
function {:inline} $LibraAccount_Balance_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && $Libra_Libra_is_well_formed($SelectField($this, $LibraAccount_Balance_coin))
}

axiom (forall m: $Memory, a: $Value, $tv0: $TypeValue :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraAccount_Balance_is_well_formed($ResourceValue(m, $LibraAccount_Balance_type_value($tv0), a))
);

procedure {:inline 1} $LibraAccount_Balance_before_update_inv($tv0: $TypeValue, $before: $Value) {
    call $Libra_Libra_before_update_inv($tv0, $SelectField($before, $LibraAccount_Balance_coin));
}

procedure {:inline 1} $LibraAccount_Balance_after_update_inv($tv0: $TypeValue, $after: $Value) {
    call $Libra_Libra_after_update_inv($tv0, $SelectField($after, $LibraAccount_Balance_coin));
}

procedure {:inline 1} $LibraAccount_Balance_pack($file_id: int, $byte_index: int, $var_idx: int, $tv0: $TypeValue, coin: $Value) returns ($struct: $Value)
{
    assume $Libra_Libra_is_well_formed(coin);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := coin], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_Balance_unpack($tv0: $TypeValue, $struct: $Value) returns (coin: $Value)
{
    assume is#$Vector($struct);
    coin := $SelectField($struct, $LibraAccount_Balance_coin);
    assume $Libra_Libra_is_well_formed(coin);
}

const unique $LibraAccount_FreezeAccountEvent: $TypeName;
const $LibraAccount_FreezeAccountEvent_initiator_address: $FieldName;
axiom $LibraAccount_FreezeAccountEvent_initiator_address == 0;
const $LibraAccount_FreezeAccountEvent_frozen_address: $FieldName;
axiom $LibraAccount_FreezeAccountEvent_frozen_address == 1;
function $LibraAccount_FreezeAccountEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_FreezeAccountEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AddressType()][1 := $AddressType()], 2))
}
function {:inline} $LibraAccount_FreezeAccountEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $LibraAccount_FreezeAccountEvent_initiator_address))
      && is#$Address($SelectField($this, $LibraAccount_FreezeAccountEvent_frozen_address))
}
function {:inline} $LibraAccount_FreezeAccountEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $LibraAccount_FreezeAccountEvent_initiator_address))
      && is#$Address($SelectField($this, $LibraAccount_FreezeAccountEvent_frozen_address))
}

procedure {:inline 1} $LibraAccount_FreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, frozen_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(initiator_address);
    assume is#$Address(frozen_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := initiator_address][1 := frozen_address], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_FreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, frozen_address: $Value)
{
    assume is#$Vector($struct);
    initiator_address := $SelectField($struct, $LibraAccount_FreezeAccountEvent_initiator_address);
    assume is#$Address(initiator_address);
    frozen_address := $SelectField($struct, $LibraAccount_FreezeAccountEvent_frozen_address);
    assume is#$Address(frozen_address);
}

const unique $LibraAccount_FreezingPrivilege: $TypeName;
const $LibraAccount_FreezingPrivilege_dummy_field: $FieldName;
axiom $LibraAccount_FreezingPrivilege_dummy_field == 0;
function $LibraAccount_FreezingPrivilege_type_value(): $TypeValue {
    $StructType($LibraAccount_FreezingPrivilege, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $LibraAccount_FreezingPrivilege_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraAccount_FreezingPrivilege_dummy_field))
}
function {:inline} $LibraAccount_FreezingPrivilege_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraAccount_FreezingPrivilege_dummy_field))
}

procedure {:inline 1} $LibraAccount_FreezingPrivilege_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_FreezingPrivilege_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraAccount_FreezingPrivilege_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $LibraAccount_KeyRotationCapability: $TypeName;
const $LibraAccount_KeyRotationCapability_account_address: $FieldName;
axiom $LibraAccount_KeyRotationCapability_account_address == 0;
function $LibraAccount_KeyRotationCapability_type_value(): $TypeValue {
    $StructType($LibraAccount_KeyRotationCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AddressType()], 1))
}
function {:inline} $LibraAccount_KeyRotationCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $LibraAccount_KeyRotationCapability_account_address))
}
function {:inline} $LibraAccount_KeyRotationCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $LibraAccount_KeyRotationCapability_account_address))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraAccount_KeyRotationCapability_is_well_formed($ResourceValue(m, $LibraAccount_KeyRotationCapability_type_value(), a))
);

procedure {:inline 1} $LibraAccount_KeyRotationCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(account_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := account_address], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_KeyRotationCapability_unpack($struct: $Value) returns (account_address: $Value)
{
    assume is#$Vector($struct);
    account_address := $SelectField($struct, $LibraAccount_KeyRotationCapability_account_address);
    assume is#$Address(account_address);
}

const unique $LibraAccount_PublishModule: $TypeName;
const $LibraAccount_PublishModule_dummy_field: $FieldName;
axiom $LibraAccount_PublishModule_dummy_field == 0;
function $LibraAccount_PublishModule_type_value(): $TypeValue {
    $StructType($LibraAccount_PublishModule, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $BooleanType()], 1))
}
function {:inline} $LibraAccount_PublishModule_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraAccount_PublishModule_dummy_field))
}
function {:inline} $LibraAccount_PublishModule_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Boolean($SelectField($this, $LibraAccount_PublishModule_dummy_field))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraAccount_PublishModule_is_well_formed($ResourceValue(m, $LibraAccount_PublishModule_type_value(), a))
);

procedure {:inline 1} $LibraAccount_PublishModule_pack($file_id: int, $byte_index: int, $var_idx: int, dummy_field: $Value) returns ($struct: $Value)
{
    assume is#$Boolean(dummy_field);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := dummy_field], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_PublishModule_unpack($struct: $Value) returns (dummy_field: $Value)
{
    assume is#$Vector($struct);
    dummy_field := $SelectField($struct, $LibraAccount_PublishModule_dummy_field);
    assume is#$Boolean(dummy_field);
}

const unique $LibraAccount_ReceivedPaymentEvent: $TypeName;
const $LibraAccount_ReceivedPaymentEvent_amount: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_amount == 0;
const $LibraAccount_ReceivedPaymentEvent_currency_code: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_currency_code == 1;
const $LibraAccount_ReceivedPaymentEvent_payer: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_payer == 2;
const $LibraAccount_ReceivedPaymentEvent_metadata: $FieldName;
axiom $LibraAccount_ReceivedPaymentEvent_metadata == 3;
function $LibraAccount_ReceivedPaymentEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_ReceivedPaymentEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())][2 := $AddressType()][3 := $Vector_type_value($IntegerType())], 4))
}
function {:inline} $LibraAccount_ReceivedPaymentEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $LibraAccount_ReceivedPaymentEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $LibraAccount_ReceivedPaymentEvent_payer))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata),$$0)))
}
function {:inline} $LibraAccount_ReceivedPaymentEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $LibraAccount_ReceivedPaymentEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $LibraAccount_ReceivedPaymentEvent_payer))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_ReceivedPaymentEvent_metadata),$$0)))
}

procedure {:inline 1} $LibraAccount_ReceivedPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(payer);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := payer][3 := metadata], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_ReceivedPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payer: $Value, metadata: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    payer := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_payer);
    assume is#$Address(payer);
    metadata := $SelectField($struct, $LibraAccount_ReceivedPaymentEvent_metadata);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
}

const unique $LibraAccount_SentPaymentEvent: $TypeName;
const $LibraAccount_SentPaymentEvent_amount: $FieldName;
axiom $LibraAccount_SentPaymentEvent_amount == 0;
const $LibraAccount_SentPaymentEvent_currency_code: $FieldName;
axiom $LibraAccount_SentPaymentEvent_currency_code == 1;
const $LibraAccount_SentPaymentEvent_payee: $FieldName;
axiom $LibraAccount_SentPaymentEvent_payee == 2;
const $LibraAccount_SentPaymentEvent_metadata: $FieldName;
axiom $LibraAccount_SentPaymentEvent_metadata == 3;
function $LibraAccount_SentPaymentEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_SentPaymentEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $IntegerType()][1 := $Vector_type_value($IntegerType())][2 := $AddressType()][3 := $Vector_type_value($IntegerType())], 4))
}
function {:inline} $LibraAccount_SentPaymentEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $LibraAccount_SentPaymentEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $LibraAccount_SentPaymentEvent_payee))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata),$$0)))
}
function {:inline} $LibraAccount_SentPaymentEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 4
      && $IsValidU64($SelectField($this, $LibraAccount_SentPaymentEvent_amount))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_currency_code),$$0)))
      && is#$Address($SelectField($this, $LibraAccount_SentPaymentEvent_payee))
      && $Vector_is_well_formed($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) && (forall $$0: int :: {$select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata),$$0)} $$0 >= 0 && $$0 < $vlen($SelectField($this, $LibraAccount_SentPaymentEvent_metadata)) ==> $IsValidU8($select_vector($SelectField($this, $LibraAccount_SentPaymentEvent_metadata),$$0)))
}

procedure {:inline 1} $LibraAccount_SentPaymentEvent_pack($file_id: int, $byte_index: int, $var_idx: int, amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value) returns ($struct: $Value)
{
    assume $IsValidU64(amount);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    assume is#$Address(payee);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := amount][1 := currency_code][2 := payee][3 := metadata], 4));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_SentPaymentEvent_unpack($struct: $Value) returns (amount: $Value, currency_code: $Value, payee: $Value, metadata: $Value)
{
    assume is#$Vector($struct);
    amount := $SelectField($struct, $LibraAccount_SentPaymentEvent_amount);
    assume $IsValidU64(amount);
    currency_code := $SelectField($struct, $LibraAccount_SentPaymentEvent_currency_code);
    assume $Vector_is_well_formed(currency_code) && (forall $$0: int :: {$select_vector(currency_code,$$0)} $$0 >= 0 && $$0 < $vlen(currency_code) ==> $IsValidU8($select_vector(currency_code,$$0)));
    payee := $SelectField($struct, $LibraAccount_SentPaymentEvent_payee);
    assume is#$Address(payee);
    metadata := $SelectField($struct, $LibraAccount_SentPaymentEvent_metadata);
    assume $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
}

const unique $LibraAccount_UnfreezeAccountEvent: $TypeName;
const $LibraAccount_UnfreezeAccountEvent_initiator_address: $FieldName;
axiom $LibraAccount_UnfreezeAccountEvent_initiator_address == 0;
const $LibraAccount_UnfreezeAccountEvent_unfrozen_address: $FieldName;
axiom $LibraAccount_UnfreezeAccountEvent_unfrozen_address == 1;
function $LibraAccount_UnfreezeAccountEvent_type_value(): $TypeValue {
    $StructType($LibraAccount_UnfreezeAccountEvent, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AddressType()][1 := $AddressType()], 2))
}
function {:inline} $LibraAccount_UnfreezeAccountEvent_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $LibraAccount_UnfreezeAccountEvent_initiator_address))
      && is#$Address($SelectField($this, $LibraAccount_UnfreezeAccountEvent_unfrozen_address))
}
function {:inline} $LibraAccount_UnfreezeAccountEvent_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 2
      && is#$Address($SelectField($this, $LibraAccount_UnfreezeAccountEvent_initiator_address))
      && is#$Address($SelectField($this, $LibraAccount_UnfreezeAccountEvent_unfrozen_address))
}

procedure {:inline 1} $LibraAccount_UnfreezeAccountEvent_pack($file_id: int, $byte_index: int, $var_idx: int, initiator_address: $Value, unfrozen_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(initiator_address);
    assume is#$Address(unfrozen_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := initiator_address][1 := unfrozen_address], 2));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_UnfreezeAccountEvent_unpack($struct: $Value) returns (initiator_address: $Value, unfrozen_address: $Value)
{
    assume is#$Vector($struct);
    initiator_address := $SelectField($struct, $LibraAccount_UnfreezeAccountEvent_initiator_address);
    assume is#$Address(initiator_address);
    unfrozen_address := $SelectField($struct, $LibraAccount_UnfreezeAccountEvent_unfrozen_address);
    assume is#$Address(unfrozen_address);
}

const unique $LibraAccount_WithdrawCapability: $TypeName;
const $LibraAccount_WithdrawCapability_account_address: $FieldName;
axiom $LibraAccount_WithdrawCapability_account_address == 0;
function $LibraAccount_WithdrawCapability_type_value(): $TypeValue {
    $StructType($LibraAccount_WithdrawCapability, $TypeValueArray($MapConstTypeValue($DefaultTypeValue()), 0), $TypeValueArray($MapConstTypeValue($DefaultTypeValue())[0 := $AddressType()], 1))
}
function {:inline} $LibraAccount_WithdrawCapability_is_well_formed_types($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $LibraAccount_WithdrawCapability_account_address))
}
function {:inline} $LibraAccount_WithdrawCapability_is_well_formed($this: $Value): bool {
    $Vector_is_well_formed($this)
    && $vlen($this) == 1
      && is#$Address($SelectField($this, $LibraAccount_WithdrawCapability_account_address))
}

axiom (forall m: $Memory, a: $Value :: $Memory__is_well_formed(m) && is#$Address(a) ==>
    $LibraAccount_WithdrawCapability_is_well_formed($ResourceValue(m, $LibraAccount_WithdrawCapability_type_value(), a))
);

procedure {:inline 1} $LibraAccount_WithdrawCapability_pack($file_id: int, $byte_index: int, $var_idx: int, account_address: $Value) returns ($struct: $Value)
{
    assume is#$Address(account_address);
    $struct := $Vector($ValueArray($MapConstValue($DefaultValue())[0 := account_address], 1));
    if ($byte_index > 0) { assume $DebugTrackLocal($file_id, $byte_index, $var_idx, $struct); }
}

procedure {:inline 1} $LibraAccount_WithdrawCapability_unpack($struct: $Value) returns (account_address: $Value)
{
    assume is#$Vector($struct);
    account_address := $SelectField($struct, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address(account_address);
}



// ** functions of module LibraAccount

procedure {:inline 1} $LibraAccount_initialize_def(lr_account: $Value) returns (){
    // declare local variables
    var limits_cap: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $Event_EventHandle_type_value($LibraAccount_FreezeAccountEvent_type_value())
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $Event_EventHandle_type_value($LibraAccount_UnfreezeAccountEvent_type_value())
    var $t27: $Value; // $LibraAccount_AccountOperationsCapability_type_value()
    var $t28: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 6821, 0, lr_account); }

    // bytecode translation starts here
    // $t28 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t28 := $tmp;

    // $t6 := LibraTimestamp::is_genesis()
    call $t6 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 6912);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t2 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t2 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 6889, 2, $tmp); }

    // if ($t2) goto L0 else goto L1
    $tmp := $t2;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(29, 6889); }
    goto Abort;

    // L0:
L0:

    // $t10 := copy($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7027);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7068);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t4 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 7012, 4, $tmp); }

    // if ($t4) goto L2 else goto L3
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t15 := move($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 1
    $tmp := $Integer(1);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(29, 7012); }
    goto Abort;

    // L2:
L2:

    // $t17 := copy($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t17 := $tmp;

    // $t18 := AccountLimits::grant_calling_capability($t17)
    call $t18 := $AccountLimits_grant_calling_capability($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7159);
      goto Abort;
    }
    assume $AccountLimits_CallingCapability_is_well_formed($t18);


    // limits_cap := $t18
    call $tmp := $CopyOrMoveValue($t18);
    limits_cap := $tmp;
    if (true) { assume $DebugTrackLocal(29, 7131, 1, $tmp); }

    // $t19 := copy($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t19 := $tmp;

    // $t20 := copy(limits_cap)
    call $tmp := $CopyOrMoveValue(limits_cap);
    $t20 := $tmp;

    // AccountLimits::initialize($t19, $t20)
    call $AccountLimits_initialize($t19, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7220);
      goto Abort;
    }

    // $t21 := copy($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t21 := $tmp;

    // $t23 := copy($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t23 := $tmp;

    // $t24 := Event::new_event_handle<LibraAccount::FreezeAccountEvent>($t23)
    call $t24 := $Event_new_event_handle($LibraAccount_FreezeAccountEvent_type_value(), $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7412);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t24);


    // $t25 := move($t28)
    call $tmp := $CopyOrMoveValue($t28);
    $t25 := $tmp;

    // $t26 := Event::new_event_handle<LibraAccount::UnfreezeAccountEvent>($t25)
    call $t26 := $Event_new_event_handle($LibraAccount_UnfreezeAccountEvent_type_value(), $t25);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7488);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t26);


    // $t27 := pack LibraAccount::AccountOperationsCapability(limits_cap, $t24, $t26)
    call $tmp := $LibraAccount_AccountOperationsCapability_pack(0, 0, 0, limits_cap, $t24, $t26);
    $t27 := $tmp;

    // move_to<LibraAccount::AccountOperationsCapability>($t27, $t21)
    call $MoveTo($LibraAccount_AccountOperationsCapability_type_value(), $t27, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7265);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_initialize(lr_account: $Value) returns ()
free requires is#$Address(lr_account);
{
    call $LibraAccount_initialize_def(lr_account);
}

procedure $LibraAccount_initialize_verify(lr_account: $Value) returns ()
free requires is#$Address(lr_account);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_initialize_def(lr_account);
}

procedure {:inline 1} $LibraAccount_exists_at_def(check_addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 34666, 0, check_addr); }

    // bytecode translation starts here
    // $t3 := move(check_addr)
    call $tmp := $CopyOrMoveValue(check_addr);
    $t3 := $tmp;

    // $t2 := exists<LibraAccount::LibraAccount>($t3)
    call $tmp := $Exists($t3, $LibraAccount_LibraAccount_type_value());
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(29, 34724, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_exists_at(check_addr: $Value) returns ($ret0: $Value)
free requires is#$Address(check_addr);
{
    call $ret0 := $LibraAccount_exists_at_def(check_addr);
}

procedure $LibraAccount_exists_at_verify(check_addr: $Value) returns ($ret0: $Value)
free requires is#$Address(check_addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_exists_at_def(check_addr);
}

procedure {:inline 1} $LibraAccount_preburn_def($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value) returns (){
    // declare local variables
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $Vector_type_value($IntegerType())
    var $t9: $Value; // $Libra_Libra_type_value($tv0)
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t12: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 18768, 0, dd); }
    if (true) { assume $DebugTrackLocal(29, 18768, 1, cap); }
    if (true) { assume $DebugTrackLocal(29, 18768, 2, amount); }

    // bytecode translation starts here
    // $t10 := move(dd)
    call $tmp := $CopyOrMoveValue(dd);
    $t10 := $tmp;

    // $t11 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t11 := $tmp;

    // $t12 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t12 := $tmp;

    // $t3 := copy($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;

    // $t4 := move($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t4 := $tmp;

    // $t5 := move($t10)
    call $tmp := $CopyOrMoveValue($t10);
    $t5 := $tmp;

    // $t6 := Signer::address_of($t5)
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 18986);
      goto Abort;
    }
    assume is#$Address($t6);


    // $t8 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t8 := $tmp;

    // $t9 := LibraAccount::withdraw_from<#0>($t4, $t6, $t12, $t8)
    call $t9 := $LibraAccount_withdraw_from($tv0, $t4, $t6, $t12, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17784);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t9);


    // Libra::preburn_to<#0>($t3, $t9)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_preburn_to($tv0, $t3, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 18937);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_preburn($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value) returns ()
free requires is#$Address(dd);
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires $IsValidU64(amount);
{
    call $LibraAccount_preburn_def($tv0, dd, cap, amount);
}

procedure $LibraAccount_preburn_verify($tv0: $TypeValue, dd: $Value, cap: $Value, amount: $Value) returns ()
free requires is#$Address(dd);
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires $IsValidU64(amount);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_preburn_def($tv0, dd, cap, amount);
}

procedure {:inline 1} $LibraAccount_cancel_burn_def($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns (){
    // declare local variables
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $Libra_Libra_type_value($tv0)
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $Libra_Libra_type_value($tv0)
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 16158, 0, account); }
    if (true) { assume $DebugTrackLocal(29, 16158, 1, preburn_address); }

    // bytecode translation starts here
    // $t11 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t11 := $tmp;

    // $t12 := move(preburn_address)
    call $tmp := $CopyOrMoveValue(preburn_address);
    $t12 := $tmp;

    // $t3 := move($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t3 := $tmp;

    // $t5 := Libra::cancel_burn<#0>($t3, $t12)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t5 := $Libra_cancel_burn($tv0, $t3, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 16343);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t5);


    // coin := $t5
    call $tmp := $CopyOrMoveValue($t5);
    coin := $tmp;
    if (true) { assume $DebugTrackLocal(29, 16329, 2, $tmp); }

    // $t9 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t9 := $tmp;

    // $t10 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t10 := $tmp;

    // LibraAccount::deposit<#0>($t12, $t12, coin, $t9, $t10)
    call $LibraAccount_deposit($tv0, $t12, $t12, coin, $t9, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_cancel_burn($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(preburn_address);
{
    call $LibraAccount_cancel_burn_def($tv0, account, preburn_address);
}

procedure $LibraAccount_cancel_burn_verify($tv0: $TypeValue, account: $Value, preburn_address: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(preburn_address);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_cancel_burn_def($tv0, account, preburn_address);
}

procedure {:inline 1} $LibraAccount_deposit_def($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value) returns (){
    // declare local variables
    var deposit_value: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Libra_Libra_type_value($tv0)
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $t21: $Value; // $Vector_type_value($IntegerType())
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $LibraAccount_AccountOperationsCapability_type_value()
    var $t31: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t32: $Value; // $BooleanType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $AddressType()
    var $t36: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t37: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t38: $Value; // $Libra_Libra_type_value($tv0)
    var $t39: $Value; // $AddressType()
    var $t40: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t41: $Reference; // ReferenceType($Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value()))
    var $t42: $Value; // $IntegerType()
    var $t43: $Value; // $Vector_type_value($IntegerType())
    var $t44: $Value; // $AddressType()
    var $t45: $Value; // $Vector_type_value($IntegerType())
    var $t46: $Value; // $LibraAccount_ReceivedPaymentEvent_type_value()
    var $t47: $Value; // $AddressType()
    var $t48: $Value; // $AddressType()
    var $t49: $Value; // $Libra_Libra_type_value($tv0)
    var $t50: $Value; // $Vector_type_value($IntegerType())
    var $t51: $Value; // $Vector_type_value($IntegerType())
    var $t52: $Value; // $Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value())
    var $t53: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 11958, 0, payer); }
    if (true) { assume $DebugTrackLocal(29, 11958, 1, payee); }
    if (true) { assume $DebugTrackLocal(29, 11958, 2, to_deposit); }
    if (true) { assume $DebugTrackLocal(29, 11958, 3, metadata); }
    if (true) { assume $DebugTrackLocal(29, 11958, 4, metadata_signature); }

    // bytecode translation starts here
    // $t47 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t47 := $tmp;

    // $t48 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t48 := $tmp;

    // $t49 := move(to_deposit)
    call $tmp := $CopyOrMoveValue(to_deposit);
    $t49 := $tmp;

    // $t50 := move(metadata)
    call $tmp := $CopyOrMoveValue(metadata);
    $t50 := $tmp;

    // $t51 := move(metadata_signature)
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t51 := $tmp;

    // $t10 := copy($t49)
    call $tmp := $CopyOrMoveValue($t49);
    $t10 := $tmp;

    // $t11 := Libra::value<#0>($t10)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t11 := $Libra_value($tv0, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 12288);
      goto Abort;
    }
    assume $IsValidU64($t11);


    // deposit_value := $t11
    call $tmp := $CopyOrMoveValue($t11);
    deposit_value := $tmp;
    if (true) { assume $DebugTrackLocal(29, 12265, 5, $tmp); }

    // $t13 := 0
    $tmp := $Integer(0);
    $t13 := $tmp;

    // $t14 := >(deposit_value, $t13)
    call $tmp := $Gt(deposit_value, $t13);
    $t14 := $tmp;

    // $t6 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 12316, 6, $tmp); }

    // if ($t6) goto L0 else goto L1
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t16 := 2
    $tmp := $Integer(2);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(29, 12316); }
    goto Abort;

    // L0:
L0:

    // DualAttestation::assert_payment_ok<#0>($t47, $t48, deposit_value, $t50, $t51)
    call $DualAttestation_assert_payment_ok($tv0, $t47, $t48, deposit_value, $t50, $t51);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 12462);
      goto Abort;
    }

    // $t24 := false
    $tmp := $Boolean(false);
    $t24 := $tmp;

    // $t25 := LibraAccount::should_track_limits_for_account($t47, $t48, $t24)
    call $t25 := $LibraAccount_should_track_limits_for_account($t47, $t48, $t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7857);
      goto Abort;
    }
    assume is#$Boolean($t25);


    // if ($t25) goto L2 else goto L3
    $tmp := $t25;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // goto L4
    goto L4;

    // L2:
L2:

    // $t28 := VASP::parent_address($t48)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t28 := $VASP_parent_address($t48);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 12885);
      goto Abort;
    }
    assume is#$Address($t28);


    // $t29 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t29 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 12987);
      goto Abort;
    }
    assume is#$Address($t29);


    // $t30 := get_global<LibraAccount::AccountOperationsCapability>($t29)
    call $tmp := $GetGlobal($t29, $LibraAccount_AccountOperationsCapability_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 12929);
      goto Abort;
    }
    assume $LibraAccount_AccountOperationsCapability_is_well_formed($tmp);
    $t30 := $tmp;

    // $t31 := get_field<LibraAccount::AccountOperationsCapability>.limits_cap($t30)
    call $tmp := $GetFieldFromValue($t30, $LibraAccount_AccountOperationsCapability_limits_cap);
    assume $AccountLimits_CallingCapability_is_well_formed($tmp);
    $t31 := $tmp;

    // $t32 := AccountLimits::update_deposit_limits<#0>(deposit_value, $t28, $t31)
    call $t32 := $AccountLimits_update_deposit_limits($tv0, deposit_value, $t28, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 12794);
      goto Abort;
    }
    assume is#$Boolean($t32);


    // $t8 := $t32
    call $tmp := $CopyOrMoveValue($t32);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 12755, 8, $tmp); }

    // if ($t8) goto L4 else goto L5
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t34 := 3
    $tmp := $Integer(3);
    $t34 := $tmp;

    // abort($t34)
    if (true) { assume $DebugTrackAbort(29, 12755); }
    goto Abort;

    // L4:
L4:

    // $t36 := borrow_global<LibraAccount::Balance<#0>>($t48)
    call $t36 := $BorrowGlobal($t48, $LibraAccount_Balance_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 13174);
      goto Abort;
    }
    assume $LibraAccount_Balance_is_well_formed($Dereference($t36));

    // UnpackRef($t36)
    call $LibraAccount_Balance_before_update_inv($tv0, $Dereference($t36));

    // $t37 := borrow_field<LibraAccount::Balance<#0>>.coin($t36)
    call $t37 := $BorrowField($t36, $LibraAccount_Balance_coin);
    assume $Libra_Libra_is_well_formed_types($Dereference($t37));

    // LibraAccount::Balance <- $t36
    call $WritebackToGlobal($t36);

    // UnpackRef($t37)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t37));

    // PackRef($t37)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t37));

    // $t53 := read_ref($t37)
    call $tmp := $ReadRef($t37);
    assume $Libra_Libra_is_well_formed($tmp);
    $t53 := $tmp;

    // $t53 := Libra::deposit<#0>($t53, $t49)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t53 := $Libra_deposit($tv0, $t53, $t49);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 13161);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t53);


    // write_ref($t37, $t53)
    call $t37 := $WriteRef($t37, $t53);

    // LibraAccount::Balance <- $t37
    call $WritebackToGlobal($t37);

    // Reference($t36) <- $t37
    call $t36 := $WritebackToReference($t37, $t36);

    // UnpackRef($t37)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t37));

    // PackRef($t36)
    call $LibraAccount_Balance_after_update_inv($tv0, $Dereference($t36));

    // PackRef($t37)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t37));

    // $t40 := borrow_global<LibraAccount::LibraAccount>($t48)
    call $t40 := $BorrowGlobal($t48, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 13333);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t40));

    // UnpackRef($t40)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t40));

    // $t41 := borrow_field<LibraAccount::LibraAccount>.received_events($t40)
    call $t41 := $BorrowField($t40, $LibraAccount_LibraAccount_received_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t41));

    // LibraAccount::LibraAccount <- $t40
    call $WritebackToGlobal($t40);

    // UnpackRef($t41)

    // $t43 := Libra::currency_code<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t43 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 13501);
      goto Abort;
    }
    assume $Vector_is_well_formed($t43) && (forall $$0: int :: {$select_vector($t43,$$0)} $$0 >= 0 && $$0 < $vlen($t43) ==> $IsValidU8($select_vector($t43,$$0)));


    // $t46 := pack LibraAccount::ReceivedPaymentEvent(deposit_value, $t43, $t47, $t50)
    call $tmp := $LibraAccount_ReceivedPaymentEvent_pack(0, 0, 0, deposit_value, $t43, $t47, $t50);
    $t46 := $tmp;

    // PackRef($t41)

    // $t52 := read_ref($t41)
    call $tmp := $ReadRef($t41);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t52 := $tmp;

    // $t52 := Event::emit_event<LibraAccount::ReceivedPaymentEvent>($t52, $t46)
    call $t52 := $Event_emit_event($LibraAccount_ReceivedPaymentEvent_type_value(), $t52, $t46);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 13282);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t52);


    // write_ref($t41, $t52)
    call $t41 := $WriteRef($t41, $t52);

    // LibraAccount::LibraAccount <- $t41
    call $WritebackToGlobal($t41);

    // Reference($t40) <- $t41
    call $t40 := $WritebackToReference($t41, $t40);

    // UnpackRef($t41)

    // PackRef($t40)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t40));

    // PackRef($t41)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_deposit($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value) returns ()
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $Libra_Libra_is_well_formed(to_deposit);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {$select_vector(metadata_signature,$$0)} $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature,$$0)));
free ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($m, $txn, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($m, $txn)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($m, $txn, payee)))))))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_LibraAccount_type_value(), payee))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_Balance_type_value($tv0), payee))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($m, $txn, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_signature_is_valid($m, $txn, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
free ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))))) ==> $abort_flag;
free ensures $abort_flag ==> (b#$Boolean(old(($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($m, $txn, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($m, $txn)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($m, $txn, payee)))))))))))
    || b#$Boolean(old(($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_LibraAccount_type_value(), payee))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_Balance_type_value($tv0), payee))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))
    || b#$Boolean(old(($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($m, $txn, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_signature_is_valid($m, $txn, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn)))))));
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value), $Integer(i#$Integer(old($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value))) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))))));
{
    call $LibraAccount_deposit_def($tv0, payer, payee, to_deposit, metadata, metadata_signature);
}

procedure $LibraAccount_deposit_verify($tv0: $TypeValue, payer: $Value, payee: $Value, to_deposit: $Value, metadata: $Value, metadata_signature: $Value) returns ()
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $Libra_Libra_is_well_formed(to_deposit);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {$select_vector(metadata_signature,$$0)} $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature,$$0)));
ensures b#$Boolean(old($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($m, $txn, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($m, $txn)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($m, $txn, payee)))))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_LibraAccount_type_value(), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_Balance_type_value($tv0), payee))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($m, $txn, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_signature_is_valid($m, $txn, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))) ==> $abort_flag;
ensures b#$Boolean(old($Boolean(!b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn))))) ==> $abort_flag;
ensures $abort_flag ==> (b#$Boolean(old(($Boolean(b#$Boolean($LibraAccount_spec_should_track_limits_for_account($m, $txn, payer, payee, $Boolean(false))) && b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($LibraAccount_spec_has_account_operations_cap($m, $txn)))) || b#$Boolean($Boolean(!b#$Boolean($AccountLimits_spec_update_deposit_limits($tv0, $SelectField(to_deposit, $Libra_Libra_value), $VASP_spec_parent_address($m, $txn, payee)))))))))))
    || b#$Boolean(old(($Boolean($IsEqual($SelectField(to_deposit, $Libra_Libra_value), $Integer(0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_LibraAccount_type_value(), payee))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($ResourceExists($m, $LibraAccount_Balance_type_value($tv0), payee))))))
    || b#$Boolean(old(($Boolean(i#$Integer($Integer(i#$Integer($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value)) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))) > i#$Integer($Integer($MAX_U64))))))
    || b#$Boolean(old(($Boolean(b#$Boolean($DualAttestation_spec_dual_attestation_required($m, $txn, $tv0, payer, payee, $SelectField(to_deposit, $Libra_Libra_value))) && b#$Boolean($Boolean(!b#$Boolean($DualAttestation_signature_is_valid($m, $txn, payer, payee, metadata_signature, metadata, $SelectField(to_deposit, $Libra_Libra_value)))))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0))))))
    || b#$Boolean(old(($Boolean(!b#$Boolean($DualAttestationLimit_spec_is_published($m, $txn)))))));
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value), $Integer(i#$Integer(old($SelectField($SelectField($ResourceValue($m, $LibraAccount_Balance_type_value($tv0), payee), $LibraAccount_Balance_coin), $Libra_Libra_value))) + i#$Integer($SelectField(to_deposit, $Libra_Libra_value)))))));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_deposit_def($tv0, payer, payee, to_deposit, metadata, metadata_signature);
}

procedure {:inline 1} $LibraAccount_tiered_mint_def($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value) returns (){
    // declare local variables
    var coin: $Value; // $Libra_Libra_type_value($tv0)
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $Libra_Libra_type_value($tv0)
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $Libra_Libra_type_value($tv0)
    var $t13: $Value; // $Vector_type_value($IntegerType())
    var $t14: $Value; // $Vector_type_value($IntegerType())
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 15351, 0, tc_account); }
    if (true) { assume $DebugTrackLocal(29, 15351, 1, designated_dealer_address); }
    if (true) { assume $DebugTrackLocal(29, 15351, 2, mint_amount); }
    if (true) { assume $DebugTrackLocal(29, 15351, 3, tier_index); }

    // bytecode translation starts here
    // $t15 := move(tc_account)
    call $tmp := $CopyOrMoveValue(tc_account);
    $t15 := $tmp;

    // $t16 := move(designated_dealer_address)
    call $tmp := $CopyOrMoveValue(designated_dealer_address);
    $t16 := $tmp;

    // $t17 := move(mint_amount)
    call $tmp := $CopyOrMoveValue(mint_amount);
    $t17 := $tmp;

    // $t18 := move(tier_index)
    call $tmp := $CopyOrMoveValue(tier_index);
    $t18 := $tmp;

    // $t5 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t5 := $tmp;

    // $t9 := DesignatedDealer::tiered_mint<#0>($t5, $t17, $t16, $t18)
    call $t9 := $DesignatedDealer_tiered_mint($tv0, $t5, $t17, $t16, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 15611);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t9);


    // coin := $t9
    call $tmp := $CopyOrMoveValue($t9);
    coin := $tmp;
    if (true) { assume $DebugTrackLocal(29, 15586, 4, $tmp); }

    // $t10 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t10 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 15864);
      goto Abort;
    }
    assume is#$Address($t10);


    // $t13 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t13 := $tmp;

    // $t14 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t14 := $tmp;

    // LibraAccount::deposit<#0>($t10, $t16, coin, $t13, $t14)
    call $LibraAccount_deposit($tv0, $t10, $t16, coin, $t13, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_tiered_mint($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value) returns ()
free requires is#$Address(tc_account);
free requires is#$Address(designated_dealer_address);
free requires $IsValidU64(mint_amount);
free requires $IsValidU64(tier_index);
{
    call $LibraAccount_tiered_mint_def($tv0, tc_account, designated_dealer_address, mint_amount, tier_index);
}

procedure $LibraAccount_tiered_mint_verify($tv0: $TypeValue, tc_account: $Value, designated_dealer_address: $Value, mint_amount: $Value, tier_index: $Value) returns ()
free requires is#$Address(tc_account);
free requires is#$Address(designated_dealer_address);
free requires $IsValidU64(mint_amount);
free requires $IsValidU64(tier_index);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_tiered_mint_def($tv0, tc_account, designated_dealer_address, mint_amount, tier_index);
}

procedure {:inline 1} $LibraAccount_balance_def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 32277, 0, addr); }

    // bytecode translation starts here
    // $t4 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;

    // $t2 := get_global<LibraAccount::Balance<#0>>($t4)
    call $tmp := $GetGlobal($t4, $LibraAccount_Balance_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32362);
      goto Abort;
    }
    assume $LibraAccount_Balance_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := LibraAccount::balance_for<#0>($t2)
    call $t3 := $LibraAccount_balance_for($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32110);
      goto Abort;
    }
    assume $IsValidU64($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(29, 32350, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_balance($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_balance_def($tv0, addr);
}

procedure $LibraAccount_balance_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_balance_def($tv0, addr);
}

procedure {:inline 1} $LibraAccount_accepts_currency_def($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $BooleanType()
    var $t3: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 32952, 0, addr); }

    // bytecode translation starts here
    // $t3 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t3 := $tmp;

    // $t2 := exists<LibraAccount::Balance<#0>>($t3)
    call $tmp := $Exists($t3, $LibraAccount_Balance_type_value($tv0));
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(29, 33018, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_accepts_currency($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_accepts_currency_def($tv0, addr);
}

procedure $LibraAccount_accepts_currency_verify($tv0: $TypeValue, addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_accepts_currency_def($tv0, addr);
}

procedure {:inline 1} $LibraAccount_account_is_frozen_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 36996, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<LibraAccount::LibraAccount>($t5)
    call $tmp := $GetGlobal($t5, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 37082);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<LibraAccount::LibraAccount>.is_frozen($t2)
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_is_frozen);
    assume is#$Boolean($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(29, 37082, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_account_is_frozen(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_account_is_frozen_def(addr);
}

procedure $LibraAccount_account_is_frozen_verify(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_account_is_frozen_def(addr);
}

procedure {:inline 1} $LibraAccount_add_currencies_for_account_def($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value) returns (){
    // declare local variables
    var new_account_addr: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 22669, 0, new_account); }
    if (true) { assume $DebugTrackLocal(29, 22669, 1, add_all_currencies); }

    // bytecode translation starts here
    // $t21 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t21 := $tmp;

    // $t22 := move(add_all_currencies)
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t22 := $tmp;

    // $t3 := copy($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t3 := $tmp;

    // $t4 := Signer::address_of($t3)
    call $t4 := $Signer_address_of($t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22819);
      goto Abort;
    }
    assume is#$Address($t4);


    // new_account_addr := $t4
    call $tmp := $CopyOrMoveValue($t4);
    new_account_addr := $tmp;
    if (true) { assume $DebugTrackLocal(29, 22792, 2, $tmp); }

    // $t5 := copy($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t5 := $tmp;

    // LibraAccount::add_currency<#0>($t5)
    call $LibraAccount_add_currency($tv0, $t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32602);
      goto Abort;
    }

    // if ($t22) goto L0 else goto L1
    $tmp := $t22;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t8 := exists<LibraAccount::Balance<Coin1::Coin1>>(new_account_addr)
    call $tmp := $Exists(new_account_addr, $LibraAccount_Balance_type_value($Coin1_Coin1_type_value()));
    $t8 := $tmp;

    // $t9 := !($t8)
    call $tmp := $Not($t8);
    $t9 := $tmp;

    // if ($t9) goto L3 else goto L4
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // $t10 := copy($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t10 := $tmp;

    // LibraAccount::add_currency<Coin1::Coin1>($t10)
    call $LibraAccount_add_currency($Coin1_Coin1_type_value(), $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32602);
      goto Abort;
    }

    // goto L5
    goto L5;

    // L5:
L5:

    // $t12 := exists<LibraAccount::Balance<Coin2::Coin2>>(new_account_addr)
    call $tmp := $Exists(new_account_addr, $LibraAccount_Balance_type_value($Coin2_Coin2_type_value()));
    $t12 := $tmp;

    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // if ($t13) goto L6 else goto L7
    $tmp := $t13;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t14 := copy($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t14 := $tmp;

    // LibraAccount::add_currency<Coin2::Coin2>($t14)
    call $LibraAccount_add_currency($Coin2_Coin2_type_value(), $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32602);
      goto Abort;
    }

    // goto L8
    goto L8;

    // L8:
L8:

    // $t16 := exists<LibraAccount::Balance<LBR::LBR>>(new_account_addr)
    call $tmp := $Exists(new_account_addr, $LibraAccount_Balance_type_value($LBR_LBR_type_value()));
    $t16 := $tmp;

    // $t17 := !($t16)
    call $tmp := $Not($t16);
    $t17 := $tmp;

    // if ($t17) goto L9 else goto L10
    $tmp := $t17;
    if (b#$Boolean($tmp)) { goto L9; } else { goto L10; }

    // L10:
L10:

    // goto L11
    goto L11;

    // L9:
L9:

    // $t18 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t18 := $tmp;

    // LibraAccount::add_currency<LBR::LBR>($t18)
    call $LibraAccount_add_currency($LBR_LBR_type_value(), $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32602);
      goto Abort;
    }

    // goto L12
    goto L12;

    // L11:
L11:

    // $t19 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t19 := $tmp;

    // destroy($t19)

    // goto L12
    goto L12;

    // L12:
L12:

    // goto L13
    goto L13;

    // L2:
L2:

    // $t20 := move($t21)
    call $tmp := $CopyOrMoveValue($t21);
    $t20 := $tmp;

    // destroy($t20)

    // goto L13
    goto L13;

    // L13:
L13:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_add_currencies_for_account($tv0: $TypeValue, new_account: $Value, add_all_currencies: $Value) returns ()
free requires is#$Address(new_account);
free requires is#$Boolean(add_all_currencies);
{
    call $LibraAccount_add_currencies_for_account_def($tv0, new_account, add_all_currencies);
}

procedure {:inline 1} $LibraAccount_add_currency_def($tv0: $TypeValue, account: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $Libra_Libra_type_value($tv0)
    var $t10: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t11: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 32591, 0, account); }

    // bytecode translation starts here
    // $t11 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t11 := $tmp;

    // $t3 := copy($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t3 := $tmp;

    // $t4 := VASP::try_allow_currency<#0>($t3)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t4 := $VASP_try_allow_currency($tv0, $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32663);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // $t1 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 32650, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t6 := move($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t6 := $tmp;

    // destroy($t6)

    // $t7 := 13
    $tmp := $Integer(13);
    $t7 := $tmp;

    // abort($t7)
    if (true) { assume $DebugTrackAbort(29, 32650); }
    goto Abort;

    // L0:
L0:

    // $t8 := move($t11)
    call $tmp := $CopyOrMoveValue($t11);
    $t8 := $tmp;

    // $t9 := Libra::zero<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t9 := $Libra_zero($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32788);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t9);


    // $t10 := pack LibraAccount::Balance<#0>($t9)
    call $tmp := $LibraAccount_Balance_pack(0, 0, 0, $tv0, $t9);
    $t10 := $tmp;

    // move_to<LibraAccount::Balance<#0>>($t10, $t8)
    call $MoveTo($LibraAccount_Balance_type_value($tv0), $t10, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32742);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_add_currency($tv0: $TypeValue, account: $Value) returns ()
free requires is#$Address(account);
{
    call $LibraAccount_add_currency_def($tv0, account);
}

procedure $LibraAccount_add_currency_verify($tv0: $TypeValue, account: $Value) returns ()
free requires is#$Address(account);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_add_currency_def($tv0, account);
}

procedure {:inline 1} $LibraAccount_authentication_key_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t3: $Value; // $Vector_type_value($IntegerType())
    var $t4: $Value; // $Vector_type_value($IntegerType())
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 33496, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<LibraAccount::LibraAccount>($t5)
    call $tmp := $GetGlobal($t5, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 33587);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<LibraAccount::LibraAccount>.authentication_key($t2)
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_authentication_key);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(29, 33585, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_authentication_key(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_authentication_key_def(addr);
}

procedure $LibraAccount_authentication_key_verify(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_authentication_key_def(addr);
}

procedure {:inline 1} $LibraAccount_balance_for_def($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t2: $Value; // $Libra_Libra_type_value($tv0)
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 32106, 0, balance); }

    // bytecode translation starts here
    // $t4 := move(balance)
    call $tmp := $CopyOrMoveValue(balance);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := get_field<LibraAccount::Balance<#0>>.coin($t1)
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_Balance_coin);
    assume $Libra_Libra_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := Libra::value<#0>($t2)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t3 := $Libra_value($tv0, $t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32177);
      goto Abort;
    }
    assume $IsValidU64($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(29, 32170, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_balance_for($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
free requires $LibraAccount_Balance_is_well_formed(balance);
{
    call $ret0 := $LibraAccount_balance_for_def($tv0, balance);
}

procedure $LibraAccount_balance_for_verify($tv0: $TypeValue, balance: $Value) returns ($ret0: $Value)
free requires $LibraAccount_Balance_is_well_formed(balance);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_balance_for_def($tv0, balance);
}

procedure {:inline 1} $LibraAccount_bump_sequence_number_def(signer: $Value) returns (){
    // declare local variables
    var sender_account: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $AddressType()
    var $t4: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t5: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t11: $Reference; // ReferenceType($IntegerType())
    var $t12: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 42262, 0, signer); }

    // bytecode translation starts here
    // $t12 := move(signer)
    call $tmp := $CopyOrMoveValue(signer);
    $t12 := $tmp;

    // $t2 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t2 := $tmp;

    // $t3 := Signer::address_of($t2)
    call $t3 := $Signer_address_of($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 42397);
      goto Abort;
    }
    assume is#$Address($t3);


    // $t4 := borrow_global<LibraAccount::LibraAccount>($t3)
    call $t4 := $BorrowGlobal($t3, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 42357);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t4));

    // UnpackRef($t4)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t4));

    // sender_account := $t4
    call sender_account := $CopyOrMoveRef($t4);
    if (true) { assume $DebugTrackLocal(29, 42340, 1, $Dereference(sender_account)); }

    // $t5 := copy(sender_account)
    call $t5 := $CopyOrMoveRef(sender_account);

    // $t6 := get_field<LibraAccount::LibraAccount>.sequence_number($t5)
    call $tmp := $GetFieldFromReference($t5, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64($tmp);
    $t6 := $tmp;

    // Reference(sender_account) <- $t5
    call sender_account := $WritebackToReference($t5, sender_account);

    // $t7 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;

    // $t8 := 1
    $tmp := $Integer(1);
    $t8 := $tmp;

    // $t9 := +($t7, $t8)
    call $tmp := $AddU64($t7, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 42490);
      goto Abort;
    }
    $t9 := $tmp;

    // $t10 := move(sender_account)
    call $t10 := $CopyOrMoveRef(sender_account);

    // $t11 := borrow_field<LibraAccount::LibraAccount>.sequence_number($t10)
    call $t11 := $BorrowField($t10, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64($Dereference($t11));

    // LibraAccount::LibraAccount <- $t10
    call $WritebackToGlobal($t10);

    // UnpackRef($t11)

    // write_ref($t11, $t9)
    call $t11 := $WriteRef($t11, $t9);
    if (true) { assume $DebugTrackLocal(29, 42426, 1, $Dereference(sender_account)); }

    // LibraAccount::LibraAccount <- $t11
    call $WritebackToGlobal($t11);

    // Reference($t10) <- $t11
    call $t10 := $WritebackToReference($t11, $t10);

    // PackRef($t10)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t10));

    // PackRef($t11)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_bump_sequence_number(signer: $Value) returns ()
free requires is#$Address(signer);
{
    call $LibraAccount_bump_sequence_number_def(signer);
}

procedure $LibraAccount_bump_sequence_number_verify(signer: $Value) returns ()
free requires is#$Address(signer);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_bump_sequence_number_def(signer);
}

procedure {:inline 1} $LibraAccount_create_child_vasp_account_def($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 29787, 0, parent); }
    if (true) { assume $DebugTrackLocal(29, 29787, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 29787, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(29, 29787, 3, add_all_currencies); }

    // bytecode translation starts here
    // $t16 := move(parent)
    call $tmp := $CopyOrMoveValue(parent);
    $t16 := $tmp;

    // $t17 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t17 := $tmp;

    // $t18 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t18 := $tmp;

    // $t19 := move(add_all_currencies)
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t19 := $tmp;

    // $t6 := LibraAccount::create_signer($t17)
    call $t6 := $LibraAccount_create_signer($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t6);


    // new_account := $t6
    call $tmp := $CopyOrMoveValue($t6);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 29986, 4, $tmp); }

    // $t7 := copy($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;

    // $t8 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t8 := $tmp;

    // Roles::new_child_vasp_role($t7, $t8)
    call $Roles_new_child_vasp_role($t7, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 30051);
      goto Abort;
    }

    // $t9 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;

    // $t10 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t10 := $tmp;

    // VASP::publish_child_vasp_credential($t9, $t10)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $VASP_publish_child_vasp_credential($t9, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 30108);
      goto Abort;
    }

    // $t11 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t11 := $tmp;

    // Event::publish_generator($t11)
    call $Event_publish_generator($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 30211);
      goto Abort;
    }

    // $t12 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;

    // LibraAccount::add_currencies_for_account<#0>($t12, $t19)
    call $LibraAccount_add_currencies_for_account($tv0, $t12, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22673);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t18)
    call $LibraAccount_make_account(new_account, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_child_vasp_account($tv0: $TypeValue, parent: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns ()
free requires is#$Address(parent);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
free requires is#$Boolean(add_all_currencies);
{
    call $LibraAccount_create_child_vasp_account_def($tv0, parent, new_account_address, auth_key_prefix, add_all_currencies);
}

procedure {:inline 1} $LibraAccount_create_designated_dealer_def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns (){
    // declare local variables
    var new_dd_account: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 27201, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(29, 27201, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 27201, 2, auth_key_prefix); }

    // bytecode translation starts here
    // $t17 := move(creator_account)
    call $tmp := $CopyOrMoveValue(creator_account);
    $t17 := $tmp;

    // $t18 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t18 := $tmp;

    // $t19 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t19 := $tmp;

    // $t5 := LibraAccount::create_signer($t18)
    call $t5 := $LibraAccount_create_signer($t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t5);


    // new_dd_account := $t5
    call $tmp := $CopyOrMoveValue($t5);
    new_dd_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 27377, 3, $tmp); }

    // $t6 := copy(new_dd_account)
    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t6 := $tmp;

    // Event::publish_generator($t6)
    call $Event_publish_generator($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 27445);
      goto Abort;
    }

    // $t7 := copy(new_dd_account)
    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t7 := $tmp;

    // $t8 := copy($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t8 := $tmp;

    // Libra::publish_preburn_to_account<#0>($t7, $t8)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $Libra_publish_preburn_to_account($tv0, $t7, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 27496);
      goto Abort;
    }

    // $t9 := copy(new_dd_account)
    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t9 := $tmp;

    // $t10 := copy($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t10 := $tmp;

    // DesignatedDealer::publish_designated_dealer_credential($t9, $t10)
    call $DesignatedDealer_publish_designated_dealer_credential($t9, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 27594);
      goto Abort;
    }

    // $t11 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t11 := $tmp;

    // $t12 := copy(new_dd_account)
    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t12 := $tmp;

    // Roles::new_designated_dealer_role($t11, $t12)
    call $Roles_new_designated_dealer_role($t11, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 27681);
      goto Abort;
    }

    // $t13 := copy(new_dd_account)
    call $tmp := $CopyOrMoveValue(new_dd_account);
    $t13 := $tmp;

    // $t14 := false
    $tmp := $Boolean(false);
    $t14 := $tmp;

    // LibraAccount::add_currencies_for_account<#0>($t13, $t14)
    call $LibraAccount_add_currencies_for_account($tv0, $t13, $t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22673);
      goto Abort;
    }

    // LibraAccount::make_account(new_dd_account, $t19)
    call $LibraAccount_make_account(new_dd_account, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_designated_dealer($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $LibraAccount_create_designated_dealer_def($tv0, creator_account, new_account_address, auth_key_prefix);
}

procedure $LibraAccount_create_designated_dealer_verify($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_create_designated_dealer_def($tv0, creator_account, new_account_address, auth_key_prefix);
}

procedure {:inline 1} $LibraAccount_create_parent_vasp_account_def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $Vector_type_value($IntegerType())
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $Vector_type_value($IntegerType())
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $Vector_type_value($IntegerType())
    var $t29: $Value; // $Vector_type_value($IntegerType())
    var $t30: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 28402, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(29, 28402, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 28402, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(29, 28402, 3, human_name); }
    if (true) { assume $DebugTrackLocal(29, 28402, 4, base_url); }
    if (true) { assume $DebugTrackLocal(29, 28402, 5, compliance_public_key); }
    if (true) { assume $DebugTrackLocal(29, 28402, 6, add_all_currencies); }

    // bytecode translation starts here
    // $t24 := move(creator_account)
    call $tmp := $CopyOrMoveValue(creator_account);
    $t24 := $tmp;

    // $t25 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t25 := $tmp;

    // $t26 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t26 := $tmp;

    // $t27 := move(human_name)
    call $tmp := $CopyOrMoveValue(human_name);
    $t27 := $tmp;

    // $t28 := move(base_url)
    call $tmp := $CopyOrMoveValue(base_url);
    $t28 := $tmp;

    // $t29 := move(compliance_public_key)
    call $tmp := $CopyOrMoveValue(compliance_public_key);
    $t29 := $tmp;

    // $t30 := move(add_all_currencies)
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t30 := $tmp;

    // $t9 := LibraAccount::create_signer($t25)
    call $t9 := $LibraAccount_create_signer($t25);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t9);


    // new_account := $t9
    call $tmp := $CopyOrMoveValue($t9);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 28730, 7, $tmp); }

    // $t10 := copy($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t10 := $tmp;

    // $t11 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t11 := $tmp;

    // Roles::new_parent_vasp_role($t10, $t11)
    call $Roles_new_parent_vasp_role($t10, $t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 28795);
      goto Abort;
    }

    // $t12 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;

    // $t13 := copy($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t13 := $tmp;

    // VASP::publish_parent_vasp_credential($t12, $t13)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $VASP_publish_parent_vasp_credential($t12, $t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 28862);
      goto Abort;
    }

    // $t14 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;

    // $t15 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t15 := $tmp;

    // DualAttestation::publish_credential($t14, $t15, $t27, $t28, $t29)
    call $DualAttestation_publish_credential($t14, $t15, $t27, $t28, $t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 28950);
      goto Abort;
    }

    // $t19 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t19 := $tmp;

    // Event::publish_generator($t19)
    call $Event_publish_generator($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 29083);
      goto Abort;
    }

    // $t20 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t20 := $tmp;

    // LibraAccount::add_currencies_for_account<#0>($t20, $t30)
    call $LibraAccount_add_currencies_for_account($tv0, $t20, $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22673);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t26)
    call $LibraAccount_make_account(new_account, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_parent_vasp_account($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, human_name: $Value, base_url: $Value, compliance_public_key: $Value, add_all_currencies: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
free requires $Vector_is_well_formed(human_name) && (forall $$0: int :: {$select_vector(human_name,$$0)} $$0 >= 0 && $$0 < $vlen(human_name) ==> $IsValidU8($select_vector(human_name,$$0)));
free requires $Vector_is_well_formed(base_url) && (forall $$0: int :: {$select_vector(base_url,$$0)} $$0 >= 0 && $$0 < $vlen(base_url) ==> $IsValidU8($select_vector(base_url,$$0)));
free requires $Vector_is_well_formed(compliance_public_key) && (forall $$0: int :: {$select_vector(compliance_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(compliance_public_key) ==> $IsValidU8($select_vector(compliance_public_key,$$0)));
free requires is#$Boolean(add_all_currencies);
{
    call $LibraAccount_create_parent_vasp_account_def($tv0, creator_account, new_account_address, auth_key_prefix, human_name, base_url, compliance_public_key, add_all_currencies);
}

procedure {:inline 1} $LibraAccount_create_root_association_account_def(new_account_address: $Value, auth_key_prefix: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $Vector_type_value($IntegerType())
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 25506, 0, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 25506, 1, auth_key_prefix); }

    // bytecode translation starts here
    // $t19 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t19 := $tmp;

    // $t20 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t20 := $tmp;

    // $t7 := LibraTimestamp::is_genesis()
    call $t7 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 25664);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t3 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 25641, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := 0
    $tmp := $Integer(0);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(29, 25641); }
    goto Abort;

    // L0:
L0:

    // $t11 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t11 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 25746);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := ==($t19, $t11)
    $tmp := $Boolean($IsEqual($t19, $t11));
    $t12 := $tmp;

    // $t5 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 25701, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t14 := 1
    $tmp := $Integer(1);
    $t14 := $tmp;

    // abort($t14)
    if (true) { assume $DebugTrackAbort(29, 25701); }
    goto Abort;

    // L2:
L2:

    // $t16 := LibraAccount::create_signer($t19)
    call $t16 := $LibraAccount_create_signer($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t16);


    // new_account := $t16
    call $tmp := $CopyOrMoveValue($t16);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 25809, 2, $tmp); }

    // LibraAccount::make_account(new_account, $t20)
    call $LibraAccount_make_account(new_account, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_root_association_account(new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $LibraAccount_create_root_association_account_def(new_account_address, auth_key_prefix);
}

procedure $LibraAccount_create_root_association_account_verify(new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_create_root_association_account_def(new_account_address, auth_key_prefix);
}

procedure {:inline 1} $LibraAccount_create_treasury_compliance_account_def(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $Vector_type_value($IntegerType())
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 26148, 0, lr_account); }
    if (true) { assume $DebugTrackLocal(29, 26148, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 26148, 2, auth_key_prefix); }

    // bytecode translation starts here
    // $t24 := move(lr_account)
    call $tmp := $CopyOrMoveValue(lr_account);
    $t24 := $tmp;

    // $t25 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t25 := $tmp;

    // $t26 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t26 := $tmp;

    // $t8 := LibraTimestamp::is_genesis()
    call $t8 := $LibraTimestamp_is_genesis();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 26338);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t4 := $t8
    call $tmp := $CopyOrMoveValue($t8);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 26315, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t10 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t10 := $tmp;

    // destroy($t10)

    // $t11 := 0
    $tmp := $Integer(0);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(29, 26315); }
    goto Abort;

    // L0:
L0:

    // $t12 := copy($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t12 := $tmp;

    // $t13 := Roles::has_libra_root_role($t12)
    call $t13 := $Roles_has_libra_root_role($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 26389);
      goto Abort;
    }
    assume is#$Boolean($t13);


    // $t6 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 26375, 6, $tmp); }

    // if ($t6) goto L2 else goto L3
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t15 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 11
    $tmp := $Integer(11);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(29, 26375); }
    goto Abort;

    // L2:
L2:

    // $t18 := LibraAccount::create_signer($t25)
    call $t18 := $LibraAccount_create_signer($t25);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t18);


    // new_account := $t18
    call $tmp := $CopyOrMoveValue($t18);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 26452, 3, $tmp); }

    // $t19 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t19 := $tmp;

    // $t20 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t20 := $tmp;

    // SlidingNonce::publish_nonce_resource($t19, $t20)
    call $SlidingNonce_publish_nonce_resource($t19, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 26524);
      goto Abort;
    }

    // $t21 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t21 := $tmp;

    // Event::publish_generator($t21)
    call $Event_publish_generator($t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 26589);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t26)
    call $LibraAccount_make_account(new_account, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_treasury_compliance_account(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(lr_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $LibraAccount_create_treasury_compliance_account_def(lr_account, new_account_address, auth_key_prefix);
}

procedure $LibraAccount_create_treasury_compliance_account_verify(lr_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(lr_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_create_treasury_compliance_account_def(lr_account, new_account_address, auth_key_prefix);
}

procedure {:inline 1} $LibraAccount_create_unhosted_account_def($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $BooleanType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $Vector_type_value($IntegerType())
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $AddressType()
    var $t31: $Value; // $Vector_type_value($IntegerType())
    var $t32: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 30935, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(29, 30935, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 30935, 2, auth_key_prefix); }
    if (true) { assume $DebugTrackLocal(29, 30935, 3, add_all_currencies); }

    // bytecode translation starts here
    // $t29 := move(creator_account)
    call $tmp := $CopyOrMoveValue(creator_account);
    $t29 := $tmp;

    // $t30 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t30 := $tmp;

    // $t31 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t31 := $tmp;

    // $t32 := move(add_all_currencies)
    call $tmp := $CopyOrMoveValue(add_all_currencies);
    $t32 := $tmp;

    // $t9 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t9 := $tmp;

    // $t10 := Roles::has_libra_root_role($t9)
    call $t10 := $Roles_has_libra_root_role($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31150);
      goto Abort;
    }
    assume is#$Boolean($t10);


    // $t5 := $t10
    call $tmp := $CopyOrMoveValue($t10);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 31136, 5, $tmp); }

    // if ($t5) goto L0 else goto L1
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t12 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t12 := $tmp;

    // destroy($t12)

    // $t13 := 11
    $tmp := $Integer(11);
    $t13 := $tmp;

    // abort($t13)
    if (true) { assume $DebugTrackAbort(29, 31136); }
    goto Abort;

    // L0:
L0:

    // $t15 := LibraAccount::exists_at($t30)
    call $t15 := $LibraAccount_exists_at($t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 34677);
      goto Abort;
    }
    assume is#$Boolean($t15);


    // $t16 := !($t15)
    call $tmp := $Not($t15);
    $t16 := $tmp;

    // $t7 := $t16
    call $tmp := $CopyOrMoveValue($t16);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 31214, 7, $tmp); }

    // if ($t7) goto L2 else goto L3
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t18 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t18 := $tmp;

    // destroy($t18)

    // $t19 := 12
    $tmp := $Integer(12);
    $t19 := $tmp;

    // abort($t19)
    if (true) { assume $DebugTrackAbort(29, 31214); }
    goto Abort;

    // L2:
L2:

    // $t21 := LibraAccount::create_signer($t30)
    call $t21 := $LibraAccount_create_signer($t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t21);


    // new_account := $t21
    call $tmp := $CopyOrMoveValue($t21);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 31292, 4, $tmp); }

    // $t22 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t22 := $tmp;

    // $t23 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t23 := $tmp;

    // Roles::new_unhosted_role($t22, $t23)
    call $Roles_new_unhosted_role($t22, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31357);
      goto Abort;
    }

    // $t24 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t24 := $tmp;

    // Event::publish_generator($t24)
    call $Event_publish_generator($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31422);
      goto Abort;
    }

    // $t25 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t25 := $tmp;

    // LibraAccount::add_currencies_for_account<#0>($t25, $t32)
    call $LibraAccount_add_currencies_for_account($tv0, $t25, $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22673);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t31)
    call $LibraAccount_make_account(new_account, $t31);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_unhosted_account($tv0: $TypeValue, creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value, add_all_currencies: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
free requires is#$Boolean(add_all_currencies);
{
    call $LibraAccount_create_unhosted_account_def($tv0, creator_account, new_account_address, auth_key_prefix, add_all_currencies);
}

procedure {:inline 1} $LibraAccount_create_validator_account_def(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 42754, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(29, 42754, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 42754, 2, auth_key_prefix); }

    // bytecode translation starts here
    // $t18 := move(creator_account)
    call $tmp := $CopyOrMoveValue(creator_account);
    $t18 := $tmp;

    // $t19 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t19 := $tmp;

    // $t20 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t20 := $tmp;

    // $t6 := copy($t18)
    call $tmp := $CopyOrMoveValue($t18);
    $t6 := $tmp;

    // $t7 := Roles::has_libra_root_role($t6)
    call $t7 := $Roles_has_libra_root_role($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 42930);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t4 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 42916, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := move($t18)
    call $tmp := $CopyOrMoveValue($t18);
    $t9 := $tmp;

    // destroy($t9)

    // $t10 := 11
    $tmp := $Integer(11);
    $t10 := $tmp;

    // abort($t10)
    if (true) { assume $DebugTrackAbort(29, 42916); }
    goto Abort;

    // L0:
L0:

    // $t12 := LibraAccount::create_signer($t19)
    call $t12 := $LibraAccount_create_signer($t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t12);


    // new_account := $t12
    call $tmp := $CopyOrMoveValue($t12);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 42998, 3, $tmp); }

    // $t13 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t13 := $tmp;

    // Event::publish_generator($t13)
    call $Event_publish_generator($t13);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 43063);
      goto Abort;
    }

    // $t14 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t14 := $tmp;

    // $t15 := move($t18)
    call $tmp := $CopyOrMoveValue($t18);
    $t15 := $tmp;

    // ValidatorConfig::publish($t14, $t15)
    call $ValidatorConfig_publish($t14, $t15);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 43121);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t20)
    call $LibraAccount_make_account(new_account, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_validator_account(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $LibraAccount_create_validator_account_def(creator_account, new_account_address, auth_key_prefix);
}

procedure $LibraAccount_create_validator_account_verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_create_validator_account_def(creator_account, new_account_address, auth_key_prefix);
}

procedure {:inline 1} $LibraAccount_create_validator_operator_account_def(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns (){
    // declare local variables
    var new_account: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $Vector_type_value($IntegerType())
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 43299, 0, creator_account); }
    if (true) { assume $DebugTrackLocal(29, 43299, 1, new_account_address); }
    if (true) { assume $DebugTrackLocal(29, 43299, 2, auth_key_prefix); }

    // bytecode translation starts here
    // $t15 := move(creator_account)
    call $tmp := $CopyOrMoveValue(creator_account);
    $t15 := $tmp;

    // $t16 := move(new_account_address)
    call $tmp := $CopyOrMoveValue(new_account_address);
    $t16 := $tmp;

    // $t17 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t17 := $tmp;

    // $t6 := move($t15)
    call $tmp := $CopyOrMoveValue($t15);
    $t6 := $tmp;

    // $t7 := Roles::has_libra_root_role($t6)
    call $t7 := $Roles_has_libra_root_role($t6);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 43484);
      goto Abort;
    }
    assume is#$Boolean($t7);


    // $t4 := $t7
    call $tmp := $CopyOrMoveValue($t7);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 43470, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t9 := 11
    $tmp := $Integer(11);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(29, 43470); }
    goto Abort;

    // L0:
L0:

    // $t11 := LibraAccount::create_signer($t16)
    call $t11 := $LibraAccount_create_signer($t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 31949);
      goto Abort;
    }
    assume is#$Address($t11);


    // new_account := $t11
    call $tmp := $CopyOrMoveValue($t11);
    new_account := $tmp;
    if (true) { assume $DebugTrackLocal(29, 43552, 3, $tmp); }

    // $t12 := copy(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t12 := $tmp;

    // Event::publish_generator($t12)
    call $Event_publish_generator($t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 43617);
      goto Abort;
    }

    // LibraAccount::make_account(new_account, $t17)
    call $LibraAccount_make_account(new_account, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 23938);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_create_validator_operator_account(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $LibraAccount_create_validator_operator_account_def(creator_account, new_account_address, auth_key_prefix);
}

procedure $LibraAccount_create_validator_operator_account_verify(creator_account: $Value, new_account_address: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(creator_account);
free requires is#$Address(new_account_address);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_create_validator_operator_account_def(creator_account, new_account_address, auth_key_prefix);
}

procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t3: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 33738, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<LibraAccount::LibraAccount>($t5)
    call $tmp := $GetGlobal($t5, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 33857);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<LibraAccount::LibraAccount>.key_rotation_capability($t2)
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_key_rotation_capability);
    assume $Option_Option_is_well_formed($tmp);
    $t3 := $tmp;

    // $t4 := Option::is_none<LibraAccount::KeyRotationCapability>($t3)
    call $t4 := $Option_is_none($LibraAccount_KeyRotationCapability_type_value(), $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 33848);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(29, 33840, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_delegated_key_rotation_capability(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_delegated_key_rotation_capability_def(addr);
}

procedure $LibraAccount_delegated_key_rotation_capability_verify(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_delegated_key_rotation_capability_def(addr);
}

procedure {:inline 1} $LibraAccount_delegated_withdraw_capability_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t3: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 34010, 0, addr); }

    // bytecode translation starts here
    // $t5 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t5 := $tmp;

    // $t2 := get_global<LibraAccount::LibraAccount>($t5)
    call $tmp := $GetGlobal($t5, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 34125);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := get_field<LibraAccount::LibraAccount>.withdrawal_capability($t2)
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_LibraAccount_withdrawal_capability);
    assume $Option_Option_is_well_formed($tmp);
    $t3 := $tmp;

    // $t4 := Option::is_none<LibraAccount::WithdrawCapability>($t3)
    call $t4 := $Option_is_none($LibraAccount_WithdrawCapability_type_value(), $t3);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 34116);
      goto Abort;
    }
    assume is#$Boolean($t4);


    // return $t4
    $ret0 := $t4;
    if (true) { assume $DebugTrackLocal(29, 34108, 6, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_delegated_withdraw_capability(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_delegated_withdraw_capability_def(addr);
}

procedure $LibraAccount_delegated_withdraw_capability_verify(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_delegated_withdraw_capability_def(addr);
}

procedure {:inline 1} $LibraAccount_epilogue_def($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value) returns (){
    // declare local variables
    var sender_account: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var sender_balance: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t5: $Value; // $AddressType()
    var $t6: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t11: $Reference; // ReferenceType($IntegerType())
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $Libra_Libra_type_value($tv0)
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 39488, 0, sender); }
    if (true) { assume $DebugTrackLocal(29, 39488, 1, transaction_fee_amount); }
    if (true) { assume $DebugTrackLocal(29, 39488, 2, txn_sequence_number); }

    // bytecode translation starts here
    // $t22 := move(sender)
    call $tmp := $CopyOrMoveValue(sender);
    $t22 := $tmp;

    // $t23 := move(transaction_fee_amount)
    call $tmp := $CopyOrMoveValue(transaction_fee_amount);
    $t23 := $tmp;

    // $t24 := move(txn_sequence_number)
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t24 := $tmp;

    // $t6 := borrow_global<LibraAccount::LibraAccount>($t22)
    call $t6 := $BorrowGlobal($t22, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 39773);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t6));

    // UnpackRef($t6)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t6));

    // sender_account := $t6
    call sender_account := $CopyOrMoveRef($t6);
    if (true) { assume $DebugTrackLocal(29, 39756, 3, $Dereference(sender_account)); }

    // $t8 := 1
    $tmp := $Integer(1);
    $t8 := $tmp;

    // $t9 := +($t24, $t8)
    call $tmp := $AddU64($t24, $t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 39912);
      goto Abort;
    }
    $t9 := $tmp;

    // $t10 := move(sender_account)
    call $t10 := $CopyOrMoveRef(sender_account);

    // $t11 := borrow_field<LibraAccount::LibraAccount>.sequence_number($t10)
    call $t11 := $BorrowField($t10, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64($Dereference($t11));

    // LibraAccount::LibraAccount <- $t10
    call $WritebackToGlobal($t10);

    // UnpackRef($t11)

    // write_ref($t11, $t9)
    call $t11 := $WriteRef($t11, $t9);
    if (true) { assume $DebugTrackLocal(29, 39859, 3, $Dereference(sender_account)); }
    if (true) { assume $DebugTrackLocal(29, 39859, 4, $Dereference(sender_balance)); }

    // LibraAccount::LibraAccount <- $t11
    call $WritebackToGlobal($t11);

    // Reference($t10) <- $t11
    call $t10 := $WritebackToReference($t11, $t10);

    // PackRef($t10)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t10));

    // PackRef($t11)

    // $t13 := 0
    $tmp := $Integer(0);
    $t13 := $tmp;

    // $t14 := >($t23, $t13)
    call $tmp := $Gt($t23, $t13);
    $t14 := $tmp;

    // if ($t14) goto L0 else goto L1
    $tmp := $t14;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t16 := borrow_global<LibraAccount::Balance<#0>>($t22)
    call $t16 := $BorrowGlobal($t22, $LibraAccount_Balance_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 39993);
      goto Abort;
    }
    assume $LibraAccount_Balance_is_well_formed($Dereference($t16));

    // UnpackRef($t16)
    call $LibraAccount_Balance_before_update_inv($tv0, $Dereference($t16));

    // sender_balance := $t16
    call sender_balance := $CopyOrMoveRef($t16);
    if (true) { assume $DebugTrackLocal(29, 39976, 4, $Dereference(sender_balance)); }

    // $t18 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t18 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 40175);
      goto Abort;
    }
    assume is#$Address($t18);


    // $t19 := move(sender_balance)
    call $t19 := $CopyOrMoveRef(sender_balance);

    // $t25 := read_ref($t19)
    call $tmp := $ReadRef($t19);
    assume $LibraAccount_Balance_is_well_formed($tmp);
    $t25 := $tmp;

    // ($t21, $t25) := LibraAccount::withdraw_from_balance<#0>($t22, $t18, $t25, $t23)
    call $t21, $t25 := $LibraAccount_withdraw_from_balance($tv0, $t22, $t18, $t25, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 16795);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t21);

    assume $LibraAccount_Balance_is_well_formed($t25);


    // write_ref($t19, $t25)
    call $t19 := $WriteRef($t19, $t25);
    if (true) { assume $DebugTrackLocal(29, 39926, 3, $Dereference(sender_account)); }
    if (true) { assume $DebugTrackLocal(29, 39926, 4, $Dereference(sender_balance)); }

    // LibraAccount::Balance <- $t19
    call $WritebackToGlobal($t19);

    // PackRef($t19)
    call $LibraAccount_Balance_after_update_inv($tv0, $Dereference($t19));

    // TransactionFee::pay_fee<#0>($t21)
    call $TransactionFee_pay_fee($tv0, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 40064);
      goto Abort;
    }

    // goto L2
    goto L2;

    // L2:
L2:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_epilogue($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value) returns ()
free requires is#$Address(sender);
free requires $IsValidU64(transaction_fee_amount);
free requires $IsValidU64(txn_sequence_number);
{
    call $LibraAccount_epilogue_def($tv0, sender, transaction_fee_amount, txn_sequence_number);
}

procedure $LibraAccount_epilogue_verify($tv0: $TypeValue, sender: $Value, transaction_fee_amount: $Value, txn_sequence_number: $Value) returns ()
free requires is#$Address(sender);
free requires $IsValidU64(transaction_fee_amount);
free requires $IsValidU64(txn_sequence_number);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_epilogue_def($tv0, sender, transaction_fee_amount, txn_sequence_number);
}

procedure {:inline 1} $LibraAccount_extract_key_rotation_capability_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var account#1473: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var account_address: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t14: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t15: $Reference; // ReferenceType($Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value()))
    var $t16: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 21648, 0, account); }

    // bytecode translation starts here
    // $t17 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t17 := $tmp;

    // $t5 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;

    // $t6 := Signer::address_of($t5)
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 21798);
      goto Abort;
    }
    assume is#$Address($t6);


    // account_address := $t6
    call $tmp := $CopyOrMoveValue($t6);
    account_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 21772, 2, $tmp); }

    // $t8 := LibraAccount::delegated_key_rotation_capability(account_address)
    call $t8 := $LibraAccount_delegated_key_rotation_capability(account_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 33749);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t9 := !($t8)
    call $tmp := $Not($t8);
    $t9 := $tmp;

    // $t3 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 21921, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t11 := 9
    $tmp := $Integer(9);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(29, 21921); }
    goto Abort;

    // L0:
L0:

    // $t13 := borrow_global<LibraAccount::LibraAccount>(account_address)
    call $t13 := $BorrowGlobal(account_address, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22048);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t13));

    // UnpackRef($t13)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t13));

    // account#1473 := $t13
    call account#1473 := $CopyOrMoveRef($t13);
    if (true) { assume $DebugTrackLocal(29, 22038, 1, $Dereference(account#1473)); }

    // $t14 := move(account#1473)
    call $t14 := $CopyOrMoveRef(account#1473);

    // $t15 := borrow_field<LibraAccount::LibraAccount>.key_rotation_capability($t14)
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_key_rotation_capability);
    assume $Option_Option_is_well_formed_types($Dereference($t15));

    // LibraAccount::LibraAccount <- $t14
    call $WritebackToGlobal($t14);

    // UnpackRef($t15)
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));

    // PackRef($t15)
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));

    // $t18 := read_ref($t15)
    call $tmp := $ReadRef($t15);
    assume $Option_Option_is_well_formed($tmp);
    $t18 := $tmp;

    // ($t16, $t18) := Option::extract<LibraAccount::KeyRotationCapability>($t18)
    call $t16, $t18 := $Option_extract($LibraAccount_KeyRotationCapability_type_value(), $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22114);
      goto Abort;
    }
    assume $LibraAccount_KeyRotationCapability_is_well_formed($t16);

    assume $Option_Option_is_well_formed($t18);


    // write_ref($t15, $t18)
    call $t15 := $WriteRef($t15, $t18);
    if (true) { assume $DebugTrackLocal(29, 22106, 1, $Dereference(account#1473)); }

    // LibraAccount::LibraAccount <- $t15
    call $WritebackToGlobal($t15);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // UnpackRef($t15)
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));

    // PackRef($t14)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));

    // PackRef($t15)
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t15));

    // return $t16
    $ret0 := $t16;
    if (true) { assume $DebugTrackLocal(29, 22106, 19, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_extract_key_rotation_capability(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
{
    call $ret0 := $LibraAccount_extract_key_rotation_capability_def(account);
}

procedure $LibraAccount_extract_key_rotation_capability_verify(account: $Value) returns ($ret0: $Value)
free requires is#$Address(account);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_extract_key_rotation_capability_def(account);
}

procedure {:inline 1} $LibraAccount_extract_withdraw_capability_def(sender: $Value) returns ($ret0: $Value){
    // declare local variables
    var account: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var sender_addr: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t14: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t15: $Reference; // ReferenceType($Option_Option_type_value($LibraAccount_WithdrawCapability_type_value()))
    var $t16: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 19129, 0, sender); }

    // bytecode translation starts here
    // $t17 := move(sender)
    call $tmp := $CopyOrMoveValue(sender);
    $t17 := $tmp;

    // $t5 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t5 := $tmp;

    // $t6 := Signer::address_of($t5)
    call $t6 := $Signer_address_of($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 19277);
      goto Abort;
    }
    assume is#$Address($t6);


    // sender_addr := $t6
    call $tmp := $CopyOrMoveValue($t6);
    sender_addr := $tmp;
    if (true) { assume $DebugTrackLocal(29, 19255, 2, $tmp); }

    // $t8 := LibraAccount::delegated_withdraw_capability(sender_addr)
    call $t8 := $LibraAccount_delegated_withdraw_capability(sender_addr);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 34021);
      goto Abort;
    }
    assume is#$Boolean($t8);


    // $t9 := !($t8)
    call $tmp := $Not($t8);
    $t9 := $tmp;

    // $t3 := $t9
    call $tmp := $CopyOrMoveValue($t9);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 19395, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t11 := 7
    $tmp := $Integer(7);
    $t11 := $tmp;

    // abort($t11)
    if (true) { assume $DebugTrackAbort(29, 19395); }
    goto Abort;

    // L0:
L0:

    // $t13 := borrow_global<LibraAccount::LibraAccount>(sender_addr)
    call $t13 := $BorrowGlobal(sender_addr, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 19512);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t13));

    // UnpackRef($t13)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t13));

    // account := $t13
    call account := $CopyOrMoveRef($t13);
    if (true) { assume $DebugTrackLocal(29, 19502, 1, $Dereference(account)); }

    // $t14 := move(account)
    call $t14 := $CopyOrMoveRef(account);

    // $t15 := borrow_field<LibraAccount::LibraAccount>.withdrawal_capability($t14)
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_withdrawal_capability);
    assume $Option_Option_is_well_formed_types($Dereference($t15));

    // LibraAccount::LibraAccount <- $t14
    call $WritebackToGlobal($t14);

    // UnpackRef($t15)
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));

    // PackRef($t15)
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));

    // $t18 := read_ref($t15)
    call $tmp := $ReadRef($t15);
    assume $Option_Option_is_well_formed($tmp);
    $t18 := $tmp;

    // ($t16, $t18) := Option::extract<LibraAccount::WithdrawCapability>($t18)
    call $t16, $t18 := $Option_extract($LibraAccount_WithdrawCapability_type_value(), $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 19574);
      goto Abort;
    }
    assume $LibraAccount_WithdrawCapability_is_well_formed($t16);

    assume $Option_Option_is_well_formed($t18);


    // write_ref($t15, $t18)
    call $t15 := $WriteRef($t15, $t18);
    if (true) { assume $DebugTrackLocal(29, 19566, 1, $Dereference(account)); }

    // LibraAccount::LibraAccount <- $t15
    call $WritebackToGlobal($t15);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // UnpackRef($t15)
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));

    // PackRef($t14)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));

    // PackRef($t15)
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t15));

    // return $t16
    $ret0 := $t16;
    if (true) { assume $DebugTrackLocal(29, 19566, 19, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_extract_withdraw_capability(sender: $Value) returns ($ret0: $Value)
free requires is#$Address(sender);
{
    call $ret0 := $LibraAccount_extract_withdraw_capability_def(sender);
}

procedure $LibraAccount_extract_withdraw_capability_verify(sender: $Value) returns ($ret0: $Value)
free requires is#$Address(sender);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_extract_withdraw_capability_def(sender);
}

procedure {:inline 1} $LibraAccount_failure_epilogue_def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns (){
    // declare local variables
    var sender: $Value; // $AddressType()
    var transaction_fee_amount: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $IntegerType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 41518, 0, account); }
    if (true) { assume $DebugTrackLocal(29, 41518, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(29, 41518, 2, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(29, 41518, 3, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(29, 41518, 4, gas_units_remaining); }

    // bytecode translation starts here
    // $t17 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t17 := $tmp;

    // $t18 := move(txn_sequence_number)
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t18 := $tmp;

    // $t19 := move(txn_gas_price)
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t19 := $tmp;

    // $t20 := move(txn_max_gas_units)
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t20 := $tmp;

    // $t21 := move(gas_units_remaining)
    call $tmp := $CopyOrMoveValue(gas_units_remaining);
    $t21 := $tmp;

    // $t7 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t7 := $tmp;

    // $t8 := Signer::address_of($t7)
    call $t8 := $Signer_address_of($t7);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 41797);
      goto Abort;
    }
    assume is#$Address($t8);


    // sender := $t8
    call $tmp := $CopyOrMoveValue($t8);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(29, 41780, 5, $tmp); }

    // $t12 := -($t20, $t21)
    call $tmp := $Sub($t20, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 41916);
      goto Abort;
    }
    $t12 := $tmp;

    // $t13 := *($t19, $t12)
    call $tmp := $MulU64($t19, $t12);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 41895);
      goto Abort;
    }
    $t13 := $tmp;

    // transaction_fee_amount := $t13
    call $tmp := $CopyOrMoveValue($t13);
    transaction_fee_amount := $tmp;
    if (true) { assume $DebugTrackLocal(29, 41856, 6, $tmp); }

    // LibraAccount::epilogue<#0>(sender, transaction_fee_amount, $t18)
    call $LibraAccount_epilogue($tv0, sender, transaction_fee_amount, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 39492);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_failure_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
free requires is#$Address(account);
free requires $IsValidU64(txn_sequence_number);
free requires $IsValidU64(txn_gas_price);
free requires $IsValidU64(txn_max_gas_units);
free requires $IsValidU64(gas_units_remaining);
{
    call $LibraAccount_failure_epilogue_def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}

procedure $LibraAccount_failure_epilogue_verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
free requires is#$Address(account);
free requires $IsValidU64(txn_sequence_number);
free requires $IsValidU64(txn_gas_price);
free requires $IsValidU64(txn_max_gas_units);
free requires $IsValidU64(gas_units_remaining);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_failure_epilogue_def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}

procedure {:inline 1} $LibraAccount_freeze_account_def(account: $Value, frozen_address: $Value) returns (){
    // declare local variables
    var initiator_address: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $IntegerType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $AddressType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $AddressType()
    var $t28: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t29: $Reference; // ReferenceType($BooleanType())
    var $t30: $Value; // $AddressType()
    var $t31: $Reference; // ReferenceType($LibraAccount_AccountOperationsCapability_type_value())
    var $t32: $Reference; // ReferenceType($Event_EventHandle_type_value($LibraAccount_FreezeAccountEvent_type_value()))
    var $t33: $Value; // $AddressType()
    var $t34: $Value; // $AddressType()
    var $t35: $Value; // $LibraAccount_FreezeAccountEvent_type_value()
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $AddressType()
    var $t38: $Value; // $Event_EventHandle_type_value($LibraAccount_FreezeAccountEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 34983, 0, account); }
    if (true) { assume $DebugTrackLocal(29, 34983, 1, frozen_address); }

    // bytecode translation starts here
    // $t36 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t36 := $tmp;

    // $t37 := move(frozen_address)
    call $tmp := $CopyOrMoveValue(frozen_address);
    $t37 := $tmp;

    // $t9 := copy($t36)
    call $tmp := $CopyOrMoveValue($t36);
    $t9 := $tmp;

    // $t10 := Roles::has_treasury_compliance_role($t9)
    call $t10 := $Roles_has_treasury_compliance_role($t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35154);
      goto Abort;
    }
    assume is#$Boolean($t10);


    // $t3 := $t10
    call $tmp := $CopyOrMoveValue($t10);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 35140, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t12 := move($t36)
    call $tmp := $CopyOrMoveValue($t36);
    $t12 := $tmp;

    // destroy($t12)

    // $t13 := 14
    $tmp := $Integer(14);
    $t13 := $tmp;

    // abort($t13)
    if (true) { assume $DebugTrackAbort(29, 35140); }
    goto Abort;

    // L0:
L0:

    // $t14 := move($t36)
    call $tmp := $CopyOrMoveValue($t36);
    $t14 := $tmp;

    // $t15 := Signer::address_of($t14)
    call $t15 := $Signer_address_of($t14);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35260);
      goto Abort;
    }
    assume is#$Address($t15);


    // initiator_address := $t15
    call $tmp := $CopyOrMoveValue($t15);
    initiator_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 35232, 2, $tmp); }

    // $t17 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t17 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35388);
      goto Abort;
    }
    assume is#$Address($t17);


    // $t18 := !=($t37, $t17)
    $tmp := $Boolean(!$IsEqual($t37, $t17));
    $t18 := $tmp;

    // $t5 := $t18
    call $tmp := $CopyOrMoveValue($t18);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 35348, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t20 := 15
    $tmp := $Integer(15);
    $t20 := $tmp;

    // abort($t20)
    if (true) { assume $DebugTrackAbort(29, 35348); }
    goto Abort;

    // L2:
L2:

    // $t22 := CoreAddresses::TREASURY_COMPLIANCE_ADDRESS()
    call $t22 := $CoreAddresses_TREASURY_COMPLIANCE_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35486);
      goto Abort;
    }
    assume is#$Address($t22);


    // $t23 := !=($t37, $t22)
    $tmp := $Boolean(!$IsEqual($t37, $t22));
    $t23 := $tmp;

    // $t7 := $t23
    call $tmp := $CopyOrMoveValue($t23);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 35446, 7, $tmp); }

    // if ($t7) goto L4 else goto L5
    $tmp := $t7;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t25 := 15
    $tmp := $Integer(15);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(29, 35446); }
    goto Abort;

    // L4:
L4:

    // $t26 := true
    $tmp := $Boolean(true);
    $t26 := $tmp;

    // $t28 := borrow_global<LibraAccount::LibraAccount>($t37)
    call $t28 := $BorrowGlobal($t37, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35553);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t28));

    // UnpackRef($t28)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t28));

    // $t29 := borrow_field<LibraAccount::LibraAccount>.is_frozen($t28)
    call $t29 := $BorrowField($t28, $LibraAccount_LibraAccount_is_frozen);
    assume is#$Boolean($Dereference($t29));

    // LibraAccount::LibraAccount <- $t28
    call $WritebackToGlobal($t28);

    // UnpackRef($t29)

    // write_ref($t29, $t26)
    call $t29 := $WriteRef($t29, $t26);

    // LibraAccount::LibraAccount <- $t29
    call $WritebackToGlobal($t29);

    // Reference($t28) <- $t29
    call $t28 := $WritebackToReference($t29, $t28);

    // PackRef($t28)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t28));

    // PackRef($t29)

    // $t30 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t30 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35745);
      goto Abort;
    }
    assume is#$Address($t30);


    // $t31 := borrow_global<LibraAccount::AccountOperationsCapability>($t30)
    call $t31 := $BorrowGlobal($t30, $LibraAccount_AccountOperationsCapability_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35683);
      goto Abort;
    }
    assume $LibraAccount_AccountOperationsCapability_is_well_formed($Dereference($t31));

    // UnpackRef($t31)

    // $t32 := borrow_field<LibraAccount::AccountOperationsCapability>.freeze_event_handle($t31)
    call $t32 := $BorrowField($t31, $LibraAccount_AccountOperationsCapability_freeze_event_handle);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t32));

    // LibraAccount::AccountOperationsCapability <- $t31
    call $WritebackToGlobal($t31);

    // UnpackRef($t32)

    // $t35 := pack LibraAccount::FreezeAccountEvent(initiator_address, $t37)
    call $tmp := $LibraAccount_FreezeAccountEvent_pack(0, 0, 0, initiator_address, $t37);
    $t35 := $tmp;

    // PackRef($t32)

    // $t38 := read_ref($t32)
    call $tmp := $ReadRef($t32);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t38 := $tmp;

    // $t38 := Event::emit_event<LibraAccount::FreezeAccountEvent>($t38, $t35)
    call $t38 := $Event_emit_event($LibraAccount_FreezeAccountEvent_type_value(), $t38, $t35);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 35634);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t38);


    // write_ref($t32, $t38)
    call $t32 := $WriteRef($t32, $t38);

    // LibraAccount::AccountOperationsCapability <- $t32
    call $WritebackToGlobal($t32);

    // Reference($t31) <- $t32
    call $t31 := $WritebackToReference($t32, $t31);

    // UnpackRef($t32)

    // PackRef($t31)

    // PackRef($t32)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_freeze_account(account: $Value, frozen_address: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(frozen_address);
{
    call $LibraAccount_freeze_account_def(account, frozen_address);
}

procedure {:inline 1} $LibraAccount_grant_module_publishing_privilege_def(account: $Value) returns (){
    // declare local variables
    var $t1: $Value; // $BooleanType()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $LibraAccount_PublishModule_type_value()
    var $t20: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 6276, 0, account); }

    // bytecode translation starts here
    // $t20 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t20 := $tmp;

    // $t5 := copy($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t5 := $tmp;

    // $t6 := Roles::has_libra_root_role($t5)
    call $t6 := $Roles_has_libra_root_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 6539);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t1 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t1 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 6525, 1, $tmp); }

    // if ($t1) goto L0 else goto L1
    $tmp := $t1;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 11
    $tmp := $Integer(11);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(29, 6525); }
    goto Abort;

    // L0:
L0:

    // $t10 := copy($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 6610);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t12 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 6648);
      goto Abort;
    }
    assume is#$Address($t12);


    // $t13 := ==($t11, $t12)
    $tmp := $Boolean($IsEqual($t11, $t12));
    $t13 := $tmp;

    // $t3 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 6595, 3, $tmp); }

    // if ($t3) goto L2 else goto L3
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t15 := move($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t15 := $tmp;

    // destroy($t15)

    // $t16 := 1
    $tmp := $Integer(1);
    $t16 := $tmp;

    // abort($t16)
    if (true) { assume $DebugTrackAbort(29, 6595); }
    goto Abort;

    // L2:
L2:

    // $t17 := move($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t17 := $tmp;

    // $t18 := false
    $tmp := $Boolean(false);
    $t18 := $tmp;

    // $t19 := pack LibraAccount::PublishModule($t18)
    call $tmp := $LibraAccount_PublishModule_pack(0, 0, 0, $t18);
    $t19 := $tmp;

    // move_to<LibraAccount::PublishModule>($t19, $t17)
    call $MoveTo($LibraAccount_PublishModule_type_value(), $t19, $t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 6707);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_grant_module_publishing_privilege(account: $Value) returns ()
free requires is#$Address(account);
{
    call $LibraAccount_grant_module_publishing_privilege_def(account);
}

procedure $LibraAccount_grant_module_publishing_privilege_verify(account: $Value) returns ()
free requires is#$Address(account);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_grant_module_publishing_privilege_def(account);
}

procedure {:inline 1} $LibraAccount_key_rotation_capability_address_def(cap: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 34490, 0, cap); }

    // bytecode translation starts here
    // $t3 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := get_field<LibraAccount::KeyRotationCapability>.account_address($t1)
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_KeyRotationCapability_account_address);
    assume is#$Address($tmp);
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(29, 34582, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_key_rotation_capability_address(cap: $Value) returns ($ret0: $Value)
free requires $LibraAccount_KeyRotationCapability_is_well_formed(cap);
{
    call $ret0 := $LibraAccount_key_rotation_capability_address_def(cap);
}

procedure $LibraAccount_key_rotation_capability_address_verify(cap: $Value) returns ($ret0: $Value)
free requires $LibraAccount_KeyRotationCapability_is_well_formed(cap);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_key_rotation_capability_address_def(cap);
}

procedure {:inline 1} $LibraAccount_make_account_def(new_account: $Value, auth_key_prefix: $Value) returns (){
    // declare local variables
    var authentication_key: $Value; // $Vector_type_value($IntegerType())
    var new_account_addr: $Value; // $AddressType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $IntegerType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $BooleanType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t30: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $t31: $Value; // $AddressType()
    var $t32: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t33: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $t34: $Value; // $AddressType()
    var $t35: $Value; // $Event_EventHandle_type_value($LibraAccount_ReceivedPaymentEvent_type_value())
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value())
    var $t38: $Value; // $IntegerType()
    var $t39: $Value; // $BooleanType()
    var $t40: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t41: $Value; // $AddressType()
    var $t42: $Value; // $AddressType()
    var $t43: $Value; // $Vector_type_value($IntegerType())
    var $t44: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 23934, 0, new_account); }
    if (true) { assume $DebugTrackLocal(29, 23934, 1, auth_key_prefix); }

    // bytecode translation starts here
    // $t42 := move(new_account)
    call $tmp := $CopyOrMoveValue(new_account);
    $t42 := $tmp;

    // $t43 := move(auth_key_prefix)
    call $tmp := $CopyOrMoveValue(auth_key_prefix);
    $t43 := $tmp;

    // $t8 := copy($t42)
    call $tmp := $CopyOrMoveValue($t42);
    $t8 := $tmp;

    // $t9 := Signer::address_of($t8)
    call $t9 := $Signer_address_of($t8);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24065);
      goto Abort;
    }
    assume is#$Address($t9);


    // new_account_addr := $t9
    call $tmp := $CopyOrMoveValue($t9);
    new_account_addr := $tmp;
    if (true) { assume $DebugTrackLocal(29, 24038, 3, $tmp); }

    // $t11 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t11 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24205);
      goto Abort;
    }
    assume is#$Address($t11);


    // $t12 := !=(new_account_addr, $t11)
    $tmp := $Boolean(!$IsEqual(new_account_addr, $t11));
    $t12 := $tmp;

    // $t4 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 24163, 4, $tmp); }

    // if ($t4) goto L0 else goto L1
    $tmp := $t4;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t14 := 10
    $tmp := $Integer(10);
    $t14 := $tmp;

    // abort($t14)
    if (true) { assume $DebugTrackAbort(29, 24163); }
    goto Abort;

    // L0:
L0:

    // authentication_key := $t43
    call $tmp := $CopyOrMoveValue($t43);
    authentication_key := $tmp;
    if (true) { assume $DebugTrackLocal(29, 24309, 2, $tmp); }

    // $t16 := borrow_local(authentication_key)
    call $t16 := $BorrowLoc(2, authentication_key);
    assume $Vector_is_well_formed($Dereference($t16)) && (forall $$1: int :: {$select_vector($Dereference($t16),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t16)) ==> $IsValidU8($select_vector($Dereference($t16),$$1)));

    // UnpackRef($t16)

    // $t17 := copy($t42)
    call $tmp := $CopyOrMoveValue($t42);
    $t17 := $tmp;

    // $t18 := Signer::borrow_address($t17)
    call $t18 := $Signer_borrow_address($t17);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24430);
      goto Abort;
    }
    assume is#$Address($t18);


    // $t19 := LCS::to_bytes<address>($t18)
    call $t19 := $LCS_to_bytes($AddressType(), $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24413);
      goto Abort;
    }
    assume $Vector_is_well_formed($t19) && (forall $$0: int :: {$select_vector($t19,$$0)} $$0 >= 0 && $$0 < $vlen($t19) ==> $IsValidU8($select_vector($t19,$$0)));


    // PackRef($t16)

    // $t44 := read_ref($t16)
    call $tmp := $ReadRef($t16);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t44 := $tmp;

    // $t44 := Vector::append<u8>($t44, $t19)
    call $t44 := $Vector_append($IntegerType(), $t44, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24363);
      goto Abort;
    }
    assume $Vector_is_well_formed($t44) && (forall $$0: int :: {$select_vector($t44,$$0)} $$0 >= 0 && $$0 < $vlen($t44) ==> $IsValidU8($select_vector($t44,$$0)));


    // write_ref($t16, $t44)
    call $t16 := $WriteRef($t16, $t44);

    // LocalRoot(authentication_key) <- $t16
    call authentication_key := $WritebackToValue($t16, 2, authentication_key);

    // UnpackRef($t16)

    // PackRef($t16)

    // $t20 := copy(authentication_key)
    call $tmp := $CopyOrMoveValue(authentication_key);
    $t20 := $tmp;

    // $t21 := Vector::length<u8>($t20)
    call $t21 := $Vector_length($IntegerType(), $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24494);
      goto Abort;
    }
    assume $IsValidU64($t21);


    // $t22 := 32
    $tmp := $Integer(32);
    $t22 := $tmp;

    // $t23 := ==($t21, $t22)
    $tmp := $Boolean($IsEqual($t21, $t22));
    $t23 := $tmp;

    // $t6 := $t23
    call $tmp := $CopyOrMoveValue($t23);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 24479, 6, $tmp); }

    // if ($t6) goto L2 else goto L3
    $tmp := $t6;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t25 := 8
    $tmp := $Integer(8);
    $t25 := $tmp;

    // abort($t25)
    if (true) { assume $DebugTrackAbort(29, 24479); }
    goto Abort;

    // L2:
L2:

    // $t26 := copy($t42)
    call $tmp := $CopyOrMoveValue($t42);
    $t26 := $tmp;

    // $t29 := pack LibraAccount::WithdrawCapability(new_account_addr)
    call $tmp := $LibraAccount_WithdrawCapability_pack(0, 0, 0, new_account_addr);
    $t29 := $tmp;

    // $t30 := Option::some<LibraAccount::WithdrawCapability>($t29)
    call $t30 := $Option_some($LibraAccount_WithdrawCapability_type_value(), $t29);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24714);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t30);


    // $t32 := pack LibraAccount::KeyRotationCapability(new_account_addr)
    call $tmp := $LibraAccount_KeyRotationCapability_pack(0, 0, 0, new_account_addr);
    $t32 := $tmp;

    // $t33 := Option::some<LibraAccount::KeyRotationCapability>($t32)
    call $t33 := $Option_some($LibraAccount_KeyRotationCapability_type_value(), $t32);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24888);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t33);


    // $t34 := copy($t42)
    call $tmp := $CopyOrMoveValue($t42);
    $t34 := $tmp;

    // $t35 := Event::new_event_handle<LibraAccount::ReceivedPaymentEvent>($t34)
    call $t35 := $Event_new_event_handle($LibraAccount_ReceivedPaymentEvent_type_value(), $t34);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 25056);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t35);


    // $t36 := copy($t42)
    call $tmp := $CopyOrMoveValue($t42);
    $t36 := $tmp;

    // $t37 := Event::new_event_handle<LibraAccount::SentPaymentEvent>($t36)
    call $t37 := $Event_new_event_handle($LibraAccount_SentPaymentEvent_type_value(), $t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 25146);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t37);


    // $t38 := 0
    $tmp := $Integer(0);
    $t38 := $tmp;

    // $t39 := false
    $tmp := $Boolean(false);
    $t39 := $tmp;

    // $t40 := pack LibraAccount::LibraAccount(authentication_key, $t30, $t33, $t35, $t37, $t38, $t39)
    call $tmp := $LibraAccount_LibraAccount_pack(0, 0, 0, authentication_key, $t30, $t33, $t35, $t37, $t38, $t39);
    $t40 := $tmp;

    // move_to<LibraAccount::LibraAccount>($t40, $t26)
    call $MoveTo($LibraAccount_LibraAccount_type_value(), $t40, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 24569);
      goto Abort;
    }

    // LibraAccount::destroy_signer($t42)
    call $LibraAccount_destroy_signer($t42);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32002);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_make_account(new_account: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(new_account);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $LibraAccount_make_account_def(new_account, auth_key_prefix);
}

procedure $LibraAccount_make_account_verify(new_account: $Value, auth_key_prefix: $Value) returns ()
free requires is#$Address(new_account);
free requires $Vector_is_well_formed(auth_key_prefix) && (forall $$0: int :: {$select_vector(auth_key_prefix,$$0)} $$0 >= 0 && $$0 < $vlen(auth_key_prefix) ==> $IsValidU8($select_vector(auth_key_prefix,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_make_account_def(new_account, auth_key_prefix);
}

procedure {:inline 1} $LibraAccount_pay_from_def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value) returns (){
    // declare local variables
    var $t5: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $Vector_type_value($IntegerType())
    var $t13: $Value; // $Libra_Libra_type_value($tv0)
    var $t14: $Value; // $Vector_type_value($IntegerType())
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $Vector_type_value($IntegerType())
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 20396, 0, cap); }
    if (true) { assume $DebugTrackLocal(29, 20396, 1, payee); }
    if (true) { assume $DebugTrackLocal(29, 20396, 2, amount); }
    if (true) { assume $DebugTrackLocal(29, 20396, 3, metadata); }
    if (true) { assume $DebugTrackLocal(29, 20396, 4, metadata_signature); }

    // bytecode translation starts here
    // $t16 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t16 := $tmp;

    // $t17 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t17 := $tmp;

    // $t18 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t18 := $tmp;

    // $t19 := move(metadata)
    call $tmp := $CopyOrMoveValue(metadata);
    $t19 := $tmp;

    // $t20 := move(metadata_signature)
    call $tmp := $CopyOrMoveValue(metadata_signature);
    $t20 := $tmp;

    // $t5 := copy($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t5 := $tmp;

    // $t6 := get_field<LibraAccount::WithdrawCapability>.account_address($t5)
    call $tmp := $GetFieldFromValue($t5, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address($tmp);
    $t6 := $tmp;

    // $t7 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;

    // $t9 := move($t16)
    call $tmp := $CopyOrMoveValue($t16);
    $t9 := $tmp;

    // $t13 := LibraAccount::withdraw_from<#0>($t9, $t17, $t18, $t19)
    call $t13 := $LibraAccount_withdraw_from($tv0, $t9, $t17, $t18, $t19);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17784);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t13);


    // LibraAccount::deposit<#0>($t7, $t17, $t13, $t19, $t20)
    call $LibraAccount_deposit($tv0, $t7, $t17, $t13, $t19, $t20);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_pay_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value) returns ()
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires is#$Address(payee);
free requires $IsValidU64(amount);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {$select_vector(metadata_signature,$$0)} $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature,$$0)));
{
    call $LibraAccount_pay_from_def($tv0, cap, payee, amount, metadata, metadata_signature);
}

procedure $LibraAccount_pay_from_verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value, metadata_signature: $Value) returns ()
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires is#$Address(payee);
free requires $IsValidU64(amount);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
free requires $Vector_is_well_formed(metadata_signature) && (forall $$0: int :: {$select_vector(metadata_signature,$$0)} $$0 >= 0 && $$0 < $vlen(metadata_signature) ==> $IsValidU8($select_vector(metadata_signature,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_pay_from_def($tv0, cap, payee, amount, metadata, metadata_signature);
}

procedure {:inline 1} $LibraAccount_prologue_def($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value) returns (){
    // declare local variables
    var balance_amount: $Value; // $IntegerType()
    var max_transaction_fee: $Value; // $IntegerType()
    var sender_account: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $BooleanType()
    var $t12: $Value; // $IntegerType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $BooleanType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $IntegerType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $IntegerType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $IntegerType()
    var transaction_sender: $Value; // $AddressType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $BooleanType()
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $AddressType()
    var $t31: $Value; // $BooleanType()
    var $t32: $Value; // $BooleanType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $AddressType()
    var $t36: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t37: $Value; // $Vector_type_value($IntegerType())
    var $t38: $Value; // $Vector_type_value($IntegerType())
    var $t39: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t40: $Value; // $Vector_type_value($IntegerType())
    var $t41: $Value; // $Vector_type_value($IntegerType())
    var $t42: $Value; // $BooleanType()
    var $t43: $Value; // $BooleanType()
    var $t44: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t45: $Value; // $IntegerType()
    var $t46: $Value; // $IntegerType()
    var $t47: $Value; // $IntegerType()
    var $t48: $Value; // $IntegerType()
    var $t49: $Value; // $IntegerType()
    var $t50: $Value; // $IntegerType()
    var $t51: $Value; // $BooleanType()
    var $t52: $Value; // $AddressType()
    var $t53: $Value; // $IntegerType()
    var $t54: $Value; // $IntegerType()
    var $t55: $Value; // $IntegerType()
    var $t56: $Value; // $BooleanType()
    var $t57: $Value; // $BooleanType()
    var $t58: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t59: $Value; // $IntegerType()
    var $t60: $Value; // $IntegerType()
    var $t61: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t62: $Value; // $IntegerType()
    var $t63: $Value; // $IntegerType()
    var $t64: $Value; // $BooleanType()
    var $t65: $Value; // $BooleanType()
    var $t66: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t67: $Value; // $IntegerType()
    var $t68: $Value; // $IntegerType()
    var $t69: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t70: $Value; // $IntegerType()
    var $t71: $Value; // $IntegerType()
    var $t72: $Value; // $BooleanType()
    var $t73: $Value; // $BooleanType()
    var $t74: $Value; // $IntegerType()
    var $t75: $Value; // $IntegerType()
    var $t76: $Value; // $BooleanType()
    var $t77: $Value; // $BooleanType()
    var $t78: $Value; // $IntegerType()
    var $t79: $Value; // $AddressType()
    var $t80: $Value; // $IntegerType()
    var $t81: $Value; // $Vector_type_value($IntegerType())
    var $t82: $Value; // $IntegerType()
    var $t83: $Value; // $IntegerType()
    var $t84: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 37445, 0, sender); }
    if (true) { assume $DebugTrackLocal(29, 37445, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(29, 37445, 2, txn_public_key); }
    if (true) { assume $DebugTrackLocal(29, 37445, 3, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(29, 37445, 4, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(29, 37445, 5, txn_expiration_time); }

    // bytecode translation starts here
    // $t79 := move(sender)
    call $tmp := $CopyOrMoveValue(sender);
    $t79 := $tmp;

    // $t80 := move(txn_sequence_number)
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t80 := $tmp;

    // $t81 := move(txn_public_key)
    call $tmp := $CopyOrMoveValue(txn_public_key);
    $t81 := $tmp;

    // $t82 := move(txn_gas_price)
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t82 := $tmp;

    // $t83 := move(txn_max_gas_units)
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t83 := $tmp;

    // $t84 := move(txn_expiration_time)
    call $tmp := $CopyOrMoveValue(txn_expiration_time);
    $t84 := $tmp;

    // $t24 := move($t79)
    call $tmp := $CopyOrMoveValue($t79);
    $t24 := $tmp;

    // $t25 := Signer::address_of($t24)
    call $t25 := $Signer_address_of($t24);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 37735);
      goto Abort;
    }
    assume is#$Address($t25);


    // transaction_sender := $t25
    call $tmp := $CopyOrMoveValue($t25);
    transaction_sender := $tmp;
    if (true) { assume $DebugTrackLocal(29, 37706, 23, $tmp); }

    // $t27 := LibraAccount::exists_at(transaction_sender)
    call $t27 := $LibraAccount_exists_at(transaction_sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 34677);
      goto Abort;
    }
    assume is#$Boolean($t27);


    // $t9 := $t27
    call $tmp := $CopyOrMoveValue($t27);
    $t9 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 37880, 9, $tmp); }

    // if ($t9) goto L0 else goto L1
    $tmp := $t9;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t29 := 4
    $tmp := $Integer(4);
    $t29 := $tmp;

    // abort($t29)
    if (true) { assume $DebugTrackAbort(29, 37880); }
    goto Abort;

    // L0:
L0:

    // $t31 := LibraAccount::account_is_frozen(transaction_sender)
    call $t31 := $LibraAccount_account_is_frozen(transaction_sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 37007);
      goto Abort;
    }
    assume is#$Boolean($t31);


    // $t32 := !($t31)
    call $tmp := $Not($t31);
    $t32 := $tmp;

    // $t11 := $t32
    call $tmp := $CopyOrMoveValue($t32);
    $t11 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 37951, 11, $tmp); }

    // if ($t11) goto L2 else goto L3
    $tmp := $t11;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t34 := 0
    $tmp := $Integer(0);
    $t34 := $tmp;

    // abort($t34)
    if (true) { assume $DebugTrackAbort(29, 37951); }
    goto Abort;

    // L2:
L2:

    // $t36 := borrow_global<LibraAccount::LibraAccount>(transaction_sender)
    call $t36 := $BorrowGlobal(transaction_sender, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 38104);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t36));

    // UnpackRef($t36)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t36));

    // sender_account := $t36
    call sender_account := $CopyOrMoveRef($t36);
    if (true) { assume $DebugTrackLocal(29, 38087, 8, $Dereference(sender_account)); }

    // $t38 := Hash::sha3_256($t81)
    call $t38 := $Hash_sha3_256($t81);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 38286);
      goto Abort;
    }
    assume $Vector_is_well_formed($t38) && (forall $$0: int :: {$select_vector($t38,$$0)} $$0 >= 0 && $$0 < $vlen($t38) ==> $IsValidU8($select_vector($t38,$$0)));


    // $t39 := copy(sender_account)
    call $t39 := $CopyOrMoveRef(sender_account);

    // $t40 := get_field<LibraAccount::LibraAccount>.authentication_key($t39)
    call $tmp := $GetFieldFromReference($t39, $LibraAccount_LibraAccount_authentication_key);
    assume $Vector_is_well_formed($tmp) && (forall $$0: int :: {$select_vector($tmp,$$0)} $$0 >= 0 && $$0 < $vlen($tmp) ==> $IsValidU8($select_vector($tmp,$$0)));
    $t40 := $tmp;

    // Reference(sender_account) <- $t39
    call sender_account := $WritebackToReference($t39, sender_account);

    // $t41 := move($t40)
    call $tmp := $CopyOrMoveValue($t40);
    $t41 := $tmp;

    // $t42 := ==($t38, $t41)
    $tmp := $Boolean($IsEqual($t38, $t41));
    $t42 := $tmp;

    // $t13 := $t42
    call $tmp := $CopyOrMoveValue($t42);
    $t13 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 38260, 13, $tmp); }

    // if ($t13) goto L4 else goto L5
    $tmp := $t13;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t44 := move(sender_account)
    call $t44 := $CopyOrMoveRef(sender_account);

    // destroy($t44)

    // LibraAccount::LibraAccount <- $t44
    call $WritebackToGlobal($t44);

    // PackRef($t44)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t44));

    // $t45 := 1
    $tmp := $Integer(1);
    $t45 := $tmp;

    // abort($t45)
    if (true) { assume $DebugTrackAbort(29, 38260); }
    goto Abort;

    // L4:
L4:

    // $t48 := *($t82, $t83)
    call $tmp := $MulU64($t82, $t83);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 38530);
      goto Abort;
    }
    $t48 := $tmp;

    // max_transaction_fee := $t48
    call $tmp := $CopyOrMoveValue($t48);
    max_transaction_fee := $tmp;
    if (true) { assume $DebugTrackLocal(29, 38494, 7, $tmp); }

    // $t50 := 0
    $tmp := $Integer(0);
    $t50 := $tmp;

    // $t51 := >(max_transaction_fee, $t50)
    call $tmp := $Gt(max_transaction_fee, $t50);
    $t51 := $tmp;

    // if ($t51) goto L6 else goto L7
    $tmp := $t51;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t53 := LibraAccount::balance<#0>(transaction_sender)
    call $t53 := $LibraAccount_balance($tv0, transaction_sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32288);
      goto Abort;
    }
    assume $IsValidU64($t53);


    // balance_amount := $t53
    call $tmp := $CopyOrMoveValue($t53);
    balance_amount := $tmp;
    if (true) { assume $DebugTrackLocal(29, 38671, 6, $tmp); }

    // $t56 := >=(balance_amount, max_transaction_fee)
    call $tmp := $Ge(balance_amount, max_transaction_fee);
    $t56 := $tmp;

    // $t15 := $t56
    call $tmp := $CopyOrMoveValue($t56);
    $t15 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 38736, 15, $tmp); }

    // if ($t15) goto L8 else goto L9
    $tmp := $t15;
    if (b#$Boolean($tmp)) { goto L8; } else { goto L9; }

    // L9:
L9:

    // $t58 := move(sender_account)
    call $t58 := $CopyOrMoveRef(sender_account);

    // destroy($t58)

    // LibraAccount::LibraAccount <- $t58
    call $WritebackToGlobal($t58);

    // PackRef($t58)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t58));

    // $t59 := 5
    $tmp := $Integer(5);
    $t59 := $tmp;

    // abort($t59)
    if (true) { assume $DebugTrackAbort(29, 38736); }
    goto Abort;

    // L8:
L8:

    // $t61 := copy(sender_account)
    call $t61 := $CopyOrMoveRef(sender_account);

    // $t62 := get_field<LibraAccount::LibraAccount>.sequence_number($t61)
    call $tmp := $GetFieldFromReference($t61, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64($tmp);
    $t62 := $tmp;

    // Reference(sender_account) <- $t61
    call sender_account := $WritebackToReference($t61, sender_account);

    // $t63 := move($t62)
    call $tmp := $CopyOrMoveValue($t62);
    $t63 := $tmp;

    // $t64 := >=($t80, $t63)
    call $tmp := $Ge($t80, $t63);
    $t64 := $tmp;

    // $t17 := $t64
    call $tmp := $CopyOrMoveValue($t64);
    $t17 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 38932, 17, $tmp); }

    // if ($t17) goto L10 else goto L11
    $tmp := $t17;
    if (b#$Boolean($tmp)) { goto L10; } else { goto L11; }

    // L11:
L11:

    // $t66 := move(sender_account)
    call $t66 := $CopyOrMoveRef(sender_account);

    // destroy($t66)

    // LibraAccount::LibraAccount <- $t66
    call $WritebackToGlobal($t66);

    // PackRef($t66)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t66));

    // $t67 := 2
    $tmp := $Integer(2);
    $t67 := $tmp;

    // abort($t67)
    if (true) { assume $DebugTrackAbort(29, 38932); }
    goto Abort;

    // L10:
L10:

    // $t69 := move(sender_account)
    call $t69 := $CopyOrMoveRef(sender_account);

    // $t70 := get_field<LibraAccount::LibraAccount>.sequence_number($t69)
    call $tmp := $GetFieldFromReference($t69, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64($tmp);
    $t70 := $tmp;

    // LibraAccount::LibraAccount <- $t69
    call $WritebackToGlobal($t69);

    // PackRef($t69)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t69));

    // $t71 := move($t70)
    call $tmp := $CopyOrMoveValue($t70);
    $t71 := $tmp;

    // $t72 := ==($t80, $t71)
    $tmp := $Boolean($IsEqual($t80, $t71));
    $t72 := $tmp;

    // $t19 := $t72
    call $tmp := $CopyOrMoveValue($t72);
    $t19 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 39038, 19, $tmp); }

    // if ($t19) goto L12 else goto L13
    $tmp := $t19;
    if (b#$Boolean($tmp)) { goto L12; } else { goto L13; }

    // L13:
L13:

    // $t74 := 3
    $tmp := $Integer(3);
    $t74 := $tmp;

    // abort($t74)
    if (true) { assume $DebugTrackAbort(29, 39038); }
    goto Abort;

    // L12:
L12:

    // $t76 := LibraTransactionTimeout::is_valid_transaction_timestamp($t84)
    call $t76 := $LibraTransactionTimeout_is_valid_transaction_timestamp($t84);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 39176);
      goto Abort;
    }
    assume is#$Boolean($t76);


    // $t21 := $t76
    call $tmp := $CopyOrMoveValue($t76);
    $t21 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 39144, 21, $tmp); }

    // if ($t21) goto L14 else goto L15
    $tmp := $t21;
    if (b#$Boolean($tmp)) { goto L14; } else { goto L15; }

    // L15:
L15:

    // $t78 := 6
    $tmp := $Integer(6);
    $t78 := $tmp;

    // abort($t78)
    if (true) { assume $DebugTrackAbort(29, 39144); }
    goto Abort;

    // L14:
L14:

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_prologue($tv0: $TypeValue, sender: $Value, txn_sequence_number: $Value, txn_public_key: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, txn_expiration_time: $Value) returns ()
free requires is#$Address(sender);
free requires $IsValidU64(txn_sequence_number);
free requires $Vector_is_well_formed(txn_public_key) && (forall $$0: int :: {$select_vector(txn_public_key,$$0)} $$0 >= 0 && $$0 < $vlen(txn_public_key) ==> $IsValidU8($select_vector(txn_public_key,$$0)));
free requires $IsValidU64(txn_gas_price);
free requires $IsValidU64(txn_max_gas_units);
free requires $IsValidU64(txn_expiration_time);
{
    call $LibraAccount_prologue_def($tv0, sender, txn_sequence_number, txn_public_key, txn_gas_price, txn_max_gas_units, txn_expiration_time);
}

procedure {:inline 1} $LibraAccount_restore_key_rotation_capability_def(cap: $Value) returns (){
    // declare local variables
    var account: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t2: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t6: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t7: $Reference; // ReferenceType($Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value()))
    var $t8: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t9: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t10: $Value; // $Option_Option_type_value($LibraAccount_KeyRotationCapability_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 22336, 0, cap); }

    // bytecode translation starts here
    // $t9 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;

    // $t2 := copy($t9)
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;

    // $t3 := get_field<LibraAccount::KeyRotationCapability>.account_address($t2)
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_KeyRotationCapability_account_address);
    assume is#$Address($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // $t5 := borrow_global<LibraAccount::LibraAccount>($t4)
    call $t5 := $BorrowGlobal($t4, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22457);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t5));

    // UnpackRef($t5)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t5));

    // account := $t5
    call account := $CopyOrMoveRef($t5);
    if (true) { assume $DebugTrackLocal(29, 22447, 1, $Dereference(account)); }

    // $t6 := move(account)
    call $t6 := $CopyOrMoveRef(account);

    // $t7 := borrow_field<LibraAccount::LibraAccount>.key_rotation_capability($t6)
    call $t7 := $BorrowField($t6, $LibraAccount_LibraAccount_key_rotation_capability);
    assume $Option_Option_is_well_formed_types($Dereference($t7));

    // LibraAccount::LibraAccount <- $t6
    call $WritebackToGlobal($t6);

    // UnpackRef($t7)
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));

    // PackRef($t7)
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));

    // $t10 := read_ref($t7)
    call $tmp := $ReadRef($t7);
    assume $Option_Option_is_well_formed($tmp);
    $t10 := $tmp;

    // $t10 := Option::fill<LibraAccount::KeyRotationCapability>($t10, $t9)
    call $t10 := $Option_fill($LibraAccount_KeyRotationCapability_type_value(), $t10, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 22527);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t10);


    // write_ref($t7, $t10)
    call $t7 := $WriteRef($t7, $t10);
    if (true) { assume $DebugTrackLocal(29, 22336, 1, $Dereference(account)); }

    // LibraAccount::LibraAccount <- $t7
    call $WritebackToGlobal($t7);

    // Reference($t6) <- $t7
    call $t6 := $WritebackToReference($t7, $t6);

    // UnpackRef($t7)
    call $Option_Option_before_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));

    // PackRef($t6)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t6));

    // PackRef($t7)
    call $Option_Option_after_update_inv($LibraAccount_KeyRotationCapability_type_value(), $Dereference($t7));

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_restore_key_rotation_capability(cap: $Value) returns ()
free requires $LibraAccount_KeyRotationCapability_is_well_formed(cap);
{
    call $LibraAccount_restore_key_rotation_capability_def(cap);
}

procedure $LibraAccount_restore_key_rotation_capability_verify(cap: $Value) returns ()
free requires $LibraAccount_KeyRotationCapability_is_well_formed(cap);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_restore_key_rotation_capability_def(cap);
}

procedure {:inline 1} $LibraAccount_restore_withdraw_capability_def(cap: $Value) returns (){
    // declare local variables
    var account: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t2: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t3: $Value; // $AddressType()
    var $t4: $Value; // $AddressType()
    var $t5: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t6: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t7: $Reference; // ReferenceType($Option_Option_type_value($LibraAccount_WithdrawCapability_type_value()))
    var $t8: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t9: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t10: $Value; // $Option_Option_type_value($LibraAccount_WithdrawCapability_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 19786, 0, cap); }

    // bytecode translation starts here
    // $t9 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t9 := $tmp;

    // $t2 := copy($t9)
    call $tmp := $CopyOrMoveValue($t9);
    $t2 := $tmp;

    // $t3 := get_field<LibraAccount::WithdrawCapability>.account_address($t2)
    call $tmp := $GetFieldFromValue($t2, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address($tmp);
    $t3 := $tmp;

    // $t4 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;

    // $t5 := borrow_global<LibraAccount::LibraAccount>($t4)
    call $t5 := $BorrowGlobal($t4, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 19900);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t5));

    // UnpackRef($t5)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t5));

    // account := $t5
    call account := $CopyOrMoveRef($t5);
    if (true) { assume $DebugTrackLocal(29, 19890, 1, $Dereference(account)); }

    // $t6 := move(account)
    call $t6 := $CopyOrMoveRef(account);

    // $t7 := borrow_field<LibraAccount::LibraAccount>.withdrawal_capability($t6)
    call $t7 := $BorrowField($t6, $LibraAccount_LibraAccount_withdrawal_capability);
    assume $Option_Option_is_well_formed_types($Dereference($t7));

    // LibraAccount::LibraAccount <- $t6
    call $WritebackToGlobal($t6);

    // UnpackRef($t7)
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));

    // PackRef($t7)
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));

    // $t10 := read_ref($t7)
    call $tmp := $ReadRef($t7);
    assume $Option_Option_is_well_formed($tmp);
    $t10 := $tmp;

    // $t10 := Option::fill<LibraAccount::WithdrawCapability>($t10, $t9)
    call $t10 := $Option_fill($LibraAccount_WithdrawCapability_type_value(), $t10, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 19970);
      goto Abort;
    }
    assume $Option_Option_is_well_formed($t10);


    // write_ref($t7, $t10)
    call $t7 := $WriteRef($t7, $t10);
    if (true) { assume $DebugTrackLocal(29, 19786, 1, $Dereference(account)); }

    // LibraAccount::LibraAccount <- $t7
    call $WritebackToGlobal($t7);

    // Reference($t6) <- $t7
    call $t6 := $WritebackToReference($t7, $t6);

    // UnpackRef($t7)
    call $Option_Option_before_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));

    // PackRef($t6)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t6));

    // PackRef($t7)
    call $Option_Option_after_update_inv($LibraAccount_WithdrawCapability_type_value(), $Dereference($t7));

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_restore_withdraw_capability(cap: $Value) returns ()
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
{
    call $LibraAccount_restore_withdraw_capability_def(cap);
}

procedure $LibraAccount_restore_withdraw_capability_verify(cap: $Value) returns ()
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_restore_withdraw_capability_def(cap);
}

procedure {:inline 1} $LibraAccount_rotate_authentication_key_def(cap: $Value, new_authentication_key: $Value) returns (){
    // declare local variables
    var sender_account_resource: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t6: $Value; // $AddressType()
    var $t7: $Value; // $AddressType()
    var $t8: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t9: $Value; // $Vector_type_value($IntegerType())
    var $t10: $Value; // $IntegerType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $Vector_type_value($IntegerType())
    var $t17: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t18: $Reference; // ReferenceType($Vector_type_value($IntegerType()))
    var $t19: $Value; // $LibraAccount_KeyRotationCapability_type_value()
    var $t20: $Value; // $Vector_type_value($IntegerType())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 20995, 0, cap); }
    if (true) { assume $DebugTrackLocal(29, 20995, 1, new_authentication_key); }

    // bytecode translation starts here
    // $t19 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t19 := $tmp;

    // $t20 := move(new_authentication_key)
    call $tmp := $CopyOrMoveValue(new_authentication_key);
    $t20 := $tmp;

    // $t5 := move($t19)
    call $tmp := $CopyOrMoveValue($t19);
    $t5 := $tmp;

    // $t6 := get_field<LibraAccount::KeyRotationCapability>.account_address($t5)
    call $tmp := $GetFieldFromValue($t5, $LibraAccount_KeyRotationCapability_account_address);
    assume is#$Address($tmp);
    $t6 := $tmp;

    // $t7 := move($t6)
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;

    // $t8 := borrow_global<LibraAccount::LibraAccount>($t7)
    call $t8 := $BorrowGlobal($t7, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 21183);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t8));

    // UnpackRef($t8)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t8));

    // sender_account_resource := $t8
    call sender_account_resource := $CopyOrMoveRef($t8);
    if (true) { assume $DebugTrackLocal(29, 21157, 2, $Dereference(sender_account_resource)); }

    // $t9 := copy($t20)
    call $tmp := $CopyOrMoveValue($t20);
    $t9 := $tmp;

    // $t10 := Vector::length<u8>($t9)
    call $t10 := $Vector_length($IntegerType(), $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 21315);
      goto Abort;
    }
    assume $IsValidU64($t10);


    // $t11 := 32
    $tmp := $Integer(32);
    $t11 := $tmp;

    // $t12 := ==($t10, $t11)
    $tmp := $Boolean($IsEqual($t10, $t11));
    $t12 := $tmp;

    // $t3 := $t12
    call $tmp := $CopyOrMoveValue($t12);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 21300, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t14 := move(sender_account_resource)
    call $t14 := $CopyOrMoveRef(sender_account_resource);

    // destroy($t14)

    // LibraAccount::LibraAccount <- $t14
    call $WritebackToGlobal($t14);

    // PackRef($t14)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));

    // $t15 := 8
    $tmp := $Integer(8);
    $t15 := $tmp;

    // abort($t15)
    if (true) { assume $DebugTrackAbort(29, 21300); }
    goto Abort;

    // L0:
L0:

    // $t17 := move(sender_account_resource)
    call $t17 := $CopyOrMoveRef(sender_account_resource);

    // $t18 := borrow_field<LibraAccount::LibraAccount>.authentication_key($t17)
    call $t18 := $BorrowField($t17, $LibraAccount_LibraAccount_authentication_key);
    assume $Vector_is_well_formed($Dereference($t18)) && (forall $$1: int :: {$select_vector($Dereference($t18),$$1)} $$1 >= 0 && $$1 < $vlen($Dereference($t18)) ==> $IsValidU8($select_vector($Dereference($t18),$$1)));

    // LibraAccount::LibraAccount <- $t17
    call $WritebackToGlobal($t17);

    // UnpackRef($t18)

    // write_ref($t18, $t20)
    call $t18 := $WriteRef($t18, $t20);
    if (true) { assume $DebugTrackLocal(29, 21394, 2, $Dereference(sender_account_resource)); }

    // LibraAccount::LibraAccount <- $t18
    call $WritebackToGlobal($t18);

    // Reference($t17) <- $t18
    call $t17 := $WritebackToReference($t18, $t17);

    // PackRef($t17)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t17));

    // PackRef($t18)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_rotate_authentication_key(cap: $Value, new_authentication_key: $Value) returns ()
free requires $LibraAccount_KeyRotationCapability_is_well_formed(cap);
free requires $Vector_is_well_formed(new_authentication_key) && (forall $$0: int :: {$select_vector(new_authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key,$$0)));
{
    call $LibraAccount_rotate_authentication_key_def(cap, new_authentication_key);
}

procedure $LibraAccount_rotate_authentication_key_verify(cap: $Value, new_authentication_key: $Value) returns ()
free requires $LibraAccount_KeyRotationCapability_is_well_formed(cap);
free requires $Vector_is_well_formed(new_authentication_key) && (forall $$0: int :: {$select_vector(new_authentication_key,$$0)} $$0 >= 0 && $$0 < $vlen(new_authentication_key) ==> $IsValidU8($select_vector(new_authentication_key,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_rotate_authentication_key_def(cap, new_authentication_key);
}

procedure {:inline 1} $LibraAccount_sequence_number_def(addr: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $AddressType()
    var $t2: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $AddressType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 33288, 0, addr); }

    // bytecode translation starts here
    // $t4 := move(addr)
    call $tmp := $CopyOrMoveValue(addr);
    $t4 := $tmp;

    // $t2 := get_global<LibraAccount::LibraAccount>($t4)
    call $tmp := $GetGlobal($t4, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 33395);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($tmp);
    $t2 := $tmp;

    // $t3 := LibraAccount::sequence_number_for_account($t2)
    call $t3 := $LibraAccount_sequence_number_for_account($t2);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 33133);
      goto Abort;
    }
    assume $IsValidU64($t3);


    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(29, 33367, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_sequence_number(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $ret0 := $LibraAccount_sequence_number_def(addr);
}

procedure $LibraAccount_sequence_number_verify(addr: $Value) returns ($ret0: $Value)
free requires is#$Address(addr);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_sequence_number_def(addr);
}

procedure {:inline 1} $LibraAccount_sequence_number_for_account_def(account: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $LibraAccount_LibraAccount_type_value()
    var $t2: $Value; // $IntegerType()
    var $t3: $Value; // $IntegerType()
    var $t4: $Value; // $LibraAccount_LibraAccount_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 33129, 0, account); }

    // bytecode translation starts here
    // $t4 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t4 := $tmp;

    // $t1 := move($t4)
    call $tmp := $CopyOrMoveValue($t4);
    $t1 := $tmp;

    // $t2 := get_field<LibraAccount::LibraAccount>.sequence_number($t1)
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_LibraAccount_sequence_number);
    assume $IsValidU64($tmp);
    $t2 := $tmp;

    // $t3 := move($t2)
    call $tmp := $CopyOrMoveValue($t2);
    $t3 := $tmp;

    // return $t3
    $ret0 := $t3;
    if (true) { assume $DebugTrackLocal(29, 33200, 5, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_sequence_number_for_account(account: $Value) returns ($ret0: $Value)
free requires $LibraAccount_LibraAccount_is_well_formed(account);
{
    call $ret0 := $LibraAccount_sequence_number_for_account_def(account);
}

procedure $LibraAccount_sequence_number_for_account_verify(account: $Value) returns ($ret0: $Value)
free requires $LibraAccount_LibraAccount_is_well_formed(account);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_sequence_number_for_account_def(account);
}

procedure {:inline 1} $LibraAccount_should_track_limits_for_account_def(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $AddressType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $BooleanType()
    var $t14: $Value; // $BooleanType()
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $BooleanType()
    var $t21: $Value; // $BooleanType()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $BooleanType()
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $BooleanType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $AddressType()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $BooleanType()
    var $t31: $Value; // $BooleanType()
    var $t32: $Value; // $BooleanType()
    var $t33: $Value; // $BooleanType()
    var $t34: $Value; // $BooleanType()
    var $t35: $Value; // $BooleanType()
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $AddressType()
    var $t38: $Value; // $BooleanType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 7853, 0, payer); }
    if (true) { assume $DebugTrackLocal(29, 7853, 1, payee); }
    if (true) { assume $DebugTrackLocal(29, 7853, 2, is_withdrawal); }

    // bytecode translation starts here
    // $t36 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t36 := $tmp;

    // $t37 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t37 := $tmp;

    // $t38 := move(is_withdrawal)
    call $tmp := $CopyOrMoveValue(is_withdrawal);
    $t38 := $tmp;

    // if ($t38) goto L0 else goto L1
    $tmp := $t38;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t10 := VASP::is_vasp($t36)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t10 := $VASP_is_vasp($t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7997);
      goto Abort;
    }
    assume is#$Boolean($t10);


    // if ($t10) goto L3 else goto L4
    $tmp := $t10;
    if (b#$Boolean($tmp)) { goto L3; } else { goto L4; }

    // L4:
L4:

    // goto L5
    goto L5;

    // L3:
L3:

    // $t12 := VASP::is_vasp($t37)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t12 := $VASP_is_vasp($t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 8023);
      goto Abort;
    }
    assume is#$Boolean($t12);


    // $t13 := !($t12)
    call $tmp := $Not($t12);
    $t13 := $tmp;

    // if ($t13) goto L6 else goto L7
    $tmp := $t13;
    if (b#$Boolean($tmp)) { goto L6; } else { goto L7; }

    // L7:
L7:

    // goto L8
    goto L8;

    // L6:
L6:

    // $t14 := true
    $tmp := $Boolean(true);
    $t14 := $tmp;

    // $t3 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 8015, 3, $tmp); }

    // goto L9
    goto L9;

    // L8:
L8:

    // $t17 := VASP::is_same_vasp($t36, $t37)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t17 := $VASP_is_same_vasp($t36, $t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 8048);
      goto Abort;
    }
    assume is#$Boolean($t17);


    // $t18 := !($t17)
    call $tmp := $Not($t17);
    $t18 := $tmp;

    // $t3 := $t18
    call $tmp := $CopyOrMoveValue($t18);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 8015, 3, $tmp); }

    // goto L9
    goto L9;

    // L9:
L9:

    // $t4 := $t3
    call $tmp := $CopyOrMoveValue($t3);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 7991, 4, $tmp); }

    // goto L10
    goto L10;

    // L5:
L5:

    // $t20 := false
    $tmp := $Boolean(false);
    $t20 := $tmp;

    // $t4 := $t20
    call $tmp := $CopyOrMoveValue($t20);
    $t4 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 7991, 4, $tmp); }

    // goto L10
    goto L10;

    // L10:
L10:

    // $t7 := $t4
    call $tmp := $CopyOrMoveValue($t4);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 7958, 7, $tmp); }

    // goto L11
    goto L11;

    // L2:
L2:

    // $t23 := VASP::is_vasp($t37)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t23 := $VASP_is_vasp($t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 8111);
      goto Abort;
    }
    assume is#$Boolean($t23);


    // if ($t23) goto L12 else goto L13
    $tmp := $t23;
    if (b#$Boolean($tmp)) { goto L12; } else { goto L13; }

    // L13:
L13:

    // goto L14
    goto L14;

    // L12:
L12:

    // $t25 := VASP::is_vasp($t37)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t25 := $VASP_is_vasp($t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 8137);
      goto Abort;
    }
    assume is#$Boolean($t25);


    // $t26 := !($t25)
    call $tmp := $Not($t25);
    $t26 := $tmp;

    // if ($t26) goto L15 else goto L16
    $tmp := $t26;
    if (b#$Boolean($tmp)) { goto L15; } else { goto L16; }

    // L16:
L16:

    // goto L17
    goto L17;

    // L15:
L15:

    // $t27 := true
    $tmp := $Boolean(true);
    $t27 := $tmp;

    // $t5 := $t27
    call $tmp := $CopyOrMoveValue($t27);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 8129, 5, $tmp); }

    // goto L18
    goto L18;

    // L17:
L17:

    // $t30 := VASP::is_same_vasp($t36, $t37)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t30 := $VASP_is_same_vasp($t36, $t37);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 8162);
      goto Abort;
    }
    assume is#$Boolean($t30);


    // $t31 := !($t30)
    call $tmp := $Not($t30);
    $t31 := $tmp;

    // $t5 := $t31
    call $tmp := $CopyOrMoveValue($t31);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 8129, 5, $tmp); }

    // goto L18
    goto L18;

    // L18:
L18:

    // $t6 := $t5
    call $tmp := $CopyOrMoveValue($t5);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 8105, 6, $tmp); }

    // goto L19
    goto L19;

    // L14:
L14:

    // $t33 := false
    $tmp := $Boolean(false);
    $t33 := $tmp;

    // $t6 := $t33
    call $tmp := $CopyOrMoveValue($t33);
    $t6 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 8105, 6, $tmp); }

    // goto L19
    goto L19;

    // L19:
L19:

    // $t7 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 7958, 7, $tmp); }

    // goto L11
    goto L11;

    // L11:
L11:

    // return $t7
    $ret0 := $t7;
    if (true) { assume $DebugTrackLocal(29, 7958, 39, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_should_track_limits_for_account(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value);
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires is#$Boolean(is_withdrawal);
free ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($m, $txn, payer, payee, is_withdrawal)))));
procedure $LibraAccount_should_track_limits_for_account_verify(payer: $Value, payee: $Value, is_withdrawal: $Value) returns ($ret0: $Value)
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires is#$Boolean(is_withdrawal);
ensures !$abort_flag ==> (b#$Boolean($Boolean($IsEqual($ret0, $LibraAccount_spec_should_track_limits_for_account($m, $txn, payer, payee, is_withdrawal)))));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_should_track_limits_for_account_def(payer, payee, is_withdrawal);
}

procedure {:inline 1} $LibraAccount_staple_lbr_def(cap: $Value, amount_lbr: $Value) returns (){
    // declare local variables
    var cap_address: $Value; // $AddressType()
    var coin1: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var coin1#1515: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var coin1_balance: $Value; // $IntegerType()
    var coin2: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var coin2#1516: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var coin2_balance: $Value; // $IntegerType()
    var lbr: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var payee_address: $Value; // $AddressType()
    var $t11: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $Vector_type_value($IntegerType())
    var $t23: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t24: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t29: $Value; // $IntegerType()
    var $t30: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t31: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t32: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t33: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t34: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t35: $Value; // $AddressType()
    var $t36: $Value; // $AddressType()
    var $t37: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t38: $Value; // $Vector_type_value($IntegerType())
    var $t39: $Value; // $Vector_type_value($IntegerType())
    var $t40: $Value; // $AddressType()
    var $t41: $Value; // $AddressType()
    var $t42: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t43: $Value; // $Vector_type_value($IntegerType())
    var $t44: $Value; // $Vector_type_value($IntegerType())
    var $t45: $Value; // $AddressType()
    var $t46: $Value; // $AddressType()
    var $t47: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t48: $Value; // $Vector_type_value($IntegerType())
    var $t49: $Value; // $Vector_type_value($IntegerType())
    var $t50: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t51: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 9293, 0, cap); }
    if (true) { assume $DebugTrackLocal(29, 9293, 1, amount_lbr); }

    // bytecode translation starts here
    // $t50 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t50 := $tmp;

    // $t51 := move(amount_lbr)
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t51 := $tmp;

    // $t11 := copy($t50)
    call $tmp := $CopyOrMoveValue($t50);
    $t11 := $tmp;

    // $t12 := get_field<LibraAccount::WithdrawCapability>.account_address($t11)
    call $tmp := $GetFieldFromValue($t11, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address($tmp);
    $t12 := $tmp;

    // $t13 := move($t12)
    call $tmp := $CopyOrMoveValue($t12);
    $t13 := $tmp;

    // cap_address := $t13
    call $tmp := $CopyOrMoveValue($t13);
    cap_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9436, 2, $tmp); }

    // $t15 := LibraAccount::balance<Coin1::Coin1>(cap_address)
    call $t15 := $LibraAccount_balance($Coin1_Coin1_type_value(), cap_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32288);
      goto Abort;
    }
    assume $IsValidU64($t15);


    // coin1_balance := $t15
    call $tmp := $CopyOrMoveValue($t15);
    coin1_balance := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9523, 5, $tmp); }

    // $t17 := LibraAccount::balance<Coin2::Coin2>(cap_address)
    call $t17 := $LibraAccount_balance($Coin2_Coin2_type_value(), cap_address);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32288);
      goto Abort;
    }
    assume $IsValidU64($t17);


    // coin2_balance := $t17
    call $tmp := $CopyOrMoveValue($t17);
    coin2_balance := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9580, 8, $tmp); }

    // $t18 := LBR::reserve_address()
    call $t18 := $LBR_reserve_address();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 9716);
      goto Abort;
    }
    assume is#$Address($t18);


    // payee_address := $t18
    call $tmp := $CopyOrMoveValue($t18);
    payee_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9695, 10, $tmp); }

    // $t19 := copy($t50)
    call $tmp := $CopyOrMoveValue($t50);
    $t19 := $tmp;

    // $t22 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t22 := $tmp;

    // $t23 := LibraAccount::withdraw_from<Coin1::Coin1>($t19, payee_address, coin1_balance, $t22)
    call $t23 := $LibraAccount_withdraw_from($Coin1_Coin1_type_value(), $t19, payee_address, coin1_balance, $t22);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17784);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t23);


    // coin1 := $t23
    call $tmp := $CopyOrMoveValue($t23);
    coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9747, 3, $tmp); }

    // $t24 := move($t50)
    call $tmp := $CopyOrMoveValue($t50);
    $t24 := $tmp;

    // $t27 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t27 := $tmp;

    // $t28 := LibraAccount::withdraw_from<Coin2::Coin2>($t24, payee_address, coin2_balance, $t27)
    call $t28 := $LibraAccount_withdraw_from($Coin2_Coin2_type_value(), $t24, payee_address, coin2_balance, $t27);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17784);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t28);


    // coin2 := $t28
    call $tmp := $CopyOrMoveValue($t28);
    coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9829, 6, $tmp); }

    // ($t32, $t33, $t34) := LBR::create($t51, coin1, coin2)
    call $t32, $t33, $t34 := $LBR_create($t51, coin1, coin2);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 9973);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t32);

    assume $Libra_Libra_is_well_formed($t33);

    assume $Libra_Libra_is_well_formed($t34);


    // coin2#1516 := $t34
    call $tmp := $CopyOrMoveValue($t34);
    coin2#1516 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9959, 7, $tmp); }

    // coin1#1515 := $t33
    call $tmp := $CopyOrMoveValue($t33);
    coin1#1515 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9952, 4, $tmp); }

    // lbr := $t32
    call $tmp := $CopyOrMoveValue($t32);
    lbr := $tmp;
    if (true) { assume $DebugTrackLocal(29, 9947, 9, $tmp); }

    // $t35 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t35 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 10174);
      goto Abort;
    }
    assume is#$Address($t35);


    // $t38 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t38 := $tmp;

    // $t39 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t39 := $tmp;

    // LibraAccount::deposit<LBR::LBR>($t35, cap_address, lbr, $t38, $t39)
    call $LibraAccount_deposit($LBR_LBR_type_value(), $t35, cap_address, lbr, $t38, $t39);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // $t43 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t43 := $tmp;

    // $t44 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t44 := $tmp;

    // LibraAccount::deposit<Coin1::Coin1>(cap_address, cap_address, coin1#1515, $t43, $t44)
    call $LibraAccount_deposit($Coin1_Coin1_type_value(), cap_address, cap_address, coin1#1515, $t43, $t44);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // $t48 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t48 := $tmp;

    // $t49 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t49 := $tmp;

    // LibraAccount::deposit<Coin2::Coin2>(cap_address, cap_address, coin2#1516, $t48, $t49)
    call $LibraAccount_deposit($Coin2_Coin2_type_value(), cap_address, cap_address, coin2#1516, $t48, $t49);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_staple_lbr(cap: $Value, amount_lbr: $Value) returns ()
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires $IsValidU64(amount_lbr);
{
    call $LibraAccount_staple_lbr_def(cap, amount_lbr);
}

procedure {:inline 1} $LibraAccount_success_epilogue_def($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns (){
    // declare local variables
    var sender: $Value; // $AddressType()
    var sender_balance: $Value; // $IntegerType()
    var $t7: $Value; // $IntegerType()
    var $t8: $Value; // $BooleanType()
    var $t9: $Value; // $IntegerType()
    var transaction_fee_amount: $Value; // $IntegerType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $IntegerType()
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $IntegerType()
    var $t16: $Value; // $IntegerType()
    var $t17: $Value; // $IntegerType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $IntegerType()
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $IntegerType()
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $IntegerType()
    var $t26: $Value; // $BooleanType()
    var $t27: $Value; // $BooleanType()
    var $t28: $Value; // $IntegerType()
    var $t29: $Value; // $AddressType()
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $IntegerType()
    var $t32: $Value; // $AddressType()
    var $t33: $Value; // $IntegerType()
    var $t34: $Value; // $IntegerType()
    var $t35: $Value; // $IntegerType()
    var $t36: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 40479, 0, account); }
    if (true) { assume $DebugTrackLocal(29, 40479, 1, txn_sequence_number); }
    if (true) { assume $DebugTrackLocal(29, 40479, 2, txn_gas_price); }
    if (true) { assume $DebugTrackLocal(29, 40479, 3, txn_max_gas_units); }
    if (true) { assume $DebugTrackLocal(29, 40479, 4, gas_units_remaining); }

    // bytecode translation starts here
    // $t32 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t32 := $tmp;

    // $t33 := move(txn_sequence_number)
    call $tmp := $CopyOrMoveValue(txn_sequence_number);
    $t33 := $tmp;

    // $t34 := move(txn_gas_price)
    call $tmp := $CopyOrMoveValue(txn_gas_price);
    $t34 := $tmp;

    // $t35 := move(txn_max_gas_units)
    call $tmp := $CopyOrMoveValue(txn_max_gas_units);
    $t35 := $tmp;

    // $t36 := move(gas_units_remaining)
    call $tmp := $CopyOrMoveValue(gas_units_remaining);
    $t36 := $tmp;

    // $t11 := move($t32)
    call $tmp := $CopyOrMoveValue($t32);
    $t11 := $tmp;

    // $t12 := Signer::address_of($t11)
    call $t12 := $Signer_address_of($t11);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 40758);
      goto Abort;
    }
    assume is#$Address($t12);


    // sender := $t12
    call $tmp := $CopyOrMoveValue($t12);
    sender := $tmp;
    if (true) { assume $DebugTrackLocal(29, 40741, 5, $tmp); }

    // $t16 := -($t35, $t36)
    call $tmp := $Sub($t35, $t36);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 40878);
      goto Abort;
    }
    $t16 := $tmp;

    // $t17 := *($t34, $t16)
    call $tmp := $MulU64($t34, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 40857);
      goto Abort;
    }
    $t17 := $tmp;

    // transaction_fee_amount := $t17
    call $tmp := $CopyOrMoveValue($t17);
    transaction_fee_amount := $tmp;
    if (true) { assume $DebugTrackLocal(29, 40818, 10, $tmp); }

    // $t19 := exists<LibraAccount::Balance<#0>>(sender)
    call $tmp := $Exists(sender, $LibraAccount_Balance_type_value($tv0));
    $t19 := $tmp;

    // if ($t19) goto L0 else goto L1
    $tmp := $t19;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t21 := LibraAccount::balance<#0>(sender)
    call $t21 := $LibraAccount_balance($tv0, sender);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 32288);
      goto Abort;
    }
    assume $IsValidU64($t21);


    // $t7 := $t21
    call $tmp := $CopyOrMoveValue($t21);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 41049, 7, $tmp); }

    // goto L3
    goto L3;

    // L2:
L2:

    // $t22 := 0
    $tmp := $Integer(0);
    $t22 := $tmp;

    // $t7 := $t22
    call $tmp := $CopyOrMoveValue($t22);
    $t7 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 41049, 7, $tmp); }

    // goto L3
    goto L3;

    // L3:
L3:

    // sender_balance := $t7
    call $tmp := $CopyOrMoveValue($t7);
    sender_balance := $tmp;
    if (true) { assume $DebugTrackLocal(29, 41032, 6, $tmp); }

    // $t26 := >=(sender_balance, transaction_fee_amount)
    call $tmp := $Ge(sender_balance, transaction_fee_amount);
    $t26 := $tmp;

    // $t8 := $t26
    call $tmp := $CopyOrMoveValue($t26);
    $t8 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 41124, 8, $tmp); }

    // if ($t8) goto L4 else goto L5
    $tmp := $t8;
    if (b#$Boolean($tmp)) { goto L4; } else { goto L5; }

    // L5:
L5:

    // $t28 := 5
    $tmp := $Integer(5);
    $t28 := $tmp;

    // abort($t28)
    if (true) { assume $DebugTrackAbort(29, 41124); }
    goto Abort;

    // L4:
L4:

    // LibraAccount::epilogue<#0>(sender, transaction_fee_amount, $t33)
    call $LibraAccount_epilogue($tv0, sender, transaction_fee_amount, $t33);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 39492);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_success_epilogue($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
free requires is#$Address(account);
free requires $IsValidU64(txn_sequence_number);
free requires $IsValidU64(txn_gas_price);
free requires $IsValidU64(txn_max_gas_units);
free requires $IsValidU64(gas_units_remaining);
{
    call $LibraAccount_success_epilogue_def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}

procedure $LibraAccount_success_epilogue_verify($tv0: $TypeValue, account: $Value, txn_sequence_number: $Value, txn_gas_price: $Value, txn_max_gas_units: $Value, gas_units_remaining: $Value) returns ()
free requires is#$Address(account);
free requires $IsValidU64(txn_sequence_number);
free requires $IsValidU64(txn_gas_price);
free requires $IsValidU64(txn_max_gas_units);
free requires $IsValidU64(gas_units_remaining);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $LibraAccount_success_epilogue_def($tv0, account, txn_sequence_number, txn_gas_price, txn_max_gas_units, gas_units_remaining);
}

procedure {:inline 1} $LibraAccount_unfreeze_account_def(account: $Value, unfrozen_address: $Value) returns (){
    // declare local variables
    var initiator_address: $Value; // $AddressType()
    var $t3: $Value; // $BooleanType()
    var $t4: $Value; // $IntegerType()
    var $t5: $Value; // $AddressType()
    var $t6: $Value; // $BooleanType()
    var $t7: $Value; // $BooleanType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $AddressType()
    var $t11: $Value; // $AddressType()
    var $t12: $Value; // $BooleanType()
    var $t13: $Value; // $AddressType()
    var $t14: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t15: $Reference; // ReferenceType($BooleanType())
    var $t16: $Value; // $AddressType()
    var $t17: $Reference; // ReferenceType($LibraAccount_AccountOperationsCapability_type_value())
    var $t18: $Reference; // ReferenceType($Event_EventHandle_type_value($LibraAccount_UnfreezeAccountEvent_type_value()))
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $LibraAccount_UnfreezeAccountEvent_type_value()
    var $t22: $Value; // $AddressType()
    var $t23: $Value; // $AddressType()
    var $t24: $Value; // $Event_EventHandle_type_value($LibraAccount_UnfreezeAccountEvent_type_value())
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 36107, 0, account); }
    if (true) { assume $DebugTrackLocal(29, 36107, 1, unfrozen_address); }

    // bytecode translation starts here
    // $t22 := move(account)
    call $tmp := $CopyOrMoveValue(account);
    $t22 := $tmp;

    // $t23 := move(unfrozen_address)
    call $tmp := $CopyOrMoveValue(unfrozen_address);
    $t23 := $tmp;

    // $t5 := copy($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t5 := $tmp;

    // $t6 := Roles::has_treasury_compliance_role($t5)
    call $t6 := $Roles_has_treasury_compliance_role($t5);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 36282);
      goto Abort;
    }
    assume is#$Boolean($t6);


    // $t3 := $t6
    call $tmp := $CopyOrMoveValue($t6);
    $t3 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 36268, 3, $tmp); }

    // if ($t3) goto L0 else goto L1
    $tmp := $t3;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // $t8 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t8 := $tmp;

    // destroy($t8)

    // $t9 := 14
    $tmp := $Integer(14);
    $t9 := $tmp;

    // abort($t9)
    if (true) { assume $DebugTrackAbort(29, 36268); }
    goto Abort;

    // L0:
L0:

    // $t10 := move($t22)
    call $tmp := $CopyOrMoveValue($t22);
    $t10 := $tmp;

    // $t11 := Signer::address_of($t10)
    call $t11 := $Signer_address_of($t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 36388);
      goto Abort;
    }
    assume is#$Address($t11);


    // initiator_address := $t11
    call $tmp := $CopyOrMoveValue($t11);
    initiator_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 36360, 2, $tmp); }

    // $t12 := false
    $tmp := $Boolean(false);
    $t12 := $tmp;

    // $t14 := borrow_global<LibraAccount::LibraAccount>($t23)
    call $t14 := $BorrowGlobal($t23, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 36417);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t14));

    // UnpackRef($t14)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t14));

    // $t15 := borrow_field<LibraAccount::LibraAccount>.is_frozen($t14)
    call $t15 := $BorrowField($t14, $LibraAccount_LibraAccount_is_frozen);
    assume is#$Boolean($Dereference($t15));

    // LibraAccount::LibraAccount <- $t14
    call $WritebackToGlobal($t14);

    // UnpackRef($t15)

    // write_ref($t15, $t12)
    call $t15 := $WriteRef($t15, $t12);

    // LibraAccount::LibraAccount <- $t15
    call $WritebackToGlobal($t15);

    // Reference($t14) <- $t15
    call $t14 := $WritebackToReference($t15, $t14);

    // PackRef($t14)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t14));

    // PackRef($t15)

    // $t16 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t16 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 36614);
      goto Abort;
    }
    assume is#$Address($t16);


    // $t17 := borrow_global<LibraAccount::AccountOperationsCapability>($t16)
    call $t17 := $BorrowGlobal($t16, $LibraAccount_AccountOperationsCapability_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 36552);
      goto Abort;
    }
    assume $LibraAccount_AccountOperationsCapability_is_well_formed($Dereference($t17));

    // UnpackRef($t17)

    // $t18 := borrow_field<LibraAccount::AccountOperationsCapability>.unfreeze_event_handle($t17)
    call $t18 := $BorrowField($t17, $LibraAccount_AccountOperationsCapability_unfreeze_event_handle);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t18));

    // LibraAccount::AccountOperationsCapability <- $t17
    call $WritebackToGlobal($t17);

    // UnpackRef($t18)

    // $t21 := pack LibraAccount::UnfreezeAccountEvent(initiator_address, $t23)
    call $tmp := $LibraAccount_UnfreezeAccountEvent_pack(0, 0, 0, initiator_address, $t23);
    $t21 := $tmp;

    // PackRef($t18)

    // $t24 := read_ref($t18)
    call $tmp := $ReadRef($t18);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t24 := $tmp;

    // $t24 := Event::emit_event<LibraAccount::UnfreezeAccountEvent>($t24, $t21)
    call $t24 := $Event_emit_event($LibraAccount_UnfreezeAccountEvent_type_value(), $t24, $t21);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 36501);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t24);


    // write_ref($t18, $t24)
    call $t18 := $WriteRef($t18, $t24);

    // LibraAccount::AccountOperationsCapability <- $t18
    call $WritebackToGlobal($t18);

    // Reference($t17) <- $t18
    call $t17 := $WritebackToReference($t18, $t17);

    // UnpackRef($t18)

    // PackRef($t17)

    // PackRef($t18)

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_unfreeze_account(account: $Value, unfrozen_address: $Value) returns ()
free requires is#$Address(account);
free requires is#$Address(unfrozen_address);
{
    call $LibraAccount_unfreeze_account_def(account, unfrozen_address);
}

procedure {:inline 1} $LibraAccount_unstaple_lbr_def(cap: $Value, amount_lbr: $Value) returns (){
    // declare local variables
    var coin1: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var coin2: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var lbr: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var payee_address: $Value; // $AddressType()
    var payer_address: $Value; // $AddressType()
    var $t7: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $IntegerType()
    var $t10: $Value; // $Vector_type_value($IntegerType())
    var $t11: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t12: $Value; // $Libra_Libra_type_value($LBR_LBR_type_value())
    var $t13: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t14: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t15: $Value; // $AddressType()
    var $t16: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t17: $Value; // $AddressType()
    var $t18: $Value; // $AddressType()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Value; // $Libra_Libra_type_value($Coin1_Coin1_type_value())
    var $t22: $Value; // $Vector_type_value($IntegerType())
    var $t23: $Value; // $Vector_type_value($IntegerType())
    var $t24: $Value; // $AddressType()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $Libra_Libra_type_value($Coin2_Coin2_type_value())
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $Vector_type_value($IntegerType())
    var $t29: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t30: $Value; // $IntegerType()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 11030, 0, cap); }
    if (true) { assume $DebugTrackLocal(29, 11030, 1, amount_lbr); }

    // bytecode translation starts here
    // $t29 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t29 := $tmp;

    // $t30 := move(amount_lbr)
    call $tmp := $CopyOrMoveValue(amount_lbr);
    $t30 := $tmp;

    // $t7 := copy($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t7 := $tmp;

    // $t8 := CoreAddresses::VM_RESERVED_ADDRESS()
    call $t8 := $CoreAddresses_VM_RESERVED_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11302);
      goto Abort;
    }
    assume is#$Address($t8);


    // $t10 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t10 := $tmp;

    // $t11 := LibraAccount::withdraw_from<LBR::LBR>($t7, $t8, $t30, $t10)
    call $t11 := $LibraAccount_withdraw_from($LBR_LBR_type_value(), $t7, $t8, $t30, $t10);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17784);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t11);


    // lbr := $t11
    call $tmp := $CopyOrMoveValue($t11);
    lbr := $tmp;
    if (true) { assume $DebugTrackLocal(29, 11257, 4, $tmp); }

    // ($t13, $t14) := LBR::unpack(lbr)
    call $t13, $t14 := $LBR_unpack(lbr);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11377);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t13);

    assume $Libra_Libra_is_well_formed($t14);


    // coin2 := $t14
    call $tmp := $CopyOrMoveValue($t14);
    coin2 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 11363, 3, $tmp); }

    // coin1 := $t13
    call $tmp := $CopyOrMoveValue($t13);
    coin1 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 11356, 2, $tmp); }

    // $t15 := LBR::reserve_address()
    call $t15 := $LBR_reserve_address();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11517);
      goto Abort;
    }
    assume is#$Address($t15);


    // payer_address := $t15
    call $tmp := $CopyOrMoveValue($t15);
    payer_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 11496, 6, $tmp); }

    // $t16 := move($t29)
    call $tmp := $CopyOrMoveValue($t29);
    $t16 := $tmp;

    // $t17 := get_field<LibraAccount::WithdrawCapability>.account_address($t16)
    call $tmp := $GetFieldFromValue($t16, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address($tmp);
    $t17 := $tmp;

    // $t18 := move($t17)
    call $tmp := $CopyOrMoveValue($t17);
    $t18 := $tmp;

    // payee_address := $t18
    call $tmp := $CopyOrMoveValue($t18);
    payee_address := $tmp;
    if (true) { assume $DebugTrackLocal(29, 11548, 5, $tmp); }

    // $t22 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t22 := $tmp;

    // $t23 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t23 := $tmp;

    // LibraAccount::deposit<Coin1::Coin1>(payer_address, payee_address, coin1, $t22, $t23)
    call $LibraAccount_deposit($Coin1_Coin1_type_value(), payer_address, payee_address, coin1, $t22, $t23);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // $t27 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t27 := $tmp;

    // $t28 := []
    $tmp := $Vector($ValueArray($MapConstValue($DefaultValue()), 0));
    $t28 := $tmp;

    // LibraAccount::deposit<Coin2::Coin2>(payer_address, payee_address, coin2, $t27, $t28)
    call $LibraAccount_deposit($Coin2_Coin2_type_value(), payer_address, payee_address, coin2, $t27, $t28);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 11962);
      goto Abort;
    }

    // return ()
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
}
procedure {:inline 1} $LibraAccount_unstaple_lbr(cap: $Value, amount_lbr: $Value) returns ()
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires $IsValidU64(amount_lbr);
{
    call $LibraAccount_unstaple_lbr_def(cap, amount_lbr);
}

procedure {:inline 1} $LibraAccount_withdraw_capability_address_def(cap: $Value) returns ($ret0: $Value){
    // declare local variables
    var $t1: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t2: $Value; // $AddressType()
    var $t3: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 34281, 0, cap); }

    // bytecode translation starts here
    // $t3 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t3 := $tmp;

    // $t1 := move($t3)
    call $tmp := $CopyOrMoveValue($t3);
    $t1 := $tmp;

    // $t2 := get_field<LibraAccount::WithdrawCapability>.account_address($t1)
    call $tmp := $GetFieldFromValue($t1, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address($tmp);
    $t2 := $tmp;

    // return $t2
    $ret0 := $t2;
    if (true) { assume $DebugTrackLocal(29, 34366, 4, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_withdraw_capability_address(cap: $Value) returns ($ret0: $Value)
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
{
    call $ret0 := $LibraAccount_withdraw_capability_address_def(cap);
}

procedure $LibraAccount_withdraw_capability_address_verify(cap: $Value) returns ($ret0: $Value)
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_withdraw_capability_address_def(cap);
}

procedure {:inline 1} $LibraAccount_withdraw_from_def($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value){
    // declare local variables
    var account_balance: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var payer: $Value; // $AddressType()
    var $t6: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $AddressType()
    var $t10: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t11: $Value; // $AddressType()
    var $t12: $Reference; // ReferenceType($LibraAccount_LibraAccount_type_value())
    var $t13: $Reference; // ReferenceType($Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value()))
    var $t14: $Value; // $IntegerType()
    var $t15: $Value; // $Vector_type_value($IntegerType())
    var $t16: $Value; // $AddressType()
    var $t17: $Value; // $Vector_type_value($IntegerType())
    var $t18: $Value; // $LibraAccount_SentPaymentEvent_type_value()
    var $t19: $Value; // $AddressType()
    var $t20: $Value; // $AddressType()
    var $t21: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t22: $Value; // $IntegerType()
    var $t23: $Value; // $Libra_Libra_type_value($tv0)
    var $t24: $Value; // $LibraAccount_WithdrawCapability_type_value()
    var $t25: $Value; // $AddressType()
    var $t26: $Value; // $IntegerType()
    var $t27: $Value; // $Vector_type_value($IntegerType())
    var $t28: $Value; // $Event_EventHandle_type_value($LibraAccount_SentPaymentEvent_type_value())
    var $t29: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 17780, 0, cap); }
    if (true) { assume $DebugTrackLocal(29, 17780, 1, payee); }
    if (true) { assume $DebugTrackLocal(29, 17780, 2, amount); }
    if (true) { assume $DebugTrackLocal(29, 17780, 3, metadata); }

    // bytecode translation starts here
    // $t24 := move(cap)
    call $tmp := $CopyOrMoveValue(cap);
    $t24 := $tmp;

    // $t25 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t25 := $tmp;

    // $t26 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t26 := $tmp;

    // $t27 := move(metadata)
    call $tmp := $CopyOrMoveValue(metadata);
    $t27 := $tmp;

    // $t6 := move($t24)
    call $tmp := $CopyOrMoveValue($t24);
    $t6 := $tmp;

    // $t7 := get_field<LibraAccount::WithdrawCapability>.account_address($t6)
    call $tmp := $GetFieldFromValue($t6, $LibraAccount_WithdrawCapability_account_address);
    assume is#$Address($tmp);
    $t7 := $tmp;

    // $t8 := move($t7)
    call $tmp := $CopyOrMoveValue($t7);
    $t8 := $tmp;

    // payer := $t8
    call $tmp := $CopyOrMoveValue($t8);
    payer := $tmp;
    if (true) { assume $DebugTrackLocal(29, 18009, 5, $tmp); }

    // $t10 := borrow_global<LibraAccount::Balance<#0>>(payer)
    call $t10 := $BorrowGlobal(payer, $LibraAccount_Balance_type_value($tv0));
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 18068);
      goto Abort;
    }
    assume $LibraAccount_Balance_is_well_formed($Dereference($t10));

    // UnpackRef($t10)
    call $LibraAccount_Balance_before_update_inv($tv0, $Dereference($t10));

    // account_balance := $t10
    call account_balance := $CopyOrMoveRef($t10);
    if (true) { assume $DebugTrackLocal(29, 18050, 4, $Dereference(account_balance)); }

    // $t12 := borrow_global<LibraAccount::LibraAccount>(payer)
    call $t12 := $BorrowGlobal(payer, $LibraAccount_LibraAccount_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 18251);
      goto Abort;
    }
    assume $LibraAccount_LibraAccount_is_well_formed($Dereference($t12));

    // UnpackRef($t12)
    call $LibraAccount_LibraAccount_before_update_inv($Dereference($t12));

    // $t13 := borrow_field<LibraAccount::LibraAccount>.sent_events($t12)
    call $t13 := $BorrowField($t12, $LibraAccount_LibraAccount_sent_events);
    assume $Event_EventHandle_is_well_formed_types($Dereference($t13));

    // LibraAccount::LibraAccount <- $t12
    call $WritebackToGlobal($t12);

    // UnpackRef($t13)

    // $t15 := Libra::currency_code<#0>()
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t15 := $Libra_currency_code($tv0);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 18396);
      goto Abort;
    }
    assume $Vector_is_well_formed($t15) && (forall $$0: int :: {$select_vector($t15,$$0)} $$0 >= 0 && $$0 < $vlen($t15) ==> $IsValidU8($select_vector($t15,$$0)));


    // $t18 := pack LibraAccount::SentPaymentEvent($t26, $t15, $t25, $t27)
    call $tmp := $LibraAccount_SentPaymentEvent_pack(0, 0, 0, $t26, $t15, $t25, $t27);
    $t18 := $tmp;

    // PackRef($t13)

    // $t28 := read_ref($t13)
    call $tmp := $ReadRef($t13);
    assume $Event_EventHandle_is_well_formed($tmp);
    $t28 := $tmp;

    // $t28 := Event::emit_event<LibraAccount::SentPaymentEvent>($t28, $t18)
    call $t28 := $Event_emit_event($LibraAccount_SentPaymentEvent_type_value(), $t28, $t18);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 18204);
      goto Abort;
    }
    assume $Event_EventHandle_is_well_formed($t28);


    // write_ref($t13, $t28)
    call $t13 := $WriteRef($t13, $t28);
    if (true) { assume $DebugTrackLocal(29, 18562, 4, $Dereference(account_balance)); }

    // LibraAccount::LibraAccount <- $t13
    call $WritebackToGlobal($t13);

    // Reference($t12) <- $t13
    call $t12 := $WritebackToReference($t13, $t12);

    // UnpackRef($t13)

    // PackRef($t12)
    call $LibraAccount_LibraAccount_after_update_inv($Dereference($t12));

    // PackRef($t13)

    // $t21 := move(account_balance)
    call $t21 := $CopyOrMoveRef(account_balance);

    // $t29 := read_ref($t21)
    call $tmp := $ReadRef($t21);
    assume $LibraAccount_Balance_is_well_formed($tmp);
    $t29 := $tmp;

    // ($t23, $t29) := LibraAccount::withdraw_from_balance<#0>(payer, $t25, $t29, $t26)
    call $t23, $t29 := $LibraAccount_withdraw_from_balance($tv0, payer, $t25, $t29, $t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 16795);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t23);

    assume $LibraAccount_Balance_is_well_formed($t29);


    // write_ref($t21, $t29)
    call $t21 := $WriteRef($t21, $t29);
    if (true) { assume $DebugTrackLocal(29, 18502, 4, $Dereference(account_balance)); }

    // LibraAccount::Balance <- $t21
    call $WritebackToGlobal($t21);

    // PackRef($t21)
    call $LibraAccount_Balance_after_update_inv($tv0, $Dereference($t21));

    // return $t23
    $ret0 := $t23;
    if (true) { assume $DebugTrackLocal(29, 18502, 30, $ret0); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_withdraw_from($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires is#$Address(payee);
free requires $IsValidU64(amount);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
{
    call $ret0 := $LibraAccount_withdraw_from_def($tv0, cap, payee, amount, metadata);
}

procedure $LibraAccount_withdraw_from_verify($tv0: $TypeValue, cap: $Value, payee: $Value, amount: $Value, metadata: $Value) returns ($ret0: $Value)
free requires $LibraAccount_WithdrawCapability_is_well_formed(cap);
free requires is#$Address(payee);
free requires $IsValidU64(amount);
free requires $Vector_is_well_formed(metadata) && (forall $$0: int :: {$select_vector(metadata,$$0)} $$0 >= 0 && $$0 < $vlen(metadata) ==> $IsValidU8($select_vector(metadata,$$0)));
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0 := $LibraAccount_withdraw_from_def($tv0, cap, payee, amount, metadata);
}

procedure {:inline 1} $LibraAccount_withdraw_from_balance_def($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value){
    // declare local variables
    var can_withdraw: $Value; // $BooleanType()
    var $t5: $Value; // $BooleanType()
    var $t6: $Value; // $IntegerType()
    var $t7: $Value; // $AddressType()
    var $t8: $Value; // $AddressType()
    var $t9: $Value; // $BooleanType()
    var $t10: $Value; // $BooleanType()
    var $t11: $Value; // $IntegerType()
    var $t12: $Value; // $AddressType()
    var $t13: $Value; // $AddressType()
    var $t14: $Value; // $AddressType()
    var $t15: $Value; // $LibraAccount_AccountOperationsCapability_type_value()
    var $t16: $Value; // $AccountLimits_CallingCapability_type_value()
    var $t17: $Value; // $BooleanType()
    var $t18: $Value; // $BooleanType()
    var $t19: $Value; // $BooleanType()
    var $t20: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t21: $Value; // $IntegerType()
    var $t22: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t23: $Reference; // ReferenceType($Libra_Libra_type_value($tv0))
    var $t24: $Value; // $IntegerType()
    var $t25: $Value; // $Libra_Libra_type_value($tv0)
    var $t26: $Value; // $AddressType()
    var $t27: $Value; // $AddressType()
    var $t28: $Value; // $LibraAccount_Balance_type_value($tv0)
    var $t29: $Reference; // ReferenceType($LibraAccount_Balance_type_value($tv0))
    var $t30: $Value; // $IntegerType()
    var $t31: $Value; // $Libra_Libra_type_value($tv0)
    var $tmp: $Value;
    var $saved_m: $Memory;

    // initialize function execution
    assume !$abort_flag;
    $saved_m := $m;

    // track values of parameters at entry time
    if (true) { assume $DebugTrackLocal(29, 16791, 0, payer); }
    if (true) { assume $DebugTrackLocal(29, 16791, 1, payee); }
    if (true) { assume $DebugTrackLocal(29, 16791, 2, balance); }
    if (true) { assume $DebugTrackLocal(29, 16791, 3, amount); }

    // bytecode translation starts here
    // $t26 := move(payer)
    call $tmp := $CopyOrMoveValue(payer);
    $t26 := $tmp;

    // $t27 := move(payee)
    call $tmp := $CopyOrMoveValue(payee);
    $t27 := $tmp;

    // $t28 := move(balance)
    call $tmp := $CopyOrMoveValue(balance);
    $t28 := $tmp;

    // $t30 := move(amount)
    call $tmp := $CopyOrMoveValue(amount);
    $t30 := $tmp;

    // $t29 := borrow_local($t28)
    call $t29 := $BorrowLoc(28, $t28);
    assume $LibraAccount_Balance_is_well_formed($Dereference($t29));

    // $t9 := true
    $tmp := $Boolean(true);
    $t9 := $tmp;

    // $t10 := LibraAccount::should_track_limits_for_account($t26, $t27, $t9)
    call $t10 := $LibraAccount_should_track_limits_for_account($t26, $t27, $t9);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 7857);
      goto Abort;
    }
    assume is#$Boolean($t10);


    // if ($t10) goto L0 else goto L1
    $tmp := $t10;
    if (b#$Boolean($tmp)) { goto L0; } else { goto L1; }

    // L1:
L1:

    // goto L2
    goto L2;

    // L0:
L0:

    // $t13 := VASP::parent_address($t26)
    assume b#$Boolean($Boolean((forall a: $Value :: is#$Address(a) ==> b#$Boolean($VASP_spec_child_has_parent($m, $txn, a)))));
    call $t13 := $VASP_parent_address($t26);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17318);
      goto Abort;
    }
    assume is#$Address($t13);


    // $t14 := CoreAddresses::LIBRA_ROOT_ADDRESS()
    call $t14 := $CoreAddresses_LIBRA_ROOT_ADDRESS();
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17420);
      goto Abort;
    }
    assume is#$Address($t14);


    // $t15 := get_global<LibraAccount::AccountOperationsCapability>($t14)
    call $tmp := $GetGlobal($t14, $LibraAccount_AccountOperationsCapability_type_value());
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17362);
      goto Abort;
    }
    assume $LibraAccount_AccountOperationsCapability_is_well_formed($tmp);
    $t15 := $tmp;

    // $t16 := get_field<LibraAccount::AccountOperationsCapability>.limits_cap($t15)
    call $tmp := $GetFieldFromValue($t15, $LibraAccount_AccountOperationsCapability_limits_cap);
    assume $AccountLimits_CallingCapability_is_well_formed($tmp);
    $t16 := $tmp;

    // $t17 := AccountLimits::update_withdrawal_limits<#0>($t30, $t13, $t16)
    call $t17 := $AccountLimits_update_withdrawal_limits($tv0, $t30, $t13, $t16);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17231);
      goto Abort;
    }
    assume is#$Boolean($t17);


    // can_withdraw := $t17
    call $tmp := $CopyOrMoveValue($t17);
    can_withdraw := $tmp;
    if (true) { assume $DebugTrackLocal(29, 17201, 4, $tmp); }

    // $t5 := can_withdraw
    call $tmp := $CopyOrMoveValue(can_withdraw);
    $t5 := $tmp;
    if (true) { assume $DebugTrackLocal(29, 17480, 5, $tmp); }

    // if ($t5) goto L2 else goto L3
    $tmp := $t5;
    if (b#$Boolean($tmp)) { goto L2; } else { goto L3; }

    // L3:
L3:

    // $t20 := move($t29)
    call $t20 := $CopyOrMoveRef($t29);

    // destroy($t20)

    // LocalRoot($t28) <- $t20
    call $t28 := $WritebackToValue($t20, 28, $t28);

    // $t21 := 6
    $tmp := $Integer(6);
    $t21 := $tmp;

    // abort($t21)
    if (true) { assume $DebugTrackAbort(29, 17480); }
    goto Abort;

    // L2:
L2:

    // $t22 := move($t29)
    call $t22 := $CopyOrMoveRef($t29);

    // $t23 := borrow_field<LibraAccount::Balance<#0>>.coin($t22)
    call $t23 := $BorrowField($t22, $LibraAccount_Balance_coin);
    assume $Libra_Libra_is_well_formed_types($Dereference($t23));

    // LocalRoot($t28) <- $t22
    call $t28 := $WritebackToValue($t22, 28, $t28);

    // UnpackRef($t23)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t23));

    // PackRef($t23)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t23));

    // $t31 := read_ref($t23)
    call $tmp := $ReadRef($t23);
    assume $Libra_Libra_is_well_formed($tmp);
    $t31 := $tmp;

    // ($t25, $t31) := Libra::withdraw<#0>($t31, $t30)
    assume b#$Boolean($Boolean(b#$Boolean($Boolean(!b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)))) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $Integer(0))))));
    assume b#$Boolean($Boolean(b#$Boolean($Libra_spec_is_currency($m, $txn, $tv0)) ==> b#$Boolean($Boolean($IsEqual($Libra_sum_of_coin_values[$tv0], $SelectField($ResourceValue($m, $Libra_CurrencyInfo_type_value($tv0), $CoreAddresses_SPEC_CURRENCY_INFO_ADDRESS()), $Libra_CurrencyInfo_total_value))))));
    call $t25, $t31 := $Libra_withdraw($tv0, $t31, $t30);
    if ($abort_flag) {
      assume $DebugTrackAbort(29, 17556);
      goto Abort;
    }
    assume $Libra_Libra_is_well_formed($t25);

    assume $Libra_Libra_is_well_formed($t31);


    // write_ref($t23, $t31)
    call $t23 := $WriteRef($t23, $t31);

    // LocalRoot($t28) <- $t23
    call $t28 := $WritebackToValue($t23, 28, $t28);

    // Reference($t22) <- $t23
    call $t22 := $WritebackToReference($t23, $t22);

    // UnpackRef($t23)
    call $Libra_Libra_before_update_inv($tv0, $Dereference($t23));

    // PackRef($t23)
    call $Libra_Libra_after_update_inv($tv0, $Dereference($t23));

    // return ($t25, $t28)
    $ret0 := $t25;
    if (true) { assume $DebugTrackLocal(29, 17549, 32, $ret0); }
    $ret1 := $t28;
    if (true) { assume $DebugTrackLocal(29, 17549, 33, $ret1); }
    return;

Abort:
    $abort_flag := true;
    $m := $saved_m;
    $ret0 := $DefaultValue();
    $ret1 := $DefaultValue();
}
procedure {:inline 1} $LibraAccount_withdraw_from_balance($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $LibraAccount_Balance_is_well_formed(balance);
free requires $IsValidU64(amount);
{
    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_def($tv0, payer, payee, balance, amount);
}

procedure $LibraAccount_withdraw_from_balance_verify($tv0: $TypeValue, payer: $Value, payee: $Value, balance: $Value, amount: $Value) returns ($ret0: $Value, $ret1: $Value)
free requires is#$Address(payer);
free requires is#$Address(payee);
free requires $LibraAccount_Balance_is_well_formed(balance);
free requires $IsValidU64(amount);
{
    call $InitVerification();
    assume $Memory__is_well_formed($m);
    call $ret0, $ret1 := $LibraAccount_withdraw_from_balance_def($tv0, payer, payee, balance, amount);
}
