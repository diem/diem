// Copyright (c) The Libra Core Contributors
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To re-generate this code, run: `cargo run --release -p stdlib`

//! Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
//! standard LCS-compatible representation used in Libra transactions (`Script`).
//!
//! This code was generated by compiling known Script interfaces ("ABIs") with the tool `transaction-builder-generator`.

#![allow(unused_imports)]
use libra_types::{
    account_address::AccountAddress,
    transaction::{Script, TransactionArgument},
};
use move_core_types::language_storage::TypeTag;
use std::collections::BTreeMap as Map;

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move script.
/// ```ignore
/// impl ScriptCall {
///     pub fn encode(self) -> Script { .. }
///     pub fn decode(&Script) -> Option<ScriptCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, PartialOrd)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
#[cfg_attr(any(test, feature = "fuzzing"), proptest(no_params))]
pub enum ScriptCall {
    /// Add a `Currency` balance to `account`, which will enable `account` to send and receive
    /// `Libra<Currency>`.
    /// Aborts with NOT_A_CURRENCY if `Currency` is not an accepted currency type in the Libra system
    /// Aborts with `LibraAccount::ADD_EXISTING_CURRENCY` if the account already holds a balance in
    /// `Currency`.
    AddCurrencyToAccount { currency: TypeTag },

    /// Add the `KeyRotationCapability` for `to_recover_account` to the `RecoveryAddress` resource under `recovery_address`.
    ///
    /// ## Aborts
    /// * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if `account` has already delegated its `KeyRotationCapability`.
    /// * Aborts with `RecoveryAddress:ENOT_A_RECOVERY_ADDRESS` if `recovery_address` does not have a `RecoveryAddress` resource.
    /// * Aborts with `RecoveryAddress::EINVALID_KEY_ROTATION_DELEGATION` if `to_recover_account` and `recovery_address` do not belong to the same VASP.
    AddRecoveryRotationCapability { recovery_address: AccountAddress },

    /// Append the `hash` to script hashes list allowed to be executed by the network.
    AddToScriptAllowList { hash: Bytes, sliding_nonce: u64 },

    /// Add `new_validator` to the validator set.
    /// Fails if the `new_validator` address is already in the validator set
    /// or does not have a `ValidatorConfig` resource stored at the address.
    /// Emits a NewEpochEvent.
    AddValidatorAndReconfigure {
        sliding_nonce: u64,
        validator_name: Bytes,
        validator_address: AccountAddress,
    },

    /// Permanently destroy the `Token`s stored in the oldest burn request under the `Preburn` resource.
    /// This will only succeed if `account` has a `MintCapability<Token>`, a `Preburn<Token>` resource
    /// exists under `preburn_address`, and there is a pending burn request.
    /// sliding_nonce is a unique nonce for operation, see sliding_nonce.move for details
    Burn {
        token: TypeTag,
        sliding_nonce: u64,
        preburn_address: AccountAddress,
    },

    /// Burn transaction fees that have been collected in the given `currency`
    /// and relinquish to the association. The currency must be non-synthetic.
    BurnTxnFees { coin_type: TypeTag },

    /// Cancel the oldest burn request from `preburn_address` and return the funds.
    /// Fails if the sender does not have a published `BurnCapability<Token>`.
    CancelBurn {
        token: TypeTag,
        preburn_address: AccountAddress,
    },

    /// Create a `ChildVASP` account for sender `parent_vasp` at `child_address` with a balance of
    /// `child_initial_balance` in `CoinType` and an initial authentication_key
    /// `auth_key_prefix | child_address`.
    /// If `add_all_currencies` is true, the child address will have a zero balance in all available
    /// currencies in the system.
    /// This account will a child of the transaction sender, which must be a ParentVASP.
    ///
    /// ## Aborts
    /// The transaction will abort:
    ///
    /// * If `parent_vasp` is not a parent vasp with error: `Roles::EINVALID_PARENT_ROLE`
    /// * If `child_address` already exists with error: `Roles::EROLE_ALREADY_ASSIGNED`
    /// * If `parent_vasp` already has 256 child accounts with error: `VASP::ETOO_MANY_CHILDREN`
    /// * If `CoinType` is not a registered currency with error: `LibraAccount::ENOT_A_CURRENCY`
    /// * If `parent_vasp`'s withdrawal capability has been extracted with error:  `LibraAccount::EWITHDRAWAL_CAPABILITY_ALREADY_EXTRACTED`
    /// * If `parent_vasp` doesn't hold `CoinType` and `child_initial_balance > 0` with error: `LibraAccount::EPAYER_DOESNT_HOLD_CURRENCY`
    /// * If `parent_vasp` doesn't at least `child_initial_balance` of `CoinType` in its account balance with error: `LibraAccount::EINSUFFICIENT_BALANCE`
    CreateChildVaspAccount {
        coin_type: TypeTag,
        child_address: AccountAddress,
        auth_key_prefix: Bytes,
        add_all_currencies: bool,
        child_initial_balance: u64,
    },

    /// Create an account with the DesignatedDealer role at `addr` with authentication key
    /// `auth_key_prefix` | `addr` and a 0 balance of type `Currency`. If `add_all_currencies` is true,
    /// 0 balances for all available currencies in the system will also be added. This can only be
    /// invoked by an account with the TreasuryCompliance role.
    CreateDesignatedDealer {
        currency: TypeTag,
        sliding_nonce: u64,
        addr: AccountAddress,
        auth_key_prefix: Bytes,
        human_name: Bytes,
        add_all_currencies: bool,
    },

    /// Create an account with the ParentVASP role at `address` with authentication key
    /// `auth_key_prefix` | `new_account_address` and a 0 balance of type `currency`. If
    /// `add_all_currencies` is true, 0 balances for all available currencies in the system will
    /// also be added. This can only be invoked by an TreasuryCompliance account.
    /// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
    CreateParentVaspAccount {
        coin_type: TypeTag,
        sliding_nonce: u64,
        new_account_address: AccountAddress,
        auth_key_prefix: Bytes,
        human_name: Bytes,
        add_all_currencies: bool,
    },

    /// Extract the `KeyRotationCapability` for `recovery_account` and publish it in a
    /// `RecoveryAddress` resource under  `account`.
    /// ## Aborts
    /// * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if `account` has already delegated its `KeyRotationCapability`.
    /// * Aborts with `RecoveryAddress::ENOT_A_VASP` if `account` is not a ParentVASP or ChildVASP
    CreateRecoveryAddress {},

    /// Create a validator account at `new_validator_address` with `auth_key_prefix`and human_name.
    CreateValidatorAccount {
        sliding_nonce: u64,
        new_account_address: AccountAddress,
        auth_key_prefix: Bytes,
        human_name: Bytes,
    },

    /// Create a validator operator account at `new_validator_address` with `auth_key_prefix`and human_name.
    CreateValidatorOperatorAccount {
        sliding_nonce: u64,
        new_account_address: AccountAddress,
        auth_key_prefix: Bytes,
        human_name: Bytes,
    },

    /// Freeze account `address`. Initiator must be authorized.
    /// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
    FreezeAccount {
        sliding_nonce: u64,
        to_freeze_account: AccountAddress,
    },

    /// Mint `amount_lbr` LBR from the sending account's constituent coins and deposits the
    /// resulting LBR into the sending account.
    ///
    /// # Events
    /// When this script executes without aborting, it emits three events:
    /// `SentPaymentEvent { amount_coin1, currency_code = Coin1, address_of(account), metadata = x"" }`
    /// `SentPaymentEvent { amount_coin2, currency_code = Coin2, address_of(account), metadata = x"" }`
    /// on `account`'s `LibraAccount::sent_events` handle where `amount_coin1` and `amount_coin2`
    /// are the components amounts of `amount_lbr` LBR, and
    /// `ReceivedPaymentEvent { amount_lbr, currency_code = LBR, address_of(account), metadata = x"" }`
    /// on `account`'s `LibraAccount::received_events` handle.
    ///
    /// # Abort Conditions
    /// > TODO(emmazzz): the documentation below documents the reasons of abort, instead of the categories.
    /// > We might want to discuss about what the best approach is here.
    /// The following abort conditions have been formally specified and verified. See spec schema
    /// `LibraAccount::StapleLBRAbortsIf` for the formal specifications.
    ///
    /// ## Aborts Caused by Invalid Account State
    /// * Aborts with `LibraAccount::EINSUFFICIENT_BALANCE` if `amount_coin1` is greater than sending
    /// `account`'s balance in `Coin1` or if `amount_coin2` is greater than sending `account`'s balance in `Coin2`.
    /// * Aborts with `LibraAccount::ECOIN_DEPOSIT_IS_ZERO` if `amount_lbr` is zero.
    /// * Aborts with `LibraAccount::EPAYEE_DOES_NOT_EXIST` if no LibraAccount exists at the address of `account`.
    /// * Aborts with `LibraAccount::EPAYEE_CANT_ACCEPT_CURRENCY_TYPE` if LibraAccount exists at `account`,
    /// but it does not accept payments in LBR.
    ///
    /// ## Aborts Caused by Invalid LBR Minting State
    /// * Aborts with `Libra::EMINTING_NOT_ALLOWED` if minting LBR is not allowed according to the CurrencyInfo<LBR>
    /// stored at `CURRENCY_INFO_ADDRESS`.
    /// * Aborts with `Libra::ECURRENCY_INFO` if the total value of LBR would reach `MAX_U128` after `amount_lbr`
    /// LBR is minted.
    ///
    /// ## Other Aborts
    /// These aborts should only happen when `account` has account limit restrictions or
    /// has been frozen by Libra administrators.
    /// * Aborts with `LibraAccount::EWITHDRAWAL_EXCEEDS_LIMITS` if `account` has exceeded their daily
    /// withdrawal limits for Coin1 or Coin2.
    /// * Aborts with `LibraAccount::EDEPOSIT_EXCEEDS_LIMITS` if `account` has exceeded their daily
    /// deposit limits for LBR.
    /// * Aborts with `LibraAccount::EACCOUNT_FROZEN` if `account` is frozen.
    ///
    /// # Post Conditions
    /// The following post conditions have been formally specified and verified. See spec schema
    /// `LibraAccount::StapleLBREnsures` for the formal specifications.
    ///
    /// ## Changed States
    /// * The reserve backing for Coin1 and Coin2 increase by the right amounts as specified by the component ratio.
    /// * Coin1 and Coin2 balances at the address of sending `account` decrease by the right amounts as specified by
    /// the component ratio.
    /// * The total value of LBR increases by `amount_lbr`.
    /// * LBR balance at the address of sending `account` increases by `amount_lbr`.
    ///
    /// ## Unchanged States
    /// * The total values of Coin1 and Coin2 stay the same.
    MintLbr { amount_lbr: u64 },

    /// Transfer `amount` coins of type `Currency` from `payer` to `payee` with (optional) associated
    /// `metadata` and an (optional) `metadata_signature` on the message
    /// `metadata` | `Signer::address_of(payer)` | `amount` | `DualAttestation::DOMAIN_SEPARATOR`.
    /// The `metadata` and `metadata_signature` parameters are only required if `amount` >=
    /// `DualAttestation::get_cur_microlibra_limit` LBR and `payer` and `payee` are distinct VASPs.
    /// However, a transaction sender can opt in to dual attestation even when it is not required (e.g., a DesignatedDealer -> VASP payment) by providing a non-empty `metadata_signature`.
    /// Standardized `metadata` LCS format can be found in `libra_types::transaction::metadata::Metadata`.
    ///
    /// ## Events
    /// When this script executes without aborting, it emits two events:
    /// `SentPaymentEvent { amount, currency_code = Currency, payee, metadata }`
    /// on `payer`'s `LibraAccount::sent_events` handle, and
    ///  `ReceivedPaymentEvent { amount, currency_code = Currency, payer, metadata }`
    /// on `payee`'s `LibraAccount::received_events` handle.
    ///
    /// ## Common Aborts
    /// These aborts can in occur in any payment.
    /// * Aborts with `LibraAccount::EINSUFFICIENT_BALANCE` if `amount` is greater than `payer`'s balance in `Currency`.
    /// * Aborts with `LibraAccount::ECOIN_DEPOSIT_IS_ZERO` if `amount` is zero.
    /// * Aborts with `LibraAccount::EPAYEE_DOES_NOT_EXIST` if no account exists at the address `payee`.
    /// * Aborts with `LibraAccount::EPAYEE_CANT_ACCEPT_CURRENCY_TYPE` if an account exists at `payee`, but it does not accept payments in `Currency`.
    ///
    /// ## Dual Attestation Aborts
    /// These aborts can occur in any payment subject to dual attestation.
    /// * Aborts with `DualAttestation::EMALFORMED_METADATA_SIGNATURE` if `metadata_signature`'s is not 64 bytes.
    /// * Aborts with `DualAttestation:EINVALID_METADATA_SIGNATURE` if `metadata_signature` does not verify on the message `metadata` | `payer` | `value` | `DOMAIN_SEPARATOR` using the `compliance_public_key` published in the `payee`'s `DualAttestation::Credential` resource.
    ///
    /// ## Other Aborts
    /// These aborts should only happen when `payer` or `payee` have account limit restrictions or
    /// have been frozen by Libra administrators.
    /// * Aborts with `LibraAccount::EWITHDRAWAL_EXCEEDS_LIMITS` if `payer` has exceeded their daily
    /// withdrawal limits.
    /// * Aborts with `LibraAccount::EDEPOSIT_EXCEEDS_LIMITS` if `payee` has exceeded their daily deposit limits.
    /// * Aborts with `LibraAccount::EACCOUNT_FROZEN` if `payer`'s account is frozen.
    PeerToPeerWithMetadata {
        currency: TypeTag,
        payee: AccountAddress,
        amount: u64,
        metadata: Bytes,
        metadata_signature: Bytes,
    },

    /// Preburn `amount` `Token`s from `account`.
    /// This will only succeed if `account` already has a published `Preburn<Token>` resource.
    Preburn { token: TypeTag, amount: u64 },

    /// (1) Rotate the authentication key of the sender to `public_key`
    /// (2) Publish a resource containing a 32-byte ed25519 public key and the rotation capability
    ///     of the sender under the sender's address.
    /// Aborts if the sender already has a `SharedEd25519PublicKey` resource.
    /// Aborts if the length of `new_public_key` is not 32.
    PublishSharedEd25519PublicKey { public_key: Bytes },

    /// Set validator's config locally.
    /// Does not emit NewEpochEvent, the config is NOT changed in the validator set.
    RegisterValidatorConfig {
        validator_account: AccountAddress,
        consensus_pubkey: Bytes,
        validator_network_addresses: Bytes,
        fullnode_network_addresses: Bytes,
    },

    /// Removes a validator from the validator set.
    /// Fails if the validator_address is not in the validator set.
    /// Emits a NewEpochEvent.
    RemoveValidatorAndReconfigure {
        sliding_nonce: u64,
        validator_name: Bytes,
        validator_address: AccountAddress,
    },

    /// Rotate the sender's authentication key to `new_key`.
    /// `new_key` should be a 256 bit sha3 hash of an ed25519 public key.
    /// * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if the `KeyRotationCapability` for `account` has already been extracted.
    /// * Aborts with `0` if the key rotation capability held by the account doesn't match the sender's address.
    /// * Aborts with `LibraAccount::EMALFORMED_AUTHENTICATION_KEY` if the length of `new_key` != 32.
    RotateAuthenticationKey { new_key: Bytes },

    /// Rotate `account`'s authentication key to `new_key`.
    /// `new_key` should be a 256 bit sha3 hash of an ed25519 public key. This script also takes
    /// `sliding_nonce`, as a unique nonce for this operation. See sliding_nonce.move for details.
    RotateAuthenticationKeyWithNonce { sliding_nonce: u64, new_key: Bytes },

    /// Rotate `account`'s authentication key to `new_key`.
    /// `new_key` should be a 256 bit sha3 hash of an ed25519 public key. This script also takes
    /// `sliding_nonce`, as a unique nonce for this operation. See sliding_nonce.move for details.
    RotateAuthenticationKeyWithNonceAdmin { sliding_nonce: u64, new_key: Bytes },

    /// Rotate the authentication key of `to_recover` to `new_key` using the `KeyRotationCapability`
    /// stored under `recovery_address`.
    ///
    /// ## Aborts
    /// * Aborts with `RecoveryAddress::ENOT_A_RECOVERY_ADDRESS` if `recovery_address` does not have a `RecoveryAddress` resource
    /// * Aborts with `RecoveryAddress::ECANNOT_ROTATE_KEY` if `account` is not `recovery_address` or `to_recover`.
    /// * Aborts with `LibraAccount::EMALFORMED_AUTHENTICATION_KEY` if `new_key` is not 32 bytes.
    /// * Aborts with `RecoveryAddress::ECANNOT_ROTATE_KEY` if `account` has not delegated its `KeyRotationCapability` to `recovery_address`.
    RotateAuthenticationKeyWithRecoveryAddress {
        recovery_address: AccountAddress,
        to_recover: AccountAddress,
        new_key: Bytes,
    },

    /// Rotate `account`'s base URL to `new_url` and its compliance public key to `new_key`.
    /// Aborts if `account` is not a ParentVASP or DesignatedDealer
    /// Aborts if `new_key` is not a well-formed public key
    RotateDualAttestationInfo { new_url: Bytes, new_key: Bytes },

    /// (1) Rotate the public key stored in `account`'s `SharedEd25519PublicKey` resource to
    /// `new_public_key`
    /// (2) Rotate the authentication key using the capability stored in `account`'s
    /// `SharedEd25519PublicKey` to a new value derived from `new_public_key`
    /// Aborts if `account` does not have a `SharedEd25519PublicKey` resource.
    /// Aborts if the length of `new_public_key` is not 32.
    RotateSharedEd25519PublicKey { public_key: Bytes },

    /// Set validator's config and updates the config in the validator set.
    /// NewEpochEvent is emitted.
    SetValidatorConfigAndReconfigure {
        validator_account: AccountAddress,
        consensus_pubkey: Bytes,
        validator_network_addresses: Bytes,
        fullnode_network_addresses: Bytes,
    },

    /// Set validator's operator
    SetValidatorOperator {
        operator_name: Bytes,
        operator_account: AccountAddress,
    },

    /// Set validator operator as 'operator_account' of validator owner 'account' (via Admin Script).
    /// `operator_name` should match expected from operator account. This script also
    /// takes `sliding_nonce`, as a unique nonce for this operation. See `Sliding_nonce.move` for details.
    SetValidatorOperatorWithNonceAdmin {
        sliding_nonce: u64,
        operator_name: Bytes,
        operator_account: AccountAddress,
    },

    /// Mint `mint_amount` to `designated_dealer_address` for `tier_index` tier.
    /// Max valid tier index is 3 since there are max 4 tiers per DD.
    /// Sender should be treasury compliance account and receiver authorized DD.
    /// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
    TieredMint {
        coin_type: TypeTag,
        sliding_nonce: u64,
        designated_dealer_address: AccountAddress,
        mint_amount: u64,
        tier_index: u64,
    },

    /// Unfreeze account `address`. Initiator must be authorized.
    /// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
    UnfreezeAccount {
        sliding_nonce: u64,
        to_unfreeze_account: AccountAddress,
    },

    /// Unmints `amount_lbr` LBR from the sending account into the constituent coins and deposits
    /// the resulting coins into the sending account.
    UnmintLbr { amount_lbr: u64 },

    /// Update the dual attesation limit to `new_micro_lbr_limit`.
    UpdateDualAttestationLimit {
        sliding_nonce: u64,
        new_micro_lbr_limit: u64,
    },

    /// Update the on-chain exchange rate to LBR for the given `currency` to be given by
    /// `new_exchange_rate_numerator/new_exchange_rate_denominator`.
    UpdateExchangeRate {
        currency: TypeTag,
        sliding_nonce: u64,
        new_exchange_rate_numerator: u64,
        new_exchange_rate_denominator: u64,
    },

    /// Update Libra version.
    /// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
    UpdateLibraVersion { sliding_nonce: u64, major: u64 },

    /// Allows--true--or disallows--false--minting of `currency` based upon `allow_minting`.
    UpdateMintingAbility {
        currency: TypeTag,
        allow_minting: bool,
    },
}

impl ScriptCall {
    /// Build a Libra `Script` from a structured object `ScriptCall`.
    pub fn encode(self) -> Script {
        use ScriptCall::*;
        match self {
            AddCurrencyToAccount { currency } => encode_add_currency_to_account_script(currency),
            AddRecoveryRotationCapability { recovery_address } => {
                encode_add_recovery_rotation_capability_script(recovery_address)
            }
            AddToScriptAllowList {
                hash,
                sliding_nonce,
            } => encode_add_to_script_allow_list_script(hash, sliding_nonce),
            AddValidatorAndReconfigure {
                sliding_nonce,
                validator_name,
                validator_address,
            } => encode_add_validator_and_reconfigure_script(
                sliding_nonce,
                validator_name,
                validator_address,
            ),
            Burn {
                token,
                sliding_nonce,
                preburn_address,
            } => encode_burn_script(token, sliding_nonce, preburn_address),
            BurnTxnFees { coin_type } => encode_burn_txn_fees_script(coin_type),
            CancelBurn {
                token,
                preburn_address,
            } => encode_cancel_burn_script(token, preburn_address),
            CreateChildVaspAccount {
                coin_type,
                child_address,
                auth_key_prefix,
                add_all_currencies,
                child_initial_balance,
            } => encode_create_child_vasp_account_script(
                coin_type,
                child_address,
                auth_key_prefix,
                add_all_currencies,
                child_initial_balance,
            ),
            CreateDesignatedDealer {
                currency,
                sliding_nonce,
                addr,
                auth_key_prefix,
                human_name,
                add_all_currencies,
            } => encode_create_designated_dealer_script(
                currency,
                sliding_nonce,
                addr,
                auth_key_prefix,
                human_name,
                add_all_currencies,
            ),
            CreateParentVaspAccount {
                coin_type,
                sliding_nonce,
                new_account_address,
                auth_key_prefix,
                human_name,
                add_all_currencies,
            } => encode_create_parent_vasp_account_script(
                coin_type,
                sliding_nonce,
                new_account_address,
                auth_key_prefix,
                human_name,
                add_all_currencies,
            ),
            CreateRecoveryAddress {} => encode_create_recovery_address_script(),
            CreateValidatorAccount {
                sliding_nonce,
                new_account_address,
                auth_key_prefix,
                human_name,
            } => encode_create_validator_account_script(
                sliding_nonce,
                new_account_address,
                auth_key_prefix,
                human_name,
            ),
            CreateValidatorOperatorAccount {
                sliding_nonce,
                new_account_address,
                auth_key_prefix,
                human_name,
            } => encode_create_validator_operator_account_script(
                sliding_nonce,
                new_account_address,
                auth_key_prefix,
                human_name,
            ),
            FreezeAccount {
                sliding_nonce,
                to_freeze_account,
            } => encode_freeze_account_script(sliding_nonce, to_freeze_account),
            MintLbr { amount_lbr } => encode_mint_lbr_script(amount_lbr),
            PeerToPeerWithMetadata {
                currency,
                payee,
                amount,
                metadata,
                metadata_signature,
            } => encode_peer_to_peer_with_metadata_script(
                currency,
                payee,
                amount,
                metadata,
                metadata_signature,
            ),
            Preburn { token, amount } => encode_preburn_script(token, amount),
            PublishSharedEd25519PublicKey { public_key } => {
                encode_publish_shared_ed25519_public_key_script(public_key)
            }
            RegisterValidatorConfig {
                validator_account,
                consensus_pubkey,
                validator_network_addresses,
                fullnode_network_addresses,
            } => encode_register_validator_config_script(
                validator_account,
                consensus_pubkey,
                validator_network_addresses,
                fullnode_network_addresses,
            ),
            RemoveValidatorAndReconfigure {
                sliding_nonce,
                validator_name,
                validator_address,
            } => encode_remove_validator_and_reconfigure_script(
                sliding_nonce,
                validator_name,
                validator_address,
            ),
            RotateAuthenticationKey { new_key } => encode_rotate_authentication_key_script(new_key),
            RotateAuthenticationKeyWithNonce {
                sliding_nonce,
                new_key,
            } => encode_rotate_authentication_key_with_nonce_script(sliding_nonce, new_key),
            RotateAuthenticationKeyWithNonceAdmin {
                sliding_nonce,
                new_key,
            } => encode_rotate_authentication_key_with_nonce_admin_script(sliding_nonce, new_key),
            RotateAuthenticationKeyWithRecoveryAddress {
                recovery_address,
                to_recover,
                new_key,
            } => encode_rotate_authentication_key_with_recovery_address_script(
                recovery_address,
                to_recover,
                new_key,
            ),
            RotateDualAttestationInfo { new_url, new_key } => {
                encode_rotate_dual_attestation_info_script(new_url, new_key)
            }
            RotateSharedEd25519PublicKey { public_key } => {
                encode_rotate_shared_ed25519_public_key_script(public_key)
            }
            SetValidatorConfigAndReconfigure {
                validator_account,
                consensus_pubkey,
                validator_network_addresses,
                fullnode_network_addresses,
            } => encode_set_validator_config_and_reconfigure_script(
                validator_account,
                consensus_pubkey,
                validator_network_addresses,
                fullnode_network_addresses,
            ),
            SetValidatorOperator {
                operator_name,
                operator_account,
            } => encode_set_validator_operator_script(operator_name, operator_account),
            SetValidatorOperatorWithNonceAdmin {
                sliding_nonce,
                operator_name,
                operator_account,
            } => encode_set_validator_operator_with_nonce_admin_script(
                sliding_nonce,
                operator_name,
                operator_account,
            ),
            TieredMint {
                coin_type,
                sliding_nonce,
                designated_dealer_address,
                mint_amount,
                tier_index,
            } => encode_tiered_mint_script(
                coin_type,
                sliding_nonce,
                designated_dealer_address,
                mint_amount,
                tier_index,
            ),
            UnfreezeAccount {
                sliding_nonce,
                to_unfreeze_account,
            } => encode_unfreeze_account_script(sliding_nonce, to_unfreeze_account),
            UnmintLbr { amount_lbr } => encode_unmint_lbr_script(amount_lbr),
            UpdateDualAttestationLimit {
                sliding_nonce,
                new_micro_lbr_limit,
            } => encode_update_dual_attestation_limit_script(sliding_nonce, new_micro_lbr_limit),
            UpdateExchangeRate {
                currency,
                sliding_nonce,
                new_exchange_rate_numerator,
                new_exchange_rate_denominator,
            } => encode_update_exchange_rate_script(
                currency,
                sliding_nonce,
                new_exchange_rate_numerator,
                new_exchange_rate_denominator,
            ),
            UpdateLibraVersion {
                sliding_nonce,
                major,
            } => encode_update_libra_version_script(sliding_nonce, major),
            UpdateMintingAbility {
                currency,
                allow_minting,
            } => encode_update_minting_ability_script(currency, allow_minting),
        }
    }

    /// Try to recognize a Libra `Script` and convert it into a structured object `ScriptCall`.
    pub fn decode(script: &Script) -> Option<ScriptCall> {
        match SCRIPT_DECODER_MAP.get(script.code()) {
            Some(decoder) => decoder(script),
            None => None,
        }
    }
}

/// Add a `Currency` balance to `account`, which will enable `account` to send and receive
/// `Libra<Currency>`.
/// Aborts with NOT_A_CURRENCY if `Currency` is not an accepted currency type in the Libra system
/// Aborts with `LibraAccount::ADD_EXISTING_CURRENCY` if the account already holds a balance in
/// `Currency`.
pub fn encode_add_currency_to_account_script(currency: TypeTag) -> Script {
    Script::new(
        ADD_CURRENCY_TO_ACCOUNT_CODE.to_vec(),
        vec![currency],
        vec![],
    )
}

/// Add the `KeyRotationCapability` for `to_recover_account` to the `RecoveryAddress` resource under `recovery_address`.
///
/// ## Aborts
/// * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if `account` has already delegated its `KeyRotationCapability`.
/// * Aborts with `RecoveryAddress:ENOT_A_RECOVERY_ADDRESS` if `recovery_address` does not have a `RecoveryAddress` resource.
/// * Aborts with `RecoveryAddress::EINVALID_KEY_ROTATION_DELEGATION` if `to_recover_account` and `recovery_address` do not belong to the same VASP.
pub fn encode_add_recovery_rotation_capability_script(recovery_address: AccountAddress) -> Script {
    Script::new(
        ADD_RECOVERY_ROTATION_CAPABILITY_CODE.to_vec(),
        vec![],
        vec![TransactionArgument::Address(recovery_address)],
    )
}

/// Append the `hash` to script hashes list allowed to be executed by the network.
pub fn encode_add_to_script_allow_list_script(hash: Vec<u8>, sliding_nonce: u64) -> Script {
    Script::new(
        ADD_TO_SCRIPT_ALLOW_LIST_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U8Vector(hash),
            TransactionArgument::U64(sliding_nonce),
        ],
    )
}

/// Add `new_validator` to the validator set.
/// Fails if the `new_validator` address is already in the validator set
/// or does not have a `ValidatorConfig` resource stored at the address.
/// Emits a NewEpochEvent.
pub fn encode_add_validator_and_reconfigure_script(
    sliding_nonce: u64,
    validator_name: Vec<u8>,
    validator_address: AccountAddress,
) -> Script {
    Script::new(
        ADD_VALIDATOR_AND_RECONFIGURE_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U8Vector(validator_name),
            TransactionArgument::Address(validator_address),
        ],
    )
}

/// Permanently destroy the `Token`s stored in the oldest burn request under the `Preburn` resource.
/// This will only succeed if `account` has a `MintCapability<Token>`, a `Preburn<Token>` resource
/// exists under `preburn_address`, and there is a pending burn request.
/// sliding_nonce is a unique nonce for operation, see sliding_nonce.move for details
pub fn encode_burn_script(
    token: TypeTag,
    sliding_nonce: u64,
    preburn_address: AccountAddress,
) -> Script {
    Script::new(
        BURN_CODE.to_vec(),
        vec![token],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(preburn_address),
        ],
    )
}

/// Burn transaction fees that have been collected in the given `currency`
/// and relinquish to the association. The currency must be non-synthetic.
pub fn encode_burn_txn_fees_script(coin_type: TypeTag) -> Script {
    Script::new(BURN_TXN_FEES_CODE.to_vec(), vec![coin_type], vec![])
}

/// Cancel the oldest burn request from `preburn_address` and return the funds.
/// Fails if the sender does not have a published `BurnCapability<Token>`.
pub fn encode_cancel_burn_script(token: TypeTag, preburn_address: AccountAddress) -> Script {
    Script::new(
        CANCEL_BURN_CODE.to_vec(),
        vec![token],
        vec![TransactionArgument::Address(preburn_address)],
    )
}

/// Create a `ChildVASP` account for sender `parent_vasp` at `child_address` with a balance of
/// `child_initial_balance` in `CoinType` and an initial authentication_key
/// `auth_key_prefix | child_address`.
/// If `add_all_currencies` is true, the child address will have a zero balance in all available
/// currencies in the system.
/// This account will a child of the transaction sender, which must be a ParentVASP.
///
/// ## Aborts
/// The transaction will abort:
///
/// * If `parent_vasp` is not a parent vasp with error: `Roles::EINVALID_PARENT_ROLE`
/// * If `child_address` already exists with error: `Roles::EROLE_ALREADY_ASSIGNED`
/// * If `parent_vasp` already has 256 child accounts with error: `VASP::ETOO_MANY_CHILDREN`
/// * If `CoinType` is not a registered currency with error: `LibraAccount::ENOT_A_CURRENCY`
/// * If `parent_vasp`'s withdrawal capability has been extracted with error:  `LibraAccount::EWITHDRAWAL_CAPABILITY_ALREADY_EXTRACTED`
/// * If `parent_vasp` doesn't hold `CoinType` and `child_initial_balance > 0` with error: `LibraAccount::EPAYER_DOESNT_HOLD_CURRENCY`
/// * If `parent_vasp` doesn't at least `child_initial_balance` of `CoinType` in its account balance with error: `LibraAccount::EINSUFFICIENT_BALANCE`
pub fn encode_create_child_vasp_account_script(
    coin_type: TypeTag,
    child_address: AccountAddress,
    auth_key_prefix: Vec<u8>,
    add_all_currencies: bool,
    child_initial_balance: u64,
) -> Script {
    Script::new(
        CREATE_CHILD_VASP_ACCOUNT_CODE.to_vec(),
        vec![coin_type],
        vec![
            TransactionArgument::Address(child_address),
            TransactionArgument::U8Vector(auth_key_prefix),
            TransactionArgument::Bool(add_all_currencies),
            TransactionArgument::U64(child_initial_balance),
        ],
    )
}

/// Create an account with the DesignatedDealer role at `addr` with authentication key
/// `auth_key_prefix` | `addr` and a 0 balance of type `Currency`. If `add_all_currencies` is true,
/// 0 balances for all available currencies in the system will also be added. This can only be
/// invoked by an account with the TreasuryCompliance role.
pub fn encode_create_designated_dealer_script(
    currency: TypeTag,
    sliding_nonce: u64,
    addr: AccountAddress,
    auth_key_prefix: Vec<u8>,
    human_name: Vec<u8>,
    add_all_currencies: bool,
) -> Script {
    Script::new(
        CREATE_DESIGNATED_DEALER_CODE.to_vec(),
        vec![currency],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(addr),
            TransactionArgument::U8Vector(auth_key_prefix),
            TransactionArgument::U8Vector(human_name),
            TransactionArgument::Bool(add_all_currencies),
        ],
    )
}

/// Create an account with the ParentVASP role at `address` with authentication key
/// `auth_key_prefix` | `new_account_address` and a 0 balance of type `currency`. If
/// `add_all_currencies` is true, 0 balances for all available currencies in the system will
/// also be added. This can only be invoked by an TreasuryCompliance account.
/// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
pub fn encode_create_parent_vasp_account_script(
    coin_type: TypeTag,
    sliding_nonce: u64,
    new_account_address: AccountAddress,
    auth_key_prefix: Vec<u8>,
    human_name: Vec<u8>,
    add_all_currencies: bool,
) -> Script {
    Script::new(
        CREATE_PARENT_VASP_ACCOUNT_CODE.to_vec(),
        vec![coin_type],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(new_account_address),
            TransactionArgument::U8Vector(auth_key_prefix),
            TransactionArgument::U8Vector(human_name),
            TransactionArgument::Bool(add_all_currencies),
        ],
    )
}

/// Extract the `KeyRotationCapability` for `recovery_account` and publish it in a
/// `RecoveryAddress` resource under  `account`.
/// ## Aborts
/// * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if `account` has already delegated its `KeyRotationCapability`.
/// * Aborts with `RecoveryAddress::ENOT_A_VASP` if `account` is not a ParentVASP or ChildVASP
pub fn encode_create_recovery_address_script() -> Script {
    Script::new(CREATE_RECOVERY_ADDRESS_CODE.to_vec(), vec![], vec![])
}

/// Create a validator account at `new_validator_address` with `auth_key_prefix`and human_name.
pub fn encode_create_validator_account_script(
    sliding_nonce: u64,
    new_account_address: AccountAddress,
    auth_key_prefix: Vec<u8>,
    human_name: Vec<u8>,
) -> Script {
    Script::new(
        CREATE_VALIDATOR_ACCOUNT_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(new_account_address),
            TransactionArgument::U8Vector(auth_key_prefix),
            TransactionArgument::U8Vector(human_name),
        ],
    )
}

/// Create a validator operator account at `new_validator_address` with `auth_key_prefix`and human_name.
pub fn encode_create_validator_operator_account_script(
    sliding_nonce: u64,
    new_account_address: AccountAddress,
    auth_key_prefix: Vec<u8>,
    human_name: Vec<u8>,
) -> Script {
    Script::new(
        CREATE_VALIDATOR_OPERATOR_ACCOUNT_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(new_account_address),
            TransactionArgument::U8Vector(auth_key_prefix),
            TransactionArgument::U8Vector(human_name),
        ],
    )
}

/// Freeze account `address`. Initiator must be authorized.
/// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
pub fn encode_freeze_account_script(
    sliding_nonce: u64,
    to_freeze_account: AccountAddress,
) -> Script {
    Script::new(
        FREEZE_ACCOUNT_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(to_freeze_account),
        ],
    )
}

/// Mint `amount_lbr` LBR from the sending account's constituent coins and deposits the
/// resulting LBR into the sending account.
///
/// # Events
/// When this script executes without aborting, it emits three events:
/// `SentPaymentEvent { amount_coin1, currency_code = Coin1, address_of(account), metadata = x"" }`
/// `SentPaymentEvent { amount_coin2, currency_code = Coin2, address_of(account), metadata = x"" }`
/// on `account`'s `LibraAccount::sent_events` handle where `amount_coin1` and `amount_coin2`
/// are the components amounts of `amount_lbr` LBR, and
/// `ReceivedPaymentEvent { amount_lbr, currency_code = LBR, address_of(account), metadata = x"" }`
/// on `account`'s `LibraAccount::received_events` handle.
///
/// # Abort Conditions
/// > TODO(emmazzz): the documentation below documents the reasons of abort, instead of the categories.
/// > We might want to discuss about what the best approach is here.
/// The following abort conditions have been formally specified and verified. See spec schema
/// `LibraAccount::StapleLBRAbortsIf` for the formal specifications.
///
/// ## Aborts Caused by Invalid Account State
/// * Aborts with `LibraAccount::EINSUFFICIENT_BALANCE` if `amount_coin1` is greater than sending
/// `account`'s balance in `Coin1` or if `amount_coin2` is greater than sending `account`'s balance in `Coin2`.
/// * Aborts with `LibraAccount::ECOIN_DEPOSIT_IS_ZERO` if `amount_lbr` is zero.
/// * Aborts with `LibraAccount::EPAYEE_DOES_NOT_EXIST` if no LibraAccount exists at the address of `account`.
/// * Aborts with `LibraAccount::EPAYEE_CANT_ACCEPT_CURRENCY_TYPE` if LibraAccount exists at `account`,
/// but it does not accept payments in LBR.
///
/// ## Aborts Caused by Invalid LBR Minting State
/// * Aborts with `Libra::EMINTING_NOT_ALLOWED` if minting LBR is not allowed according to the CurrencyInfo<LBR>
/// stored at `CURRENCY_INFO_ADDRESS`.
/// * Aborts with `Libra::ECURRENCY_INFO` if the total value of LBR would reach `MAX_U128` after `amount_lbr`
/// LBR is minted.
///
/// ## Other Aborts
/// These aborts should only happen when `account` has account limit restrictions or
/// has been frozen by Libra administrators.
/// * Aborts with `LibraAccount::EWITHDRAWAL_EXCEEDS_LIMITS` if `account` has exceeded their daily
/// withdrawal limits for Coin1 or Coin2.
/// * Aborts with `LibraAccount::EDEPOSIT_EXCEEDS_LIMITS` if `account` has exceeded their daily
/// deposit limits for LBR.
/// * Aborts with `LibraAccount::EACCOUNT_FROZEN` if `account` is frozen.
///
/// # Post Conditions
/// The following post conditions have been formally specified and verified. See spec schema
/// `LibraAccount::StapleLBREnsures` for the formal specifications.
///
/// ## Changed States
/// * The reserve backing for Coin1 and Coin2 increase by the right amounts as specified by the component ratio.
/// * Coin1 and Coin2 balances at the address of sending `account` decrease by the right amounts as specified by
/// the component ratio.
/// * The total value of LBR increases by `amount_lbr`.
/// * LBR balance at the address of sending `account` increases by `amount_lbr`.
///
/// ## Unchanged States
/// * The total values of Coin1 and Coin2 stay the same.
pub fn encode_mint_lbr_script(amount_lbr: u64) -> Script {
    Script::new(
        MINT_LBR_CODE.to_vec(),
        vec![],
        vec![TransactionArgument::U64(amount_lbr)],
    )
}

/// Transfer `amount` coins of type `Currency` from `payer` to `payee` with (optional) associated
/// `metadata` and an (optional) `metadata_signature` on the message
/// `metadata` | `Signer::address_of(payer)` | `amount` | `DualAttestation::DOMAIN_SEPARATOR`.
/// The `metadata` and `metadata_signature` parameters are only required if `amount` >=
/// `DualAttestation::get_cur_microlibra_limit` LBR and `payer` and `payee` are distinct VASPs.
/// However, a transaction sender can opt in to dual attestation even when it is not required (e.g., a DesignatedDealer -> VASP payment) by providing a non-empty `metadata_signature`.
/// Standardized `metadata` LCS format can be found in `libra_types::transaction::metadata::Metadata`.
///
/// ## Events
/// When this script executes without aborting, it emits two events:
/// `SentPaymentEvent { amount, currency_code = Currency, payee, metadata }`
/// on `payer`'s `LibraAccount::sent_events` handle, and
///  `ReceivedPaymentEvent { amount, currency_code = Currency, payer, metadata }`
/// on `payee`'s `LibraAccount::received_events` handle.
///
/// ## Common Aborts
/// These aborts can in occur in any payment.
/// * Aborts with `LibraAccount::EINSUFFICIENT_BALANCE` if `amount` is greater than `payer`'s balance in `Currency`.
/// * Aborts with `LibraAccount::ECOIN_DEPOSIT_IS_ZERO` if `amount` is zero.
/// * Aborts with `LibraAccount::EPAYEE_DOES_NOT_EXIST` if no account exists at the address `payee`.
/// * Aborts with `LibraAccount::EPAYEE_CANT_ACCEPT_CURRENCY_TYPE` if an account exists at `payee`, but it does not accept payments in `Currency`.
///
/// ## Dual Attestation Aborts
/// These aborts can occur in any payment subject to dual attestation.
/// * Aborts with `DualAttestation::EMALFORMED_METADATA_SIGNATURE` if `metadata_signature`'s is not 64 bytes.
/// * Aborts with `DualAttestation:EINVALID_METADATA_SIGNATURE` if `metadata_signature` does not verify on the message `metadata` | `payer` | `value` | `DOMAIN_SEPARATOR` using the `compliance_public_key` published in the `payee`'s `DualAttestation::Credential` resource.
///
/// ## Other Aborts
/// These aborts should only happen when `payer` or `payee` have account limit restrictions or
/// have been frozen by Libra administrators.
/// * Aborts with `LibraAccount::EWITHDRAWAL_EXCEEDS_LIMITS` if `payer` has exceeded their daily
/// withdrawal limits.
/// * Aborts with `LibraAccount::EDEPOSIT_EXCEEDS_LIMITS` if `payee` has exceeded their daily deposit limits.
/// * Aborts with `LibraAccount::EACCOUNT_FROZEN` if `payer`'s account is frozen.
pub fn encode_peer_to_peer_with_metadata_script(
    currency: TypeTag,
    payee: AccountAddress,
    amount: u64,
    metadata: Vec<u8>,
    metadata_signature: Vec<u8>,
) -> Script {
    Script::new(
        PEER_TO_PEER_WITH_METADATA_CODE.to_vec(),
        vec![currency],
        vec![
            TransactionArgument::Address(payee),
            TransactionArgument::U64(amount),
            TransactionArgument::U8Vector(metadata),
            TransactionArgument::U8Vector(metadata_signature),
        ],
    )
}

/// Preburn `amount` `Token`s from `account`.
/// This will only succeed if `account` already has a published `Preburn<Token>` resource.
pub fn encode_preburn_script(token: TypeTag, amount: u64) -> Script {
    Script::new(
        PREBURN_CODE.to_vec(),
        vec![token],
        vec![TransactionArgument::U64(amount)],
    )
}

/// (1) Rotate the authentication key of the sender to `public_key`
/// (2) Publish a resource containing a 32-byte ed25519 public key and the rotation capability
///     of the sender under the sender's address.
/// Aborts if the sender already has a `SharedEd25519PublicKey` resource.
/// Aborts if the length of `new_public_key` is not 32.
pub fn encode_publish_shared_ed25519_public_key_script(public_key: Vec<u8>) -> Script {
    Script::new(
        PUBLISH_SHARED_ED25519_PUBLIC_KEY_CODE.to_vec(),
        vec![],
        vec![TransactionArgument::U8Vector(public_key)],
    )
}

/// Set validator's config locally.
/// Does not emit NewEpochEvent, the config is NOT changed in the validator set.
pub fn encode_register_validator_config_script(
    validator_account: AccountAddress,
    consensus_pubkey: Vec<u8>,
    validator_network_addresses: Vec<u8>,
    fullnode_network_addresses: Vec<u8>,
) -> Script {
    Script::new(
        REGISTER_VALIDATOR_CONFIG_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::Address(validator_account),
            TransactionArgument::U8Vector(consensus_pubkey),
            TransactionArgument::U8Vector(validator_network_addresses),
            TransactionArgument::U8Vector(fullnode_network_addresses),
        ],
    )
}

/// Removes a validator from the validator set.
/// Fails if the validator_address is not in the validator set.
/// Emits a NewEpochEvent.
pub fn encode_remove_validator_and_reconfigure_script(
    sliding_nonce: u64,
    validator_name: Vec<u8>,
    validator_address: AccountAddress,
) -> Script {
    Script::new(
        REMOVE_VALIDATOR_AND_RECONFIGURE_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U8Vector(validator_name),
            TransactionArgument::Address(validator_address),
        ],
    )
}

/// Rotate the sender's authentication key to `new_key`.
/// `new_key` should be a 256 bit sha3 hash of an ed25519 public key.
/// * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if the `KeyRotationCapability` for `account` has already been extracted.
/// * Aborts with `0` if the key rotation capability held by the account doesn't match the sender's address.
/// * Aborts with `LibraAccount::EMALFORMED_AUTHENTICATION_KEY` if the length of `new_key` != 32.
pub fn encode_rotate_authentication_key_script(new_key: Vec<u8>) -> Script {
    Script::new(
        ROTATE_AUTHENTICATION_KEY_CODE.to_vec(),
        vec![],
        vec![TransactionArgument::U8Vector(new_key)],
    )
}

/// Rotate `account`'s authentication key to `new_key`.
/// `new_key` should be a 256 bit sha3 hash of an ed25519 public key. This script also takes
/// `sliding_nonce`, as a unique nonce for this operation. See sliding_nonce.move for details.
pub fn encode_rotate_authentication_key_with_nonce_script(
    sliding_nonce: u64,
    new_key: Vec<u8>,
) -> Script {
    Script::new(
        ROTATE_AUTHENTICATION_KEY_WITH_NONCE_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U8Vector(new_key),
        ],
    )
}

/// Rotate `account`'s authentication key to `new_key`.
/// `new_key` should be a 256 bit sha3 hash of an ed25519 public key. This script also takes
/// `sliding_nonce`, as a unique nonce for this operation. See sliding_nonce.move for details.
pub fn encode_rotate_authentication_key_with_nonce_admin_script(
    sliding_nonce: u64,
    new_key: Vec<u8>,
) -> Script {
    Script::new(
        ROTATE_AUTHENTICATION_KEY_WITH_NONCE_ADMIN_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U8Vector(new_key),
        ],
    )
}

/// Rotate the authentication key of `to_recover` to `new_key` using the `KeyRotationCapability`
/// stored under `recovery_address`.
///
/// ## Aborts
/// * Aborts with `RecoveryAddress::ENOT_A_RECOVERY_ADDRESS` if `recovery_address` does not have a `RecoveryAddress` resource
/// * Aborts with `RecoveryAddress::ECANNOT_ROTATE_KEY` if `account` is not `recovery_address` or `to_recover`.
/// * Aborts with `LibraAccount::EMALFORMED_AUTHENTICATION_KEY` if `new_key` is not 32 bytes.
/// * Aborts with `RecoveryAddress::ECANNOT_ROTATE_KEY` if `account` has not delegated its `KeyRotationCapability` to `recovery_address`.
pub fn encode_rotate_authentication_key_with_recovery_address_script(
    recovery_address: AccountAddress,
    to_recover: AccountAddress,
    new_key: Vec<u8>,
) -> Script {
    Script::new(
        ROTATE_AUTHENTICATION_KEY_WITH_RECOVERY_ADDRESS_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::Address(recovery_address),
            TransactionArgument::Address(to_recover),
            TransactionArgument::U8Vector(new_key),
        ],
    )
}

/// Rotate `account`'s base URL to `new_url` and its compliance public key to `new_key`.
/// Aborts if `account` is not a ParentVASP or DesignatedDealer
/// Aborts if `new_key` is not a well-formed public key
pub fn encode_rotate_dual_attestation_info_script(new_url: Vec<u8>, new_key: Vec<u8>) -> Script {
    Script::new(
        ROTATE_DUAL_ATTESTATION_INFO_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U8Vector(new_url),
            TransactionArgument::U8Vector(new_key),
        ],
    )
}

/// (1) Rotate the public key stored in `account`'s `SharedEd25519PublicKey` resource to
/// `new_public_key`
/// (2) Rotate the authentication key using the capability stored in `account`'s
/// `SharedEd25519PublicKey` to a new value derived from `new_public_key`
/// Aborts if `account` does not have a `SharedEd25519PublicKey` resource.
/// Aborts if the length of `new_public_key` is not 32.
pub fn encode_rotate_shared_ed25519_public_key_script(public_key: Vec<u8>) -> Script {
    Script::new(
        ROTATE_SHARED_ED25519_PUBLIC_KEY_CODE.to_vec(),
        vec![],
        vec![TransactionArgument::U8Vector(public_key)],
    )
}

/// Set validator's config and updates the config in the validator set.
/// NewEpochEvent is emitted.
pub fn encode_set_validator_config_and_reconfigure_script(
    validator_account: AccountAddress,
    consensus_pubkey: Vec<u8>,
    validator_network_addresses: Vec<u8>,
    fullnode_network_addresses: Vec<u8>,
) -> Script {
    Script::new(
        SET_VALIDATOR_CONFIG_AND_RECONFIGURE_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::Address(validator_account),
            TransactionArgument::U8Vector(consensus_pubkey),
            TransactionArgument::U8Vector(validator_network_addresses),
            TransactionArgument::U8Vector(fullnode_network_addresses),
        ],
    )
}

/// Set validator's operator
pub fn encode_set_validator_operator_script(
    operator_name: Vec<u8>,
    operator_account: AccountAddress,
) -> Script {
    Script::new(
        SET_VALIDATOR_OPERATOR_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U8Vector(operator_name),
            TransactionArgument::Address(operator_account),
        ],
    )
}

/// Set validator operator as 'operator_account' of validator owner 'account' (via Admin Script).
/// `operator_name` should match expected from operator account. This script also
/// takes `sliding_nonce`, as a unique nonce for this operation. See `Sliding_nonce.move` for details.
pub fn encode_set_validator_operator_with_nonce_admin_script(
    sliding_nonce: u64,
    operator_name: Vec<u8>,
    operator_account: AccountAddress,
) -> Script {
    Script::new(
        SET_VALIDATOR_OPERATOR_WITH_NONCE_ADMIN_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U8Vector(operator_name),
            TransactionArgument::Address(operator_account),
        ],
    )
}

/// Mint `mint_amount` to `designated_dealer_address` for `tier_index` tier.
/// Max valid tier index is 3 since there are max 4 tiers per DD.
/// Sender should be treasury compliance account and receiver authorized DD.
/// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
pub fn encode_tiered_mint_script(
    coin_type: TypeTag,
    sliding_nonce: u64,
    designated_dealer_address: AccountAddress,
    mint_amount: u64,
    tier_index: u64,
) -> Script {
    Script::new(
        TIERED_MINT_CODE.to_vec(),
        vec![coin_type],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(designated_dealer_address),
            TransactionArgument::U64(mint_amount),
            TransactionArgument::U64(tier_index),
        ],
    )
}

/// Unfreeze account `address`. Initiator must be authorized.
/// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
pub fn encode_unfreeze_account_script(
    sliding_nonce: u64,
    to_unfreeze_account: AccountAddress,
) -> Script {
    Script::new(
        UNFREEZE_ACCOUNT_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::Address(to_unfreeze_account),
        ],
    )
}

/// Unmints `amount_lbr` LBR from the sending account into the constituent coins and deposits
/// the resulting coins into the sending account.
pub fn encode_unmint_lbr_script(amount_lbr: u64) -> Script {
    Script::new(
        UNMINT_LBR_CODE.to_vec(),
        vec![],
        vec![TransactionArgument::U64(amount_lbr)],
    )
}

/// Update the dual attesation limit to `new_micro_lbr_limit`.
pub fn encode_update_dual_attestation_limit_script(
    sliding_nonce: u64,
    new_micro_lbr_limit: u64,
) -> Script {
    Script::new(
        UPDATE_DUAL_ATTESTATION_LIMIT_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U64(new_micro_lbr_limit),
        ],
    )
}

/// Update the on-chain exchange rate to LBR for the given `currency` to be given by
/// `new_exchange_rate_numerator/new_exchange_rate_denominator`.
pub fn encode_update_exchange_rate_script(
    currency: TypeTag,
    sliding_nonce: u64,
    new_exchange_rate_numerator: u64,
    new_exchange_rate_denominator: u64,
) -> Script {
    Script::new(
        UPDATE_EXCHANGE_RATE_CODE.to_vec(),
        vec![currency],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U64(new_exchange_rate_numerator),
            TransactionArgument::U64(new_exchange_rate_denominator),
        ],
    )
}

/// Update Libra version.
/// `sliding_nonce` is a unique nonce for operation, see sliding_nonce.move for details.
pub fn encode_update_libra_version_script(sliding_nonce: u64, major: u64) -> Script {
    Script::new(
        UPDATE_LIBRA_VERSION_CODE.to_vec(),
        vec![],
        vec![
            TransactionArgument::U64(sliding_nonce),
            TransactionArgument::U64(major),
        ],
    )
}

/// Allows--true--or disallows--false--minting of `currency` based upon `allow_minting`.
pub fn encode_update_minting_ability_script(currency: TypeTag, allow_minting: bool) -> Script {
    Script::new(
        UPDATE_MINTING_ABILITY_CODE.to_vec(),
        vec![currency],
        vec![TransactionArgument::Bool(allow_minting)],
    )
}

fn decode_add_currency_to_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::AddCurrencyToAccount {
        currency: script.ty_args().get(0)?.clone(),
    })
}

fn decode_add_recovery_rotation_capability_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::AddRecoveryRotationCapability {
        recovery_address: decode_address_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_add_to_script_allow_list_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::AddToScriptAllowList {
        hash: decode_u8vector_argument(script.args().get(0)?.clone())?,
        sliding_nonce: decode_u64_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_add_validator_and_reconfigure_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::AddValidatorAndReconfigure {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        validator_name: decode_u8vector_argument(script.args().get(1)?.clone())?,
        validator_address: decode_address_argument(script.args().get(2)?.clone())?,
    })
}

fn decode_burn_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::Burn {
        token: script.ty_args().get(0)?.clone(),
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        preburn_address: decode_address_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_burn_txn_fees_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::BurnTxnFees {
        coin_type: script.ty_args().get(0)?.clone(),
    })
}

fn decode_cancel_burn_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CancelBurn {
        token: script.ty_args().get(0)?.clone(),
        preburn_address: decode_address_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_create_child_vasp_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CreateChildVaspAccount {
        coin_type: script.ty_args().get(0)?.clone(),
        child_address: decode_address_argument(script.args().get(0)?.clone())?,
        auth_key_prefix: decode_u8vector_argument(script.args().get(1)?.clone())?,
        add_all_currencies: decode_bool_argument(script.args().get(2)?.clone())?,
        child_initial_balance: decode_u64_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_create_designated_dealer_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CreateDesignatedDealer {
        currency: script.ty_args().get(0)?.clone(),
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        addr: decode_address_argument(script.args().get(1)?.clone())?,
        auth_key_prefix: decode_u8vector_argument(script.args().get(2)?.clone())?,
        human_name: decode_u8vector_argument(script.args().get(3)?.clone())?,
        add_all_currencies: decode_bool_argument(script.args().get(4)?.clone())?,
    })
}

fn decode_create_parent_vasp_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CreateParentVaspAccount {
        coin_type: script.ty_args().get(0)?.clone(),
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_account_address: decode_address_argument(script.args().get(1)?.clone())?,
        auth_key_prefix: decode_u8vector_argument(script.args().get(2)?.clone())?,
        human_name: decode_u8vector_argument(script.args().get(3)?.clone())?,
        add_all_currencies: decode_bool_argument(script.args().get(4)?.clone())?,
    })
}

fn decode_create_recovery_address_script(_script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CreateRecoveryAddress {})
}

fn decode_create_validator_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CreateValidatorAccount {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_account_address: decode_address_argument(script.args().get(1)?.clone())?,
        auth_key_prefix: decode_u8vector_argument(script.args().get(2)?.clone())?,
        human_name: decode_u8vector_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_create_validator_operator_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::CreateValidatorOperatorAccount {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_account_address: decode_address_argument(script.args().get(1)?.clone())?,
        auth_key_prefix: decode_u8vector_argument(script.args().get(2)?.clone())?,
        human_name: decode_u8vector_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_freeze_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::FreezeAccount {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        to_freeze_account: decode_address_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_mint_lbr_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::MintLbr {
        amount_lbr: decode_u64_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_peer_to_peer_with_metadata_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::PeerToPeerWithMetadata {
        currency: script.ty_args().get(0)?.clone(),
        payee: decode_address_argument(script.args().get(0)?.clone())?,
        amount: decode_u64_argument(script.args().get(1)?.clone())?,
        metadata: decode_u8vector_argument(script.args().get(2)?.clone())?,
        metadata_signature: decode_u8vector_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_preburn_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::Preburn {
        token: script.ty_args().get(0)?.clone(),
        amount: decode_u64_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_publish_shared_ed25519_public_key_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::PublishSharedEd25519PublicKey {
        public_key: decode_u8vector_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_register_validator_config_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RegisterValidatorConfig {
        validator_account: decode_address_argument(script.args().get(0)?.clone())?,
        consensus_pubkey: decode_u8vector_argument(script.args().get(1)?.clone())?,
        validator_network_addresses: decode_u8vector_argument(script.args().get(2)?.clone())?,
        fullnode_network_addresses: decode_u8vector_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_remove_validator_and_reconfigure_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RemoveValidatorAndReconfigure {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        validator_name: decode_u8vector_argument(script.args().get(1)?.clone())?,
        validator_address: decode_address_argument(script.args().get(2)?.clone())?,
    })
}

fn decode_rotate_authentication_key_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RotateAuthenticationKey {
        new_key: decode_u8vector_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_rotate_authentication_key_with_nonce_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RotateAuthenticationKeyWithNonce {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_key: decode_u8vector_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_rotate_authentication_key_with_nonce_admin_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RotateAuthenticationKeyWithNonceAdmin {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_key: decode_u8vector_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_rotate_authentication_key_with_recovery_address_script(
    script: &Script,
) -> Option<ScriptCall> {
    Some(ScriptCall::RotateAuthenticationKeyWithRecoveryAddress {
        recovery_address: decode_address_argument(script.args().get(0)?.clone())?,
        to_recover: decode_address_argument(script.args().get(1)?.clone())?,
        new_key: decode_u8vector_argument(script.args().get(2)?.clone())?,
    })
}

fn decode_rotate_dual_attestation_info_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RotateDualAttestationInfo {
        new_url: decode_u8vector_argument(script.args().get(0)?.clone())?,
        new_key: decode_u8vector_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_rotate_shared_ed25519_public_key_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::RotateSharedEd25519PublicKey {
        public_key: decode_u8vector_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_set_validator_config_and_reconfigure_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::SetValidatorConfigAndReconfigure {
        validator_account: decode_address_argument(script.args().get(0)?.clone())?,
        consensus_pubkey: decode_u8vector_argument(script.args().get(1)?.clone())?,
        validator_network_addresses: decode_u8vector_argument(script.args().get(2)?.clone())?,
        fullnode_network_addresses: decode_u8vector_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_set_validator_operator_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::SetValidatorOperator {
        operator_name: decode_u8vector_argument(script.args().get(0)?.clone())?,
        operator_account: decode_address_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_set_validator_operator_with_nonce_admin_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::SetValidatorOperatorWithNonceAdmin {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        operator_name: decode_u8vector_argument(script.args().get(1)?.clone())?,
        operator_account: decode_address_argument(script.args().get(2)?.clone())?,
    })
}

fn decode_tiered_mint_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::TieredMint {
        coin_type: script.ty_args().get(0)?.clone(),
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        designated_dealer_address: decode_address_argument(script.args().get(1)?.clone())?,
        mint_amount: decode_u64_argument(script.args().get(2)?.clone())?,
        tier_index: decode_u64_argument(script.args().get(3)?.clone())?,
    })
}

fn decode_unfreeze_account_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::UnfreezeAccount {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        to_unfreeze_account: decode_address_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_unmint_lbr_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::UnmintLbr {
        amount_lbr: decode_u64_argument(script.args().get(0)?.clone())?,
    })
}

fn decode_update_dual_attestation_limit_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::UpdateDualAttestationLimit {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_micro_lbr_limit: decode_u64_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_update_exchange_rate_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::UpdateExchangeRate {
        currency: script.ty_args().get(0)?.clone(),
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        new_exchange_rate_numerator: decode_u64_argument(script.args().get(1)?.clone())?,
        new_exchange_rate_denominator: decode_u64_argument(script.args().get(2)?.clone())?,
    })
}

fn decode_update_libra_version_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::UpdateLibraVersion {
        sliding_nonce: decode_u64_argument(script.args().get(0)?.clone())?,
        major: decode_u64_argument(script.args().get(1)?.clone())?,
    })
}

fn decode_update_minting_ability_script(script: &Script) -> Option<ScriptCall> {
    Some(ScriptCall::UpdateMintingAbility {
        currency: script.ty_args().get(0)?.clone(),
        allow_minting: decode_bool_argument(script.args().get(0)?.clone())?,
    })
}

type DecoderMap = std::collections::HashMap<
    Vec<u8>,
    Box<dyn Fn(&Script) -> Option<ScriptCall> + std::marker::Sync + std::marker::Send>,
>;

static SCRIPT_DECODER_MAP: once_cell::sync::Lazy<DecoderMap> = once_cell::sync::Lazy::new(|| {
    let mut map: DecoderMap = std::collections::HashMap::new();
    map.insert(
        ADD_CURRENCY_TO_ACCOUNT_CODE.to_vec(),
        Box::new(decode_add_currency_to_account_script),
    );
    map.insert(
        ADD_RECOVERY_ROTATION_CAPABILITY_CODE.to_vec(),
        Box::new(decode_add_recovery_rotation_capability_script),
    );
    map.insert(
        ADD_TO_SCRIPT_ALLOW_LIST_CODE.to_vec(),
        Box::new(decode_add_to_script_allow_list_script),
    );
    map.insert(
        ADD_VALIDATOR_AND_RECONFIGURE_CODE.to_vec(),
        Box::new(decode_add_validator_and_reconfigure_script),
    );
    map.insert(BURN_CODE.to_vec(), Box::new(decode_burn_script));
    map.insert(
        BURN_TXN_FEES_CODE.to_vec(),
        Box::new(decode_burn_txn_fees_script),
    );
    map.insert(
        CANCEL_BURN_CODE.to_vec(),
        Box::new(decode_cancel_burn_script),
    );
    map.insert(
        CREATE_CHILD_VASP_ACCOUNT_CODE.to_vec(),
        Box::new(decode_create_child_vasp_account_script),
    );
    map.insert(
        CREATE_DESIGNATED_DEALER_CODE.to_vec(),
        Box::new(decode_create_designated_dealer_script),
    );
    map.insert(
        CREATE_PARENT_VASP_ACCOUNT_CODE.to_vec(),
        Box::new(decode_create_parent_vasp_account_script),
    );
    map.insert(
        CREATE_RECOVERY_ADDRESS_CODE.to_vec(),
        Box::new(decode_create_recovery_address_script),
    );
    map.insert(
        CREATE_VALIDATOR_ACCOUNT_CODE.to_vec(),
        Box::new(decode_create_validator_account_script),
    );
    map.insert(
        CREATE_VALIDATOR_OPERATOR_ACCOUNT_CODE.to_vec(),
        Box::new(decode_create_validator_operator_account_script),
    );
    map.insert(
        FREEZE_ACCOUNT_CODE.to_vec(),
        Box::new(decode_freeze_account_script),
    );
    map.insert(MINT_LBR_CODE.to_vec(), Box::new(decode_mint_lbr_script));
    map.insert(
        PEER_TO_PEER_WITH_METADATA_CODE.to_vec(),
        Box::new(decode_peer_to_peer_with_metadata_script),
    );
    map.insert(PREBURN_CODE.to_vec(), Box::new(decode_preburn_script));
    map.insert(
        PUBLISH_SHARED_ED25519_PUBLIC_KEY_CODE.to_vec(),
        Box::new(decode_publish_shared_ed25519_public_key_script),
    );
    map.insert(
        REGISTER_VALIDATOR_CONFIG_CODE.to_vec(),
        Box::new(decode_register_validator_config_script),
    );
    map.insert(
        REMOVE_VALIDATOR_AND_RECONFIGURE_CODE.to_vec(),
        Box::new(decode_remove_validator_and_reconfigure_script),
    );
    map.insert(
        ROTATE_AUTHENTICATION_KEY_CODE.to_vec(),
        Box::new(decode_rotate_authentication_key_script),
    );
    map.insert(
        ROTATE_AUTHENTICATION_KEY_WITH_NONCE_CODE.to_vec(),
        Box::new(decode_rotate_authentication_key_with_nonce_script),
    );
    map.insert(
        ROTATE_AUTHENTICATION_KEY_WITH_NONCE_ADMIN_CODE.to_vec(),
        Box::new(decode_rotate_authentication_key_with_nonce_admin_script),
    );
    map.insert(
        ROTATE_AUTHENTICATION_KEY_WITH_RECOVERY_ADDRESS_CODE.to_vec(),
        Box::new(decode_rotate_authentication_key_with_recovery_address_script),
    );
    map.insert(
        ROTATE_DUAL_ATTESTATION_INFO_CODE.to_vec(),
        Box::new(decode_rotate_dual_attestation_info_script),
    );
    map.insert(
        ROTATE_SHARED_ED25519_PUBLIC_KEY_CODE.to_vec(),
        Box::new(decode_rotate_shared_ed25519_public_key_script),
    );
    map.insert(
        SET_VALIDATOR_CONFIG_AND_RECONFIGURE_CODE.to_vec(),
        Box::new(decode_set_validator_config_and_reconfigure_script),
    );
    map.insert(
        SET_VALIDATOR_OPERATOR_CODE.to_vec(),
        Box::new(decode_set_validator_operator_script),
    );
    map.insert(
        SET_VALIDATOR_OPERATOR_WITH_NONCE_ADMIN_CODE.to_vec(),
        Box::new(decode_set_validator_operator_with_nonce_admin_script),
    );
    map.insert(
        TIERED_MINT_CODE.to_vec(),
        Box::new(decode_tiered_mint_script),
    );
    map.insert(
        UNFREEZE_ACCOUNT_CODE.to_vec(),
        Box::new(decode_unfreeze_account_script),
    );
    map.insert(UNMINT_LBR_CODE.to_vec(), Box::new(decode_unmint_lbr_script));
    map.insert(
        UPDATE_DUAL_ATTESTATION_LIMIT_CODE.to_vec(),
        Box::new(decode_update_dual_attestation_limit_script),
    );
    map.insert(
        UPDATE_EXCHANGE_RATE_CODE.to_vec(),
        Box::new(decode_update_exchange_rate_script),
    );
    map.insert(
        UPDATE_LIBRA_VERSION_CODE.to_vec(),
        Box::new(decode_update_libra_version_script),
    );
    map.insert(
        UPDATE_MINTING_ABILITY_CODE.to_vec(),
        Box::new(decode_update_minting_ability_script),
    );
    map
});

fn decode_bool_argument(arg: TransactionArgument) -> Option<bool> {
    match arg {
        TransactionArgument::Bool(value) => Some(value),
        _ => None,
    }
}

fn decode_u64_argument(arg: TransactionArgument) -> Option<u64> {
    match arg {
        TransactionArgument::U64(value) => Some(value),
        _ => None,
    }
}

fn decode_address_argument(arg: TransactionArgument) -> Option<AccountAddress> {
    match arg {
        TransactionArgument::Address(value) => Some(value),
        _ => None,
    }
}

fn decode_u8vector_argument(arg: TransactionArgument) -> Option<Vec<u8>> {
    match arg {
        TransactionArgument::U8Vector(value) => Some(value),
        _ => None,
    }
}

const ADD_CURRENCY_TO_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 2, 3, 2, 6, 4, 8, 2, 5, 10, 7, 7, 17, 26, 8, 43, 16, 0,
    0, 0, 1, 0, 1, 1, 1, 0, 2, 1, 6, 12, 0, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111,
    117, 110, 116, 12, 97, 100, 100, 95, 99, 117, 114, 114, 101, 110, 99, 121, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 3, 11, 0, 56, 0, 2,
];

const ADD_RECOVERY_ROTATION_CAPABILITY_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 2, 4, 4, 3, 8, 10, 5, 18, 15, 7, 33, 107, 8, 140, 1,
    16, 0, 0, 0, 1, 0, 2, 1, 0, 0, 3, 0, 1, 0, 1, 4, 2, 3, 0, 1, 6, 12, 1, 8, 0, 2, 8, 0, 5, 0, 2,
    6, 12, 5, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 15, 82, 101, 99, 111, 118,
    101, 114, 121, 65, 100, 100, 114, 101, 115, 115, 21, 75, 101, 121, 82, 111, 116, 97, 116, 105,
    111, 110, 67, 97, 112, 97, 98, 105, 108, 105, 116, 121, 31, 101, 120, 116, 114, 97, 99, 116,
    95, 107, 101, 121, 95, 114, 111, 116, 97, 116, 105, 111, 110, 95, 99, 97, 112, 97, 98, 105,
    108, 105, 116, 121, 23, 97, 100, 100, 95, 114, 111, 116, 97, 116, 105, 111, 110, 95, 99, 97,
    112, 97, 98, 105, 108, 105, 116, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 3,
    5, 11, 0, 17, 0, 10, 1, 17, 1, 2,
];

const ADD_TO_SCRIPT_ALLOW_LIST_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 16, 7, 30, 93, 8, 123, 16, 0, 0, 0,
    1, 0, 2, 0, 1, 0, 1, 3, 2, 1, 0, 2, 6, 12, 10, 2, 0, 2, 6, 12, 3, 3, 6, 12, 10, 2, 3, 32, 76,
    105, 98, 114, 97, 84, 114, 97, 110, 115, 97, 99, 116, 105, 111, 110, 80, 117, 98, 108, 105,
    115, 104, 105, 110, 103, 79, 112, 116, 105, 111, 110, 12, 83, 108, 105, 100, 105, 110, 103, 78,
    111, 110, 99, 101, 24, 97, 100, 100, 95, 116, 111, 95, 115, 99, 114, 105, 112, 116, 95, 97,
    108, 108, 111, 119, 95, 108, 105, 115, 116, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110,
    99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 3, 1, 7, 10, 0, 10, 2, 17, 1, 11, 0, 11, 1, 17, 0, 2,
];

const ADD_VALIDATOR_AND_RECONFIGURE_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 6, 3, 6, 15, 5, 21, 24, 7, 45, 92, 8, 137, 1, 16, 0, 0,
    0, 1, 0, 2, 1, 3, 0, 1, 0, 2, 4, 2, 3, 0, 0, 5, 4, 1, 0, 2, 6, 12, 3, 0, 1, 5, 1, 10, 2, 2, 6,
    12, 5, 4, 6, 12, 3, 10, 2, 5, 2, 1, 3, 11, 76, 105, 98, 114, 97, 83, 121, 115, 116, 101, 109,
    12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99, 101, 15, 86, 97, 108, 105, 100, 97,
    116, 111, 114, 67, 111, 110, 102, 105, 103, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110,
    99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 14, 103, 101, 116, 95, 104, 117, 109, 97,
    110, 95, 110, 97, 109, 101, 13, 97, 100, 100, 95, 118, 97, 108, 105, 100, 97, 116, 111, 114, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 6, 18, 10, 0, 10, 1, 17, 0, 10, 3, 17, 1,
    11, 2, 33, 12, 4, 11, 4, 3, 14, 11, 0, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 39, 11, 0, 10, 3, 17, 2,
    2,
];

const BURN_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 3, 4, 11, 4, 15, 2, 5, 17, 17, 7, 34, 46, 8, 80, 16,
    0, 0, 0, 1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 1, 1, 1, 4, 2, 6, 12, 3, 0, 2, 6, 12, 5, 3, 6, 12, 3, 5,
    1, 9, 0, 5, 76, 105, 98, 114, 97, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99, 101,
    21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95, 97, 98, 111,
    114, 116, 4, 98, 117, 114, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 1, 7,
    10, 0, 10, 1, 17, 0, 11, 0, 10, 2, 56, 0, 2,
];

const BURN_TXN_FEES_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 2, 3, 2, 6, 4, 8, 2, 5, 10, 7, 7, 17, 25, 8, 42, 16, 0,
    0, 0, 1, 0, 1, 1, 1, 0, 2, 1, 6, 12, 0, 1, 9, 0, 14, 84, 114, 97, 110, 115, 97, 99, 116, 105,
    111, 110, 70, 101, 101, 9, 98, 117, 114, 110, 95, 102, 101, 101, 115, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 3, 11, 0, 56, 0, 2,
];

const CANCEL_BURN_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 2, 3, 2, 6, 4, 8, 2, 5, 10, 8, 7, 18, 25, 8, 43, 16, 0,
    0, 0, 1, 0, 1, 1, 1, 0, 2, 2, 6, 12, 5, 0, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111,
    117, 110, 116, 11, 99, 97, 110, 99, 101, 108, 95, 98, 117, 114, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 4, 11, 0, 10, 1, 56, 0, 2,
];

const CREATE_CHILD_VASP_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 8, 1, 0, 2, 2, 2, 4, 3, 6, 22, 4, 28, 4, 5, 32, 35, 7, 67, 123,
    8, 190, 1, 16, 6, 206, 1, 4, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 1, 1, 0, 3, 2, 3, 0, 0, 4, 4, 1, 1,
    1, 0, 5, 3, 1, 0, 0, 6, 2, 6, 4, 6, 12, 5, 10, 2, 1, 0, 1, 6, 12, 1, 8, 0, 5, 6, 8, 0, 5, 3,
    10, 2, 10, 2, 5, 6, 12, 5, 10, 2, 1, 3, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111,
    117, 110, 116, 18, 87, 105, 116, 104, 100, 114, 97, 119, 67, 97, 112, 97, 98, 105, 108, 105,
    116, 121, 25, 99, 114, 101, 97, 116, 101, 95, 99, 104, 105, 108, 100, 95, 118, 97, 115, 112,
    95, 97, 99, 99, 111, 117, 110, 116, 27, 101, 120, 116, 114, 97, 99, 116, 95, 119, 105, 116,
    104, 100, 114, 97, 119, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 8, 112, 97, 121, 95,
    102, 114, 111, 109, 27, 114, 101, 115, 116, 111, 114, 101, 95, 119, 105, 116, 104, 100, 114,
    97, 119, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 10, 2, 1, 0, 1, 1, 5, 3, 25, 10, 0, 10, 1, 11, 2, 10, 3, 56, 0, 10, 4, 6, 0, 0, 0,
    0, 0, 0, 0, 0, 36, 3, 10, 5, 22, 11, 0, 17, 1, 12, 5, 14, 5, 10, 1, 10, 4, 7, 0, 7, 0, 56, 1,
    11, 5, 17, 3, 5, 24, 11, 0, 1, 2,
];

const CREATE_DESIGNATED_DEALER_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 3, 4, 11, 4, 15, 2, 5, 17, 27, 7, 44, 73, 8, 117, 16,
    0, 0, 0, 1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 1, 1, 1, 4, 2, 6, 12, 3, 0, 5, 6, 12, 5, 10, 2, 10, 2,
    1, 6, 6, 12, 3, 5, 10, 2, 10, 2, 1, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117,
    110, 116, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99, 101, 21, 114, 101, 99, 111,
    114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 24, 99, 114,
    101, 97, 116, 101, 95, 100, 101, 115, 105, 103, 110, 97, 116, 101, 100, 95, 100, 101, 97, 108,
    101, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 1, 10, 10, 0, 10, 1, 17, 0,
    11, 0, 10, 2, 11, 3, 11, 4, 10, 5, 56, 0, 2,
];

const CREATE_PARENT_VASP_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 3, 4, 11, 4, 15, 2, 5, 17, 27, 7, 44, 75, 8, 119, 16,
    0, 0, 0, 1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 1, 1, 1, 4, 2, 6, 12, 3, 0, 5, 6, 12, 5, 10, 2, 10, 2,
    1, 6, 6, 12, 3, 5, 10, 2, 10, 2, 1, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117,
    110, 116, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99, 101, 21, 114, 101, 99, 111,
    114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 26, 99, 114,
    101, 97, 116, 101, 95, 112, 97, 114, 101, 110, 116, 95, 118, 97, 115, 112, 95, 97, 99, 99, 111,
    117, 110, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 1, 10, 10, 0, 10, 1,
    17, 0, 11, 0, 10, 2, 11, 3, 11, 4, 10, 5, 56, 0, 2,
];

const CREATE_RECOVERY_ADDRESS_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 2, 4, 4, 3, 8, 10, 5, 18, 12, 7, 30, 91, 8, 121, 16,
    0, 0, 0, 1, 0, 2, 1, 0, 0, 3, 0, 1, 0, 1, 4, 2, 3, 0, 1, 6, 12, 1, 8, 0, 2, 6, 12, 8, 0, 0, 12,
    76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 15, 82, 101, 99, 111, 118, 101, 114, 121,
    65, 100, 100, 114, 101, 115, 115, 21, 75, 101, 121, 82, 111, 116, 97, 116, 105, 111, 110, 67,
    97, 112, 97, 98, 105, 108, 105, 116, 121, 31, 101, 120, 116, 114, 97, 99, 116, 95, 107, 101,
    121, 95, 114, 111, 116, 97, 116, 105, 111, 110, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116,
    121, 7, 112, 117, 98, 108, 105, 115, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    3, 5, 10, 0, 11, 0, 17, 0, 17, 1, 2,
];

const CREATE_VALIDATOR_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 22, 7, 36, 73, 8, 109, 16, 0, 0, 0,
    1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 0, 2, 6, 12, 3, 0, 4, 6, 12, 5, 10, 2, 10, 2, 5, 6, 12, 3, 5, 10,
    2, 10, 2, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 12, 83, 108, 105, 100, 105,
    110, 103, 78, 111, 110, 99, 101, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101,
    95, 111, 114, 95, 97, 98, 111, 114, 116, 24, 99, 114, 101, 97, 116, 101, 95, 118, 97, 108, 105,
    100, 97, 116, 111, 114, 95, 97, 99, 99, 111, 117, 110, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 3, 1, 9, 10, 0, 10, 1, 17, 0, 11, 0, 10, 2, 11, 3, 11, 4, 17, 1, 2,
];

const CREATE_VALIDATOR_OPERATOR_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 22, 7, 36, 82, 8, 118, 16, 0, 0, 0,
    1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 0, 2, 6, 12, 3, 0, 4, 6, 12, 5, 10, 2, 10, 2, 5, 6, 12, 3, 5, 10,
    2, 10, 2, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 12, 83, 108, 105, 100, 105,
    110, 103, 78, 111, 110, 99, 101, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101,
    95, 111, 114, 95, 97, 98, 111, 114, 116, 33, 99, 114, 101, 97, 116, 101, 95, 118, 97, 108, 105,
    100, 97, 116, 111, 114, 95, 111, 112, 101, 114, 97, 116, 111, 114, 95, 97, 99, 99, 111, 117,
    110, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 1, 9, 10, 0, 10, 1, 17, 0, 11,
    0, 10, 2, 11, 3, 11, 4, 17, 1, 2,
];

const FREEZE_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 14, 7, 28, 66, 8, 94, 16, 0, 0, 0,
    1, 0, 2, 0, 1, 0, 1, 3, 2, 1, 0, 2, 6, 12, 5, 0, 2, 6, 12, 3, 3, 6, 12, 3, 5, 15, 65, 99, 99,
    111, 117, 110, 116, 70, 114, 101, 101, 122, 105, 110, 103, 12, 83, 108, 105, 100, 105, 110,
    103, 78, 111, 110, 99, 101, 14, 102, 114, 101, 101, 122, 101, 95, 97, 99, 99, 111, 117, 110,
    116, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95, 97, 98,
    111, 114, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 1, 7, 10, 0, 10, 1, 17, 1,
    11, 0, 10, 2, 17, 0, 2,
];

const MINT_LBR_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 2, 2, 2, 4, 3, 6, 15, 5, 21, 16, 7, 37, 99, 8, 136, 1,
    16, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 0, 3, 1, 2, 0, 0, 4, 3, 2, 0, 1, 6, 12, 1, 8, 0, 0, 2, 6,
    8, 0, 3, 2, 6, 12, 3, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 18, 87, 105,
    116, 104, 100, 114, 97, 119, 67, 97, 112, 97, 98, 105, 108, 105, 116, 121, 27, 101, 120, 116,
    114, 97, 99, 116, 95, 119, 105, 116, 104, 100, 114, 97, 119, 95, 99, 97, 112, 97, 98, 105, 108,
    105, 116, 121, 27, 114, 101, 115, 116, 111, 114, 101, 95, 119, 105, 116, 104, 100, 114, 97,
    119, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 10, 115, 116, 97, 112, 108, 101, 95,
    108, 98, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 1, 9, 11, 0, 17, 0, 12, 2,
    14, 2, 10, 1, 17, 2, 11, 2, 17, 1, 2,
];

const PEER_TO_PEER_WITH_METADATA_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 7, 1, 0, 2, 2, 2, 4, 3, 6, 16, 4, 22, 2, 5, 24, 29, 7, 53, 97, 8,
    150, 1, 16, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 0, 3, 2, 3, 1, 1, 0, 4, 1, 3, 0, 1, 5, 1, 6, 12,
    1, 8, 0, 5, 6, 8, 0, 5, 3, 10, 2, 10, 2, 0, 5, 6, 12, 5, 3, 10, 2, 10, 2, 1, 9, 0, 12, 76, 105,
    98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 18, 87, 105, 116, 104, 100, 114, 97, 119, 67, 97,
    112, 97, 98, 105, 108, 105, 116, 121, 27, 101, 120, 116, 114, 97, 99, 116, 95, 119, 105, 116,
    104, 100, 114, 97, 119, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 8, 112, 97, 121, 95,
    102, 114, 111, 109, 27, 114, 101, 115, 116, 111, 114, 101, 95, 119, 105, 116, 104, 100, 114,
    97, 119, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 4, 1, 12, 11, 0, 17, 0, 12, 5, 14, 5, 10, 1, 10, 2, 11, 3, 11, 4, 56, 0, 11,
    5, 17, 2, 2,
];

const PREBURN_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 7, 1, 0, 2, 2, 2, 4, 3, 6, 16, 4, 22, 2, 5, 24, 21, 7, 45, 96, 8,
    141, 1, 16, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 0, 3, 2, 3, 1, 1, 0, 4, 1, 3, 0, 1, 5, 1, 6, 12,
    1, 8, 0, 3, 6, 12, 6, 8, 0, 3, 0, 2, 6, 12, 3, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99,
    111, 117, 110, 116, 18, 87, 105, 116, 104, 100, 114, 97, 119, 67, 97, 112, 97, 98, 105, 108,
    105, 116, 121, 27, 101, 120, 116, 114, 97, 99, 116, 95, 119, 105, 116, 104, 100, 114, 97, 119,
    95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 7, 112, 114, 101, 98, 117, 114, 110, 27, 114,
    101, 115, 116, 111, 114, 101, 95, 119, 105, 116, 104, 100, 114, 97, 119, 95, 99, 97, 112, 97,
    98, 105, 108, 105, 116, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 1, 10,
    10, 0, 17, 0, 12, 2, 11, 0, 14, 2, 10, 1, 56, 0, 11, 2, 17, 2, 2,
];

const PUBLISH_SHARED_ED25519_PUBLIC_KEY_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 2, 3, 2, 5, 5, 7, 6, 7, 13, 31, 8, 44, 16, 0, 0, 0, 1,
    0, 1, 0, 2, 6, 12, 10, 2, 0, 22, 83, 104, 97, 114, 101, 100, 69, 100, 50, 53, 53, 49, 57, 80,
    117, 98, 108, 105, 99, 75, 101, 121, 7, 112, 117, 98, 108, 105, 115, 104, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 11, 0, 11, 1, 17, 0, 2,
];

const REGISTER_VALIDATOR_CONFIG_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 2, 3, 2, 5, 5, 7, 11, 7, 18, 27, 8, 45, 16, 0, 0, 0, 1,
    0, 1, 0, 5, 6, 12, 5, 10, 2, 10, 2, 10, 2, 0, 15, 86, 97, 108, 105, 100, 97, 116, 111, 114, 67,
    111, 110, 102, 105, 103, 10, 115, 101, 116, 95, 99, 111, 110, 102, 105, 103, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 7, 11, 0, 10, 1, 11, 2, 11, 3, 11, 4, 17, 0, 2,
];

const REMOVE_VALIDATOR_AND_RECONFIGURE_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 6, 3, 6, 15, 5, 21, 24, 7, 45, 95, 8, 140, 1, 16, 0, 0,
    0, 1, 0, 2, 1, 3, 0, 1, 0, 2, 4, 2, 3, 0, 0, 5, 4, 1, 0, 2, 6, 12, 3, 0, 1, 5, 1, 10, 2, 2, 6,
    12, 5, 4, 6, 12, 3, 10, 2, 5, 2, 1, 3, 11, 76, 105, 98, 114, 97, 83, 121, 115, 116, 101, 109,
    12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99, 101, 15, 86, 97, 108, 105, 100, 97,
    116, 111, 114, 67, 111, 110, 102, 105, 103, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110,
    99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 14, 103, 101, 116, 95, 104, 117, 109, 97,
    110, 95, 110, 97, 109, 101, 16, 114, 101, 109, 111, 118, 101, 95, 118, 97, 108, 105, 100, 97,
    116, 111, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 6, 18, 10, 0, 10, 1, 17,
    0, 10, 3, 17, 1, 11, 2, 33, 12, 4, 11, 4, 3, 14, 11, 0, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 39, 11,
    0, 10, 3, 17, 2, 2,
];

const ROTATE_AUTHENTICATION_KEY_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 2, 4, 4, 3, 8, 25, 5, 33, 32, 7, 65, 175, 1, 8, 240,
    1, 16, 0, 0, 0, 1, 0, 3, 1, 0, 1, 2, 0, 1, 0, 0, 4, 0, 2, 0, 0, 5, 3, 4, 0, 0, 6, 2, 5, 0, 0,
    7, 6, 5, 0, 1, 6, 12, 1, 5, 1, 8, 0, 1, 6, 8, 0, 1, 6, 5, 0, 2, 6, 8, 0, 10, 2, 2, 6, 12, 10,
    2, 3, 8, 0, 1, 3, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 6, 83, 105, 103,
    110, 101, 114, 10, 97, 100, 100, 114, 101, 115, 115, 95, 111, 102, 21, 75, 101, 121, 82, 111,
    116, 97, 116, 105, 111, 110, 67, 97, 112, 97, 98, 105, 108, 105, 116, 121, 31, 101, 120, 116,
    114, 97, 99, 116, 95, 107, 101, 121, 95, 114, 111, 116, 97, 116, 105, 111, 110, 95, 99, 97,
    112, 97, 98, 105, 108, 105, 116, 121, 31, 107, 101, 121, 95, 114, 111, 116, 97, 116, 105, 111,
    110, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 95, 97, 100, 100, 114, 101, 115, 115,
    31, 114, 101, 115, 116, 111, 114, 101, 95, 107, 101, 121, 95, 114, 111, 116, 97, 116, 105, 111,
    110, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 25, 114, 111, 116, 97, 116, 101, 95, 97,
    117, 116, 104, 101, 110, 116, 105, 99, 97, 116, 105, 111, 110, 95, 107, 101, 121, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 8, 20, 10, 0, 17, 1, 12, 2, 14, 2, 17, 2, 20, 11, 0,
    17, 0, 33, 12, 3, 11, 3, 3, 14, 6, 0, 0, 0, 0, 0, 0, 0, 0, 39, 14, 2, 11, 1, 17, 4, 11, 2, 17,
    3, 2,
];

const ROTATE_AUTHENTICATION_KEY_WITH_NONCE_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 2, 4, 4, 3, 8, 20, 5, 28, 23, 7, 51, 160, 1, 8, 211,
    1, 16, 0, 0, 0, 1, 0, 3, 1, 0, 1, 2, 0, 1, 0, 0, 4, 2, 3, 0, 0, 5, 3, 1, 0, 0, 6, 4, 1, 0, 2,
    6, 12, 3, 0, 1, 6, 12, 1, 8, 0, 2, 6, 8, 0, 10, 2, 3, 6, 12, 3, 10, 2, 12, 76, 105, 98, 114,
    97, 65, 99, 99, 111, 117, 110, 116, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99,
    101, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95, 97, 98,
    111, 114, 116, 21, 75, 101, 121, 82, 111, 116, 97, 116, 105, 111, 110, 67, 97, 112, 97, 98,
    105, 108, 105, 116, 121, 31, 101, 120, 116, 114, 97, 99, 116, 95, 107, 101, 121, 95, 114, 111,
    116, 97, 116, 105, 111, 110, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 31, 114, 101,
    115, 116, 111, 114, 101, 95, 107, 101, 121, 95, 114, 111, 116, 97, 116, 105, 111, 110, 95, 99,
    97, 112, 97, 98, 105, 108, 105, 116, 121, 25, 114, 111, 116, 97, 116, 101, 95, 97, 117, 116,
    104, 101, 110, 116, 105, 99, 97, 116, 105, 111, 110, 95, 107, 101, 121, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 3, 12, 10, 0, 10, 1, 17, 0, 11, 0, 17, 1, 12, 3, 14, 3, 11, 2,
    17, 3, 11, 3, 17, 2, 2,
];

const ROTATE_AUTHENTICATION_KEY_WITH_NONCE_ADMIN_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 2, 4, 4, 3, 8, 20, 5, 28, 25, 7, 53, 160, 1, 8, 213,
    1, 16, 0, 0, 0, 1, 0, 3, 1, 0, 1, 2, 0, 1, 0, 0, 4, 2, 3, 0, 0, 5, 3, 1, 0, 0, 6, 4, 1, 0, 2,
    6, 12, 3, 0, 1, 6, 12, 1, 8, 0, 2, 6, 8, 0, 10, 2, 4, 6, 12, 6, 12, 3, 10, 2, 12, 76, 105, 98,
    114, 97, 65, 99, 99, 111, 117, 110, 116, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110,
    99, 101, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95, 97, 98,
    111, 114, 116, 21, 75, 101, 121, 82, 111, 116, 97, 116, 105, 111, 110, 67, 97, 112, 97, 98,
    105, 108, 105, 116, 121, 31, 101, 120, 116, 114, 97, 99, 116, 95, 107, 101, 121, 95, 114, 111,
    116, 97, 116, 105, 111, 110, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 31, 114, 101,
    115, 116, 111, 114, 101, 95, 107, 101, 121, 95, 114, 111, 116, 97, 116, 105, 111, 110, 95, 99,
    97, 112, 97, 98, 105, 108, 105, 116, 121, 25, 114, 111, 116, 97, 116, 101, 95, 97, 117, 116,
    104, 101, 110, 116, 105, 99, 97, 116, 105, 111, 110, 95, 107, 101, 121, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 3, 12, 11, 0, 10, 2, 17, 0, 11, 1, 17, 1, 12, 4, 14, 4, 11, 3,
    17, 3, 11, 4, 17, 2, 2,
];

const ROTATE_AUTHENTICATION_KEY_WITH_RECOVERY_ADDRESS_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 2, 3, 2, 5, 5, 7, 8, 7, 15, 42, 8, 57, 16, 0, 0, 0, 1,
    0, 1, 0, 4, 6, 12, 5, 5, 10, 2, 0, 15, 82, 101, 99, 111, 118, 101, 114, 121, 65, 100, 100, 114,
    101, 115, 115, 25, 114, 111, 116, 97, 116, 101, 95, 97, 117, 116, 104, 101, 110, 116, 105, 99,
    97, 116, 105, 111, 110, 95, 107, 101, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 1, 6, 11, 0, 10, 1, 10, 2, 11, 3, 17, 0, 2,
];

const ROTATE_DUAL_ATTESTATION_INFO_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 2, 3, 2, 10, 5, 12, 13, 7, 25, 61, 8, 86, 16, 0, 0, 0,
    1, 0, 1, 0, 0, 2, 0, 1, 0, 2, 6, 12, 10, 2, 0, 3, 6, 12, 10, 2, 10, 2, 15, 68, 117, 97, 108,
    65, 116, 116, 101, 115, 116, 97, 116, 105, 111, 110, 15, 114, 111, 116, 97, 116, 101, 95, 98,
    97, 115, 101, 95, 117, 114, 108, 28, 114, 111, 116, 97, 116, 101, 95, 99, 111, 109, 112, 108,
    105, 97, 110, 99, 101, 95, 112, 117, 98, 108, 105, 99, 95, 107, 101, 121, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 7, 10, 0, 11, 1, 17, 0, 11, 0, 11, 2, 17, 1, 2,
];

const ROTATE_SHARED_ED25519_PUBLIC_KEY_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 2, 3, 2, 5, 5, 7, 6, 7, 13, 34, 8, 47, 16, 0, 0, 0, 1,
    0, 1, 0, 2, 6, 12, 10, 2, 0, 22, 83, 104, 97, 114, 101, 100, 69, 100, 50, 53, 53, 49, 57, 80,
    117, 98, 108, 105, 99, 75, 101, 121, 10, 114, 111, 116, 97, 116, 101, 95, 107, 101, 121, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 4, 11, 0, 11, 1, 17, 0, 2,
];

const SET_VALIDATOR_CONFIG_AND_RECONFIGURE_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 15, 7, 29, 69, 8, 98, 16, 0, 0, 0,
    1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 0, 5, 6, 12, 5, 10, 2, 10, 2, 10, 2, 0, 2, 6, 12, 5, 11, 76, 105,
    98, 114, 97, 83, 121, 115, 116, 101, 109, 15, 86, 97, 108, 105, 100, 97, 116, 111, 114, 67,
    111, 110, 102, 105, 103, 10, 115, 101, 116, 95, 99, 111, 110, 102, 105, 103, 29, 117, 112, 100,
    97, 116, 101, 95, 99, 111, 110, 102, 105, 103, 95, 97, 110, 100, 95, 114, 101, 99, 111, 110,
    102, 105, 103, 117, 114, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 10, 10,
    0, 10, 1, 11, 2, 11, 3, 11, 4, 17, 0, 11, 0, 10, 1, 17, 1, 2,
];

const SET_VALIDATOR_OPERATOR_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 19, 7, 33, 68, 8, 101, 16, 0, 0, 0,
    1, 1, 2, 0, 1, 0, 0, 3, 2, 3, 0, 1, 5, 1, 10, 2, 2, 6, 12, 5, 0, 3, 6, 12, 10, 2, 5, 2, 1, 3,
    15, 86, 97, 108, 105, 100, 97, 116, 111, 114, 67, 111, 110, 102, 105, 103, 23, 86, 97, 108,
    105, 100, 97, 116, 111, 114, 79, 112, 101, 114, 97, 116, 111, 114, 67, 111, 110, 102, 105, 103,
    14, 103, 101, 116, 95, 104, 117, 109, 97, 110, 95, 110, 97, 109, 101, 12, 115, 101, 116, 95,
    111, 112, 101, 114, 97, 116, 111, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 5,
    15, 10, 2, 17, 0, 11, 1, 33, 12, 3, 11, 3, 3, 11, 11, 0, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 39, 11,
    0, 10, 2, 17, 1, 2,
];

const SET_VALIDATOR_OPERATOR_WITH_NONCE_ADMIN_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 6, 3, 6, 15, 5, 21, 26, 7, 47, 103, 8, 150, 1, 16, 0, 0,
    0, 1, 0, 2, 0, 3, 0, 1, 0, 2, 4, 2, 3, 0, 1, 5, 4, 1, 0, 2, 6, 12, 3, 0, 1, 5, 1, 10, 2, 2, 6,
    12, 5, 5, 6, 12, 6, 12, 3, 10, 2, 5, 2, 1, 3, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111,
    110, 99, 101, 15, 86, 97, 108, 105, 100, 97, 116, 111, 114, 67, 111, 110, 102, 105, 103, 23,
    86, 97, 108, 105, 100, 97, 116, 111, 114, 79, 112, 101, 114, 97, 116, 111, 114, 67, 111, 110,
    102, 105, 103, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95,
    97, 98, 111, 114, 116, 14, 103, 101, 116, 95, 104, 117, 109, 97, 110, 95, 110, 97, 109, 101,
    12, 115, 101, 116, 95, 111, 112, 101, 114, 97, 116, 111, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 5, 6, 18, 11, 0, 10, 2, 17, 0, 10, 4, 17, 1, 11, 3, 33, 12, 5, 11, 5, 3, 14,
    11, 1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 39, 11, 1, 10, 4, 17, 2, 2,
];

const TIERED_MINT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 4, 3, 4, 11, 4, 15, 2, 5, 17, 21, 7, 38, 60, 8, 98, 16,
    0, 0, 0, 1, 1, 2, 0, 1, 0, 0, 3, 2, 1, 1, 1, 1, 4, 2, 6, 12, 3, 0, 4, 6, 12, 5, 3, 3, 5, 6, 12,
    3, 5, 3, 3, 1, 9, 0, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 12, 83, 108,
    105, 100, 105, 110, 103, 78, 111, 110, 99, 101, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111,
    110, 99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 11, 116, 105, 101, 114, 101, 100, 95,
    109, 105, 110, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 1, 9, 10, 0, 10,
    1, 17, 0, 11, 0, 10, 2, 10, 3, 10, 4, 56, 0, 2,
];

const UNFREEZE_ACCOUNT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 14, 7, 28, 68, 8, 96, 16, 0, 0, 0,
    1, 0, 2, 0, 1, 0, 1, 3, 2, 1, 0, 2, 6, 12, 5, 0, 2, 6, 12, 3, 3, 6, 12, 3, 5, 15, 65, 99, 99,
    111, 117, 110, 116, 70, 114, 101, 101, 122, 105, 110, 103, 12, 83, 108, 105, 100, 105, 110,
    103, 78, 111, 110, 99, 101, 16, 117, 110, 102, 114, 101, 101, 122, 101, 95, 97, 99, 99, 111,
    117, 110, 116, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95,
    97, 98, 111, 114, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 1, 7, 10, 0, 10,
    1, 17, 1, 11, 0, 10, 2, 17, 0, 2,
];

const UNMINT_LBR_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 2, 2, 2, 4, 3, 6, 15, 5, 21, 16, 7, 37, 101, 8, 138, 1,
    16, 0, 0, 0, 1, 1, 0, 0, 2, 0, 1, 0, 0, 3, 1, 2, 0, 0, 4, 3, 2, 0, 1, 6, 12, 1, 8, 0, 0, 2, 6,
    8, 0, 3, 2, 6, 12, 3, 12, 76, 105, 98, 114, 97, 65, 99, 99, 111, 117, 110, 116, 18, 87, 105,
    116, 104, 100, 114, 97, 119, 67, 97, 112, 97, 98, 105, 108, 105, 116, 121, 27, 101, 120, 116,
    114, 97, 99, 116, 95, 119, 105, 116, 104, 100, 114, 97, 119, 95, 99, 97, 112, 97, 98, 105, 108,
    105, 116, 121, 27, 114, 101, 115, 116, 111, 114, 101, 95, 119, 105, 116, 104, 100, 114, 97,
    119, 95, 99, 97, 112, 97, 98, 105, 108, 105, 116, 121, 12, 117, 110, 115, 116, 97, 112, 108,
    101, 95, 108, 98, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 1, 9, 11, 0, 17,
    0, 12, 2, 14, 2, 10, 1, 17, 2, 11, 2, 17, 1, 2,
];

const UPDATE_DUAL_ATTESTATION_LIMIT_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 10, 7, 24, 72, 8, 96, 16, 0, 0, 0,
    1, 0, 2, 0, 1, 0, 1, 3, 0, 1, 0, 2, 6, 12, 3, 0, 3, 6, 12, 3, 3, 15, 68, 117, 97, 108, 65, 116,
    116, 101, 115, 116, 97, 116, 105, 111, 110, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110,
    99, 101, 20, 115, 101, 116, 95, 109, 105, 99, 114, 111, 108, 105, 98, 114, 97, 95, 108, 105,
    109, 105, 116, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95,
    97, 98, 111, 114, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 7, 10, 0, 10,
    1, 17, 1, 11, 0, 10, 2, 17, 0, 2,
];

const UPDATE_EXCHANGE_RATE_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 7, 1, 0, 6, 2, 6, 4, 3, 10, 16, 4, 26, 2, 5, 28, 25, 7, 53, 100,
    8, 153, 1, 16, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 0, 3, 0, 1, 0, 2, 4, 2, 3, 0, 1, 5, 4, 3, 1, 1, 2,
    6, 2, 3, 3, 1, 8, 0, 2, 6, 12, 3, 0, 2, 6, 12, 8, 0, 4, 6, 12, 3, 3, 3, 1, 9, 0, 12, 70, 105,
    120, 101, 100, 80, 111, 105, 110, 116, 51, 50, 5, 76, 105, 98, 114, 97, 12, 83, 108, 105, 100,
    105, 110, 103, 78, 111, 110, 99, 101, 20, 99, 114, 101, 97, 116, 101, 95, 102, 114, 111, 109,
    95, 114, 97, 116, 105, 111, 110, 97, 108, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110,
    99, 101, 95, 111, 114, 95, 97, 98, 111, 114, 116, 24, 117, 112, 100, 97, 116, 101, 95, 108, 98,
    114, 95, 101, 120, 99, 104, 97, 110, 103, 101, 95, 114, 97, 116, 101, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 5, 1, 11, 10, 0, 10, 1, 17, 1, 10, 2, 10, 3, 17, 0, 12, 4, 11, 0,
    11, 4, 56, 0, 2,
];

const UPDATE_LIBRA_VERSION_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 5, 1, 0, 4, 3, 4, 10, 5, 14, 10, 7, 24, 52, 8, 76, 16, 0, 0, 0,
    1, 0, 2, 0, 1, 0, 1, 3, 0, 1, 0, 2, 6, 12, 3, 0, 3, 6, 12, 3, 3, 12, 76, 105, 98, 114, 97, 86,
    101, 114, 115, 105, 111, 110, 12, 83, 108, 105, 100, 105, 110, 103, 78, 111, 110, 99, 101, 3,
    115, 101, 116, 21, 114, 101, 99, 111, 114, 100, 95, 110, 111, 110, 99, 101, 95, 111, 114, 95,
    97, 98, 111, 114, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 7, 10, 0, 10,
    1, 17, 1, 11, 0, 10, 2, 17, 0, 2,
];

const UPDATE_MINTING_ABILITY_CODE: &[u8] = &[
    161, 28, 235, 11, 1, 0, 0, 0, 6, 1, 0, 2, 3, 2, 6, 4, 8, 2, 5, 10, 8, 7, 18, 29, 8, 47, 16, 0,
    0, 0, 1, 0, 1, 1, 1, 0, 2, 2, 6, 12, 1, 0, 1, 9, 0, 5, 76, 105, 98, 114, 97, 22, 117, 112, 100,
    97, 116, 101, 95, 109, 105, 110, 116, 105, 110, 103, 95, 97, 98, 105, 108, 105, 116, 121, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 4, 11, 0, 10, 1, 56, 0, 2,
];
